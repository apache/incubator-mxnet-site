<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.13" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>mxnet: mxnet::NDArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">mxnet
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="navpath" id="nav-path">
<ul>
<li class="navelem"><a class="el" href="namespacemxnet.html">mxnet</a></li><li class="navelem"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a></li> </ul>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pub-static-methods">Static Public Member Functions</a> |
<a href="#friends">Friends</a> |
<a href="classmxnet_1_1NDArray-members.html">List of all members</a> </div>
<div class="headertitle">
<div class="title">mxnet::NDArray Class Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>ndarray interface  
 <a href="classmxnet_1_1NDArray.html#details">More...</a></p>
<p><code>#include &lt;<a class="el" href="ndarray_8h_source.html">ndarray.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mxnet::NDArray:</div>
<div class="dyncontent">
<div class="center"><img alt="Collaboration graph" border="0" src="classmxnet_1_1NDArray__coll__graph.png" usemap="#mxnet_1_1NDArray_coll__map"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a12ec978e5dbe9092d21721a657c39756"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a12ec978e5dbe9092d21721a657c39756">NDArray</a> ()</td></tr>
<tr class="memdesc:a12ec978e5dbe9092d21721a657c39756"><td class="mdescLeft"> </td><td class="mdescRight">default constructor  <a href="#a12ec978e5dbe9092d21721a657c39756">More...</a><br/></td></tr>
<tr class="separator:a12ec978e5dbe9092d21721a657c39756"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8fb6d94c737c452e180650fdfe5228ad"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a8fb6d94c737c452e180650fdfe5228ad">NDArray</a> (const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>, <a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>, bool delay_alloc=false, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>=mshadow::default_type_flag)</td></tr>
<tr class="memdesc:a8fb6d94c737c452e180650fdfe5228ad"><td class="mdescLeft"> </td><td class="mdescRight">constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a8fb6d94c737c452e180650fdfe5228ad">More...</a><br/></td></tr>
<tr class="separator:a8fb6d94c737c452e180650fdfe5228ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45db645c41d0d6280d11de5ea84abf93"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a45db645c41d0d6280d11de5ea84abf93">NDArray</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>, <a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>, bool delay_alloc=true, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>=mshadow::default_type_flag, std::vector&lt; int &gt; <a class="el" href="classmxnet_1_1NDArray.html#aa475e532890ae08c2a63ea2707a5053b">aux_types</a>={}, std::vector&lt; <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &gt; <a class="el" href="classmxnet_1_1NDArray.html#a0fa1e4d8313eca87daa6c92d3f09b471">aux_shapes</a>={}, <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> <a class="el" href="classmxnet_1_1NDArray.html#a2070a7c45abb9f0a788459391a8ac657">storage_shape</a>=<a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>(mshadow::Shape1(0)))</td></tr>
<tr class="memdesc:a45db645c41d0d6280d11de5ea84abf93"><td class="mdescLeft"> </td><td class="mdescRight">constructor for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> with storage type  <a href="#a45db645c41d0d6280d11de5ea84abf93">More...</a><br/></td></tr>
<tr class="separator:a45db645c41d0d6280d11de5ea84abf93"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1a7288505ac9bbb19830161f7e5c1a6f"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1a7288505ac9bbb19830161f7e5c1a6f">NDArray</a> (const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, int dev_id)</td></tr>
<tr class="memdesc:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="mdescLeft"> </td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a1a7288505ac9bbb19830161f7e5c1a6f">More...</a><br/></td></tr>
<tr class="separator:a1a7288505ac9bbb19830161f7e5c1a6f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bdd6008f99b9f05ae45d44fa13d013e"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a6bdd6008f99b9f05ae45d44fa13d013e">NDArray</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#a0bb9681f2b23318ff38566ed71af26a9">aux_data</a>, int dev_id)</td></tr>
<tr class="memdesc:a6bdd6008f99b9f05ae45d44fa13d013e"><td class="mdescLeft"> </td><td class="mdescRight">constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> of non-default storage that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a6bdd6008f99b9f05ae45d44fa13d013e">More...</a><br/></td></tr>
<tr class="separator:a6bdd6008f99b9f05ae45d44fa13d013e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2fc268d12168d39d9095829b3b9a3836"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a> () const</td></tr>
<tr class="separator:a2fc268d12168d39d9095829b3b9a3836"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2070a7c45abb9f0a788459391a8ac657"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a2070a7c45abb9f0a788459391a8ac657">storage_shape</a> () const</td></tr>
<tr class="separator:a2070a7c45abb9f0a788459391a8ac657"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85083ab595fdc4986b191d4921b56654"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a85083ab595fdc4986b191d4921b56654">aux_shape</a> (size_t index) const</td></tr>
<tr class="memdesc:a85083ab595fdc4986b191d4921b56654"><td class="mdescLeft"> </td><td class="mdescRight">get the shape of aux_data(index)  <a href="#a85083ab595fdc4986b191d4921b56654">More...</a><br/></td></tr>
<tr class="separator:a85083ab595fdc4986b191d4921b56654"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0fa1e4d8313eca87daa6c92d3f09b471"><td align="right" class="memItemLeft" valign="top">const std::vector&lt; <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0fa1e4d8313eca87daa6c92d3f09b471">aux_shapes</a> () const</td></tr>
<tr class="separator:a0fa1e4d8313eca87daa6c92d3f09b471"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa475e532890ae08c2a63ea2707a5053b"><td align="right" class="memItemLeft" valign="top">const std::vector&lt; int &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa475e532890ae08c2a63ea2707a5053b">aux_types</a> () const</td></tr>
<tr class="separator:aa475e532890ae08c2a63ea2707a5053b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a802d468a953ca85636e4c44ee3bdb61c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a802d468a953ca85636e4c44ee3bdb61c">set_aux_shape</a> (size_t index, const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>) const</td></tr>
<tr class="memdesc:a802d468a953ca85636e4c44ee3bdb61c"><td class="mdescLeft"> </td><td class="mdescRight">For a sparse operation on a csr matrix for example, the size of the column index array is an estimated value in the beginning for allocating enough capacity for the final result. After the operation is done, the exact size of the shape is known and need to be reset using this function.  <a href="#a802d468a953ca85636e4c44ee3bdb61c">More...</a><br/></td></tr>
<tr class="separator:a802d468a953ca85636e4c44ee3bdb61c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade5c291caf0e240892b1bffaf7e5c8b5"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a> () const</td></tr>
<tr class="separator:ade5c291caf0e240892b1bffaf7e5c8b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c038544414ed2b992f9393a14eff6cd"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a9c038544414ed2b992f9393a14eff6cd">grad</a> () const</td></tr>
<tr class="separator:a9c038544414ed2b992f9393a14eff6cd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0bb9681f2b23318ff38566ed71af26a9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0bb9681f2b23318ff38566ed71af26a9">aux_data</a> (size_t i) const</td></tr>
<tr class="separator:a0bb9681f2b23318ff38566ed71af26a9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a26d1ddb2bb0ed1e671ce7606498b942d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a> () const</td></tr>
<tr class="separator:a26d1ddb2bb0ed1e671ce7606498b942d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67b0f8eb36568b4c9fbd3da2a1c4b0a3"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a> () const</td></tr>
<tr class="separator:a67b0f8eb36568b4c9fbd3da2a1c4b0a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac1f24bbdb0013050415ef0542d8273f1"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac1f24bbdb0013050415ef0542d8273f1">aux_type</a> (size_t i) const</td></tr>
<tr class="separator:ac1f24bbdb0013050415ef0542d8273f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67cb416db42a52288bb0a693026a8b97"><td align="right" class="memItemLeft" valign="top"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a67cb416db42a52288bb0a693026a8b97">storage_type</a> () const</td></tr>
<tr class="separator:a67cb416db42a52288bb0a693026a8b97"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a29673998ea5bec1cab7337595d907c67"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a29673998ea5bec1cab7337595d907c67">is_none</a> () const</td></tr>
<tr class="separator:a29673998ea5bec1cab7337595d907c67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad9d2fa3ffbe963fb5960375da1b557a2"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad9d2fa3ffbe963fb5960375da1b557a2">fresh_out_grad</a> () const</td></tr>
<tr class="separator:ad9d2fa3ffbe963fb5960375da1b557a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec1b90af51327c2956adf182c201de03"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aec1b90af51327c2956adf182c201de03">set_fresh_out_grad</a> (bool state) const</td></tr>
<tr class="separator:aec1b90af51327c2956adf182c201de03"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac4ccbd0815226566d65d53229f719222"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac4ccbd0815226566d65d53229f719222">storage_initialized</a> () const</td></tr>
<tr class="separator:ac4ccbd0815226566d65d53229f719222"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1cf4c49e6925d35586f75a1c9bdb51e4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1cf4c49e6925d35586f75a1c9bdb51e4">WaitToRead</a> () const</td></tr>
<tr class="memdesc:a1cf4c49e6925d35586f75a1c9bdb51e4"><td class="mdescLeft"> </td><td class="mdescRight">Block until all the pending write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and read can be performed.  <a href="#a1cf4c49e6925d35586f75a1c9bdb51e4">More...</a><br/></td></tr>
<tr class="separator:a1cf4c49e6925d35586f75a1c9bdb51e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8599450a4ba06b5890c5d06bd024d8e"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad8599450a4ba06b5890c5d06bd024d8e">WaitToWrite</a> () const</td></tr>
<tr class="memdesc:ad8599450a4ba06b5890c5d06bd024d8e"><td class="mdescLeft"> </td><td class="mdescRight">Block until all the pending read/write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and write can be performed.  <a href="#ad8599450a4ba06b5890c5d06bd024d8e">More...</a><br/></td></tr>
<tr class="separator:ad8599450a4ba06b5890c5d06bd024d8e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a168da55c01cc5c7a218d975af6b5b1f9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1Engine.html#aac31510c793a12944c33f9cac6150491">Engine::VarHandle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a168da55c01cc5c7a218d975af6b5b1f9">var</a> () const</td></tr>
<tr class="separator:a168da55c01cc5c7a218d975af6b5b1f9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7dd1143eeb4fbe15cebe85f28142551f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7dd1143eeb4fbe15cebe85f28142551f">Save</a> (dmlc::Stream *strm) const</td></tr>
<tr class="memdesc:a7dd1143eeb4fbe15cebe85f28142551f"><td class="mdescLeft"> </td><td class="mdescRight">save the content into binary stream  <a href="#a7dd1143eeb4fbe15cebe85f28142551f">More...</a><br/></td></tr>
<tr class="separator:a7dd1143eeb4fbe15cebe85f28142551f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b212c0a0c4c83c64a6bf6d0c430602b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0b212c0a0c4c83c64a6bf6d0c430602b">LegacyLoad</a> (dmlc::Stream *strm, const uint32_t magic)</td></tr>
<tr class="memdesc:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="mdescLeft"> </td><td class="mdescRight">load ndarrays before supporting sparse ndarrays  <a href="#a0b212c0a0c4c83c64a6bf6d0c430602b">More...</a><br/></td></tr>
<tr class="separator:a0b212c0a0c4c83c64a6bf6d0c430602b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5203aa033a53942deaecb7bb3bf46480"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5203aa033a53942deaecb7bb3bf46480">Load</a> (dmlc::Stream *strm)</td></tr>
<tr class="memdesc:a5203aa033a53942deaecb7bb3bf46480"><td class="mdescLeft"> </td><td class="mdescRight">load the content from binary stream  <a href="#a5203aa033a53942deaecb7bb3bf46480">More...</a><br/></td></tr>
<tr class="separator:a5203aa033a53942deaecb7bb3bf46480"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7a198e3e4c80a48cf92a913009aab8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa7a198e3e4c80a48cf92a913009aab8f">operator=</a> (<a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> scalar)</td></tr>
<tr class="memdesc:aa7a198e3e4c80a48cf92a913009aab8f"><td class="mdescLeft"> </td><td class="mdescRight">set all the elements in ndarray to be scalar  <a href="#aa7a198e3e4c80a48cf92a913009aab8f">More...</a><br/></td></tr>
<tr class="separator:aa7a198e3e4c80a48cf92a913009aab8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7df5a5d9956a481635fc43ca4d9a196c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7df5a5d9956a481635fc43ca4d9a196c">operator+=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:a7df5a5d9956a481635fc43ca4d9a196c"><td class="mdescLeft"> </td><td class="mdescRight">elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a7df5a5d9956a481635fc43ca4d9a196c">More...</a><br/></td></tr>
<tr class="separator:a7df5a5d9956a481635fc43ca4d9a196c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1068954b69113429bab7b369300fdbe0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1068954b69113429bab7b369300fdbe0">operator+=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a1068954b69113429bab7b369300fdbe0"><td class="mdescLeft"> </td><td class="mdescRight">elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a1068954b69113429bab7b369300fdbe0">More...</a><br/></td></tr>
<tr class="separator:a1068954b69113429bab7b369300fdbe0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad35ba01da6949494afe895b7429e4fc3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ad35ba01da6949494afe895b7429e4fc3">operator-=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:ad35ba01da6949494afe895b7429e4fc3"><td class="mdescLeft"> </td><td class="mdescRight">elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#ad35ba01da6949494afe895b7429e4fc3">More...</a><br/></td></tr>
<tr class="separator:ad35ba01da6949494afe895b7429e4fc3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a81a7b37678af0f23edc2beec6daca3ab"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a81a7b37678af0f23edc2beec6daca3ab">operator-=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a81a7b37678af0f23edc2beec6daca3ab"><td class="mdescLeft"> </td><td class="mdescRight">elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a81a7b37678af0f23edc2beec6daca3ab">More...</a><br/></td></tr>
<tr class="separator:a81a7b37678af0f23edc2beec6daca3ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1b47078a60bf0369ff0a7df893caf65b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1b47078a60bf0369ff0a7df893caf65b">operator*=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:a1b47078a60bf0369ff0a7df893caf65b"><td class="mdescLeft"> </td><td class="mdescRight">elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a1b47078a60bf0369ff0a7df893caf65b">More...</a><br/></td></tr>
<tr class="separator:a1b47078a60bf0369ff0a7df893caf65b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">operator*=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="mdescLeft"> </td><td class="mdescRight">elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">More...</a><br/></td></tr>
<tr class="separator:a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aebc61006705874666423c45f161df546"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aebc61006705874666423c45f161df546">operator/=</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src)</td></tr>
<tr class="memdesc:aebc61006705874666423c45f161df546"><td class="mdescLeft"> </td><td class="mdescRight">elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#aebc61006705874666423c45f161df546">More...</a><br/></td></tr>
<tr class="separator:aebc61006705874666423c45f161df546"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab88b476b2092b30c7d456d99df9f36e3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ab88b476b2092b30c7d456d99df9f36e3">operator/=</a> (const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp;src)</td></tr>
<tr class="memdesc:ab88b476b2092b30c7d456d99df9f36e3"><td class="mdescLeft"> </td><td class="mdescRight">elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#ab88b476b2092b30c7d456d99df9f36e3">More...</a><br/></td></tr>
<tr class="separator:ab88b476b2092b30c7d456d99df9f36e3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7876b8d60109a18feabe767d85f66226"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a7876b8d60109a18feabe767d85f66226">T</a> () const</td></tr>
<tr class="memdesc:a7876b8d60109a18feabe767d85f66226"><td class="mdescLeft"> </td><td class="mdescRight">return transpose of current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a7876b8d60109a18feabe767d85f66226">More...</a><br/></td></tr>
<tr class="separator:a7876b8d60109a18feabe767d85f66226"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6617e1bf4242314f7ee6b6e3a66ce493"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a6617e1bf4242314f7ee6b6e3a66ce493">Copy</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> <a class="el" href="classmxnet_1_1NDArray.html#a26d1ddb2bb0ed1e671ce7606498b942d">ctx</a>) const</td></tr>
<tr class="memdesc:a6617e1bf4242314f7ee6b6e3a66ce493"><td class="mdescLeft"> </td><td class="mdescRight">return a new copy this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> <a href="#a6617e1bf4242314f7ee6b6e3a66ce493">More...</a><br/></td></tr>
<tr class="separator:a6617e1bf4242314f7ee6b6e3a66ce493"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac390edfdd8a7dd99f69ea373f4d18e1a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac390edfdd8a7dd99f69ea373f4d18e1a">SyncCopyFromCPU</a> (const void *<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, size_t size) const</td></tr>
<tr class="memdesc:ac390edfdd8a7dd99f69ea373f4d18e1a"><td class="mdescLeft"> </td><td class="mdescRight">Do a synchronize copy from a continugous CPU memory region.  <a href="#ac390edfdd8a7dd99f69ea373f4d18e1a">More...</a><br/></td></tr>
<tr class="separator:ac390edfdd8a7dd99f69ea373f4d18e1a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3943fcf632304f6ab165b8628710609"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#aa3943fcf632304f6ab165b8628710609">SyncCopyFromNDArray</a> (const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;src, int i=-1, int j=-1)</td></tr>
<tr class="memdesc:aa3943fcf632304f6ab165b8628710609"><td class="mdescLeft"> </td><td class="mdescRight">Copy from src.data()/aux_data(i) to this-&gt;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a>/aux_data(j)  <a href="#aa3943fcf632304f6ab165b8628710609">More...</a><br/></td></tr>
<tr class="separator:aa3943fcf632304f6ab165b8628710609"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb3dbc357c53e1e0b980257f6c5e2cac"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#afb3dbc357c53e1e0b980257f6c5e2cac">SyncCopyToCPU</a> (void *<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, size_t size) const</td></tr>
<tr class="memdesc:afb3dbc357c53e1e0b980257f6c5e2cac"><td class="mdescLeft"> </td><td class="mdescRight">Do a synchronize copy to a continugous CPU memory region.  <a href="#afb3dbc357c53e1e0b980257f6c5e2cac">More...</a><br/></td></tr>
<tr class="separator:afb3dbc357c53e1e0b980257f6c5e2cac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0cfa7466a652feb2258bb990453a0a7d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a0cfa7466a652feb2258bb990453a0a7d">Slice</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> begin, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> end) const</td></tr>
<tr class="memdesc:a0cfa7466a652feb2258bb990453a0a7d"><td class="mdescLeft"> </td><td class="mdescRight">Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a0cfa7466a652feb2258bb990453a0a7d">More...</a><br/></td></tr>
<tr class="separator:a0cfa7466a652feb2258bb990453a0a7d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:addb42a7353a4c07b2d1bae0afa8ef48e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#addb42a7353a4c07b2d1bae0afa8ef48e">At</a> (<a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> idx) const</td></tr>
<tr class="memdesc:addb42a7353a4c07b2d1bae0afa8ef48e"><td class="mdescLeft"> </td><td class="mdescRight">Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#addb42a7353a4c07b2d1bae0afa8ef48e">More...</a><br/></td></tr>
<tr class="separator:addb42a7353a4c07b2d1bae0afa8ef48e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3279047ec28e02b794e7662ec68384a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac3279047ec28e02b794e7662ec68384a">aux_ndarray</a> (size_t i) const</td></tr>
<tr class="memdesc:ac3279047ec28e02b794e7662ec68384a"><td class="mdescLeft"> </td><td class="mdescRight">Generate a deep copy of aux_data(i) returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#ac3279047ec28e02b794e7662ec68384a">More...</a><br/></td></tr>
<tr class="separator:ac3279047ec28e02b794e7662ec68384a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae14d45e2bae697565a0723f4963db7e4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ae14d45e2bae697565a0723f4963db7e4">data_ndarray</a> () const</td></tr>
<tr class="memdesc:ae14d45e2bae697565a0723f4963db7e4"><td class="mdescLeft"> </td><td class="mdescRight">Generate a deep copy of <a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a> returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#ae14d45e2bae697565a0723f4963db7e4">More...</a><br/></td></tr>
<tr class="separator:ae14d45e2bae697565a0723f4963db7e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3c424c05eabe0b7a4976191d81cf6b0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ac3c424c05eabe0b7a4976191d81cf6b0">AsArray</a> (const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>, int <a class="el" href="classmxnet_1_1NDArray.html#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">dtype</a>) const</td></tr>
<tr class="memdesc:ac3c424c05eabe0b7a4976191d81cf6b0"><td class="mdescLeft"> </td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares memory with current one The new array must have smaller memory size than the current array.  <a href="#ac3c424c05eabe0b7a4976191d81cf6b0">More...</a><br/></td></tr>
<tr class="separator:ac3c424c05eabe0b7a4976191d81cf6b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d01269333b9226fffddc89ce3b7fb63"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a1d01269333b9226fffddc89ce3b7fb63">Reshape</a> (const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>) const</td></tr>
<tr class="memdesc:a1d01269333b9226fffddc89ce3b7fb63"><td class="mdescLeft"> </td><td class="mdescRight">Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>.  <a href="#a1d01269333b9226fffddc89ce3b7fb63">More...</a><br/></td></tr>
<tr class="separator:a1d01269333b9226fffddc89ce3b7fb63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a76646c5c7e164bd7c81854521d3bee52"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a76646c5c7e164bd7c81854521d3bee52">Detach</a> () const</td></tr>
<tr class="memdesc:a76646c5c7e164bd7c81854521d3bee52"><td class="mdescLeft"> </td><td class="mdescRight">Return a copy of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> without autograd history.  <a href="#a76646c5c7e164bd7c81854521d3bee52">More...</a><br/></td></tr>
<tr class="separator:a76646c5c7e164bd7c81854521d3bee52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5ef20369f37a4ff2ceb44adf213871dc"><td align="right" class="memItemLeft" valign="top">nnvm::Symbol </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a5ef20369f37a4ff2ceb44adf213871dc">get_autograd_symbol</a> ()</td></tr>
<tr class="separator:a5ef20369f37a4ff2ceb44adf213871dc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a531a3437dde0dfc9b0c40a32450f4c7a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a531a3437dde0dfc9b0c40a32450f4c7a">CheckAndAlloc</a> () const</td></tr>
<tr class="memdesc:a531a3437dde0dfc9b0c40a32450f4c7a"><td class="mdescLeft"> </td><td class="mdescRight">Allocate the space if it is delayed allocated. This is an internal function used by system that normal user should not use.  <a href="#a531a3437dde0dfc9b0c40a32450f4c7a">More...</a><br/></td></tr>
<tr class="separator:a531a3437dde0dfc9b0c40a32450f4c7a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a15af0cf321dbe235b6900417d4847aae"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a15af0cf321dbe235b6900417d4847aae">ReshapeAndAlloc</a> (const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2fc268d12168d39d9095829b3b9a3836">shape</a>)</td></tr>
<tr class="memdesc:a15af0cf321dbe235b6900417d4847aae"><td class="mdescLeft"> </td><td class="mdescRight">Allocate the space if the allocation has been delayed or the requested size is bigger than the available one. This function can only be called by ndarray of default storage type and effectively changes the ndarray's shape_. Note: This function is named as this to avoid overload conflict with CheckAndAlloc(const std::vector&lt;TShape&gt; &amp;aux_shapes), since TShape tmp = some_shape is equivalent to TShape tmp = {some_shape}.  <a href="#a15af0cf321dbe235b6900417d4847aae">More...</a><br/></td></tr>
<tr class="separator:a15af0cf321dbe235b6900417d4847aae"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a76a28fa9bd27a652f6f329a864b74e72"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a76a28fa9bd27a652f6f329a864b74e72">CheckAndAlloc</a> (const std::vector&lt; <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#a0fa1e4d8313eca87daa6c92d3f09b471">aux_shapes</a>) const</td></tr>
<tr class="separator:a76a28fa9bd27a652f6f329a864b74e72"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39ff0b6bf5dc896d7f47029d34ec294c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a39ff0b6bf5dc896d7f47029d34ec294c">CheckAndAllocData</a> (const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a2070a7c45abb9f0a788459391a8ac657">storage_shape</a>) const</td></tr>
<tr class="separator:a39ff0b6bf5dc896d7f47029d34ec294c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af02e3c29186f5ab995a0d2c439feb8f9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#af02e3c29186f5ab995a0d2c439feb8f9">CheckAndAllocAuxData</a> (size_t i, const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp;<a class="el" href="classmxnet_1_1NDArray.html#a85083ab595fdc4986b191d4921b56654">aux_shape</a>) const</td></tr>
<tr class="separator:af02e3c29186f5ab995a0d2c439feb8f9"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af215b7a886e717b4bb3c911fe3c1a032"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#af215b7a886e717b4bb3c911fe3c1a032">Save</a> (dmlc::Stream *fo, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:af215b7a886e717b4bb3c911fe3c1a032"><td class="mdescLeft"> </td><td class="mdescRight">Save list of ndarray into the Stream.x.  <a href="#af215b7a886e717b4bb3c911fe3c1a032">More...</a><br/></td></tr>
<tr class="separator:af215b7a886e717b4bb3c911fe3c1a032"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae45c38de80d6d4dc79ad3d24baa9e981"><td align="right" class="memItemLeft" valign="top">static void </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#ae45c38de80d6d4dc79ad3d24baa9e981">Load</a> (dmlc::Stream *fi, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data</a>, std::vector&lt; std::string &gt; *keys)</td></tr>
<tr class="memdesc:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="mdescLeft"> </td><td class="mdescRight">Load list of ndarray into from the stream.  <a href="#ae45c38de80d6d4dc79ad3d24baa9e981">More...</a><br/></td></tr>
<tr class="separator:ae45c38de80d6d4dc79ad3d24baa9e981"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a423cc97aa03ee0dd8bc13781b77b8e50"><td align="right" class="memItemLeft" valign="top">class </td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1NDArray.html#a423cc97aa03ee0dd8bc13781b77b8e50">autograd::AutogradRuntime</a></td></tr>
<tr class="separator:a423cc97aa03ee0dd8bc13781b77b8e50"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ndarray interface </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a12ec978e5dbe9092d21721a657c39756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ec978e5dbe9092d21721a657c39756">◆ </a></span>NDArray() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>default constructor </p>
</div>
</div>
<a id="a8fb6d94c737c452e180650fdfe5228ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb6d94c737c452e180650fdfe5228ad">◆ </a></span>NDArray() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>delay_alloc</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> = <code>mshadow::default_type_flag</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructs a new dynamic <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>the shape of array </td></tr>
<tr><td class="paramname">ctx</td><td>context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">delay_alloc</td><td>whether delay the allocation </td></tr>
<tr><td class="paramname">dtype</td><td>data type of this ndarray </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a45db645c41d0d6280d11de5ea84abf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45db645c41d0d6280d11de5ea84abf93">◆ </a></span>NDArray() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td>
<td class="paramname"><em>stype</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>delay_alloc</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> = <code>mshadow::default_type_flag</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; </td>
<td class="paramname"><em>aux_types</em> = <code>{}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &gt; </td>
<td class="paramname"><em>aux_shapes</em> = <code>{}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> </td>
<td class="paramname"><em>storage_shape</em> = <code><a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>(mshadow::Shape1(0))</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructor for <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> with storage type </p>
</div>
</div>
<a id="a1a7288505ac9bbb19830161f7e5c1a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7288505ac9bbb19830161f7e5c1a6f">◆ </a></span>NDArray() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dev_id</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
<tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a6bdd6008f99b9f05ae45d44fa13d013e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdd6008f99b9f05ae45d44fa13d013e">◆ </a></span>NDArray() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">mxnet::NDArray::NDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> </td>
<td class="paramname"><em>stype</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; &amp; </td>
<td class="paramname"><em>aux_data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dev_id</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>constructing a static <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> of non-default storage that shares data with <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> Use with caution: allocate ONLY ONE <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> for each <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a>, make sure the memory region is available through out the life of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">stype</td><td>the storage type of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">shape</td><td>the shape of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
<tr><td class="paramname">data</td><td>the memory content of static data </td></tr>
<tr><td class="paramname">aux_data</td><td>the memory content of static aux data </td></tr>
<tr><td class="paramname">dev_id</td><td>the device id this tensor sits at </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3c424c05eabe0b7a4976191d81cf6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c424c05eabe0b7a4976191d81cf6b0">◆ </a></span>AsArray()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::AsArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dtype</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> that shares memory with current one The new array must have smaller memory size than the current array. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>new shape </td></tr>
<tr><td class="paramname">dtype</td><td>The data type. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape and type. </dd></dl>
</div>
</div>
<a id="addb42a7353a4c07b2d1bae0afa8ef48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb42a7353a4c07b2d1bae0afa8ef48e">◆ </a></span>At()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::At </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>idx</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Index a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">idx</td><td>the index </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx-th sub array <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a id="a0bb9681f2b23318ff38566ed71af26a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb9681f2b23318ff38566ed71af26a9">◆ </a></span>aux_data()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> mxnet::NDArray::aux_data </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the aux <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> </dd></dl>
</div>
</div>
<a id="ac3279047ec28e02b794e7662ec68384a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3279047ec28e02b794e7662ec68384a">◆ </a></span>aux_ndarray()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::aux_ndarray </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Generate a deep copy of aux_data(i) returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
</div>
</div>
<a id="a85083ab595fdc4986b191d4921b56654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85083ab595fdc4986b191d4921b56654">◆ </a></span>aux_shape()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>&amp; mxnet::NDArray::aux_shape </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>index</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>get the shape of aux_data(index) </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">index</td><td>the index of the aux data </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shape of aux data at given index </dd></dl>
</div>
</div>
<a id="a0fa1e4d8313eca87daa6c92d3f09b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa1e4d8313eca87daa6c92d3f09b471">◆ </a></span>aux_shapes()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const std::vector&lt;<a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>&gt;&amp; mxnet::NDArray::aux_shapes </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac1f24bbdb0013050415ef0542d8273f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f24bbdb0013050415ef0542d8273f1">◆ </a></span>aux_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int mxnet::NDArray::aux_type </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa475e532890ae08c2a63ea2707a5053b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa475e532890ae08c2a63ea2707a5053b">◆ </a></span>aux_types()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const std::vector&lt;int&gt;&amp; mxnet::NDArray::aux_types </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>returns the dtypes of all aux data </p>
</div>
</div>
<a id="a531a3437dde0dfc9b0c40a32450f4c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531a3437dde0dfc9b0c40a32450f4c7a">◆ </a></span>CheckAndAlloc() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAlloc </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Allocate the space if it is delayed allocated. This is an internal function used by system that normal user should not use. </p>
</div>
</div>
<a id="a76a28fa9bd27a652f6f329a864b74e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a28fa9bd27a652f6f329a864b74e72">◆ </a></span>CheckAndAlloc() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAlloc </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &gt; &amp; </td>
<td class="paramname"><em>aux_shapes</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af02e3c29186f5ab995a0d2c439feb8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e3c29186f5ab995a0d2c439feb8f9">◆ </a></span>CheckAndAllocAuxData()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAllocAuxData </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>i</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>aux_shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a39ff0b6bf5dc896d7f47029d34ec294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ff0b6bf5dc896d7f47029d34ec294c">◆ </a></span>CheckAndAllocData()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::CheckAndAllocData </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>storage_shape</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a6617e1bf4242314f7ee6b6e3a66ce493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6617e1bf4242314f7ee6b6e3a66ce493">◆ </a></span>Copy()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Copy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a> </td>
<td class="paramname"><em>ctx</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>return a new copy this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ctx</td><td>the new context of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new copy </dd></dl>
</div>
</div>
<a id="a26d1ddb2bb0ed1e671ce7606498b942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d1ddb2bb0ed1e671ce7606498b942d">◆ </a></span>ctx()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structmxnet_1_1Context.html">Context</a> mxnet::NDArray::ctx </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the context of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, this function is only valid when the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is not empty </dd></dl>
</div>
</div>
<a id="ade5c291caf0e240892b1bffaf7e5c8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5c291caf0e240892b1bffaf7e5c8b5">◆ </a></span>data()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a>&amp; mxnet::NDArray::data </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data <a class="el" href="classmxnet_1_1TBlob.html" title="tensor blob class that can be used to hold tensor of any dimension, any device and any data type...">TBlob</a> </dd></dl>
</div>
</div>
<a id="ae14d45e2bae697565a0723f4963db7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14d45e2bae697565a0723f4963db7e4">◆ </a></span>data_ndarray()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::data_ndarray </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Generate a deep copy of <a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a> returned as a default storage type <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
</div>
</div>
<a id="a76646c5c7e164bd7c81854521d3bee52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76646c5c7e164bd7c81854521d3bee52">◆ </a></span>Detach()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Detach </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Return a copy of this <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> without autograd history. </p>
</div>
</div>
<a id="a67b0f8eb36568b4c9fbd3da2a1c4b0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b0f8eb36568b4c9fbd3da2a1c4b0a3">◆ </a></span>dtype()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">int mxnet::NDArray::dtype </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data type of <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, this function is only valid when the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> is not empty </dd></dl>
</div>
</div>
<a id="ad9d2fa3ffbe963fb5960375da1b557a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d2fa3ffbe963fb5960375da1b557a2">◆ </a></span>fresh_out_grad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::fresh_out_grad </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>updated grad state in entry_ </dd></dl>
</div>
</div>
<a id="a5ef20369f37a4ff2ceb44adf213871dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef20369f37a4ff2ceb44adf213871dc">◆ </a></span>get_autograd_symbol()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">nnvm::Symbol mxnet::NDArray::get_autograd_symbol </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9c038544414ed2b992f9393a14eff6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c038544414ed2b992f9393a14eff6cd">◆ </a></span>grad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::grad </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the gradient ndarray. </dd></dl>
</div>
</div>
<a id="a29673998ea5bec1cab7337595d907c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29673998ea5bec1cab7337595d907c67">◆ </a></span>is_none()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::is_none </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether this ndarray is not initialized </dd></dl>
</div>
</div>
<a id="a0b212c0a0c4c83c64a6bf6d0c430602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b212c0a0c4c83c64a6bf6d0c430602b">◆ </a></span>LegacyLoad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::LegacyLoad </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>strm</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint32_t </td>
<td class="paramname"><em>magic</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>load ndarrays before supporting sparse ndarrays </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strm</td><td>the output stream </td></tr>
<tr><td class="paramname">magic</td><td>the magic number used for version control </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a5203aa033a53942deaecb7bb3bf46480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5203aa033a53942deaecb7bb3bf46480">◆ </a></span>Load() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::Load </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>strm</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>load the content from binary stream </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strm</td><td>the output stream </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the load is successful </dd></dl>
</div>
</div>
<a id="ae45c38de80d6d4dc79ad3d24baa9e981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45c38de80d6d4dc79ad3d24baa9e981">◆ </a></span>Load() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void mxnet::NDArray::Load </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>fi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::string &gt; * </td>
<td class="paramname"><em>keys</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Load list of ndarray into from the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">fi</td><td>The stream of the input file. </td></tr>
<tr><td class="paramname">data</td><td>the NDArrays to be loaded </td></tr>
<tr><td class="paramname">keys</td><td>the name of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, if saved in the file. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a1b47078a60bf0369ff0a7df893caf65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b47078a60bf0369ff0a7df893caf65b">◆ </a></span>operator*=() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator*= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4b2ac8b0c154ae8c53ebfd2d1d3fcf">◆ </a></span>operator*=() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator*= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise multiplication to current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="a7df5a5d9956a481635fc43ca4d9a196c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df5a5d9956a481635fc43ca4d9a196c">◆ </a></span>operator+=() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator+= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to add </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="a1068954b69113429bab7b369300fdbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1068954b69113429bab7b369300fdbe0">◆ </a></span>operator+=() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator+= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise add to current space this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to add </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="ad35ba01da6949494afe895b7429e4fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35ba01da6949494afe895b7429e4fc3">◆ </a></span>operator-=() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator-= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="a81a7b37678af0f23edc2beec6daca3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a7b37678af0f23edc2beec6daca3ab">◆ </a></span>operator-=() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator-= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise subtract from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="aebc61006705874666423c45f161df546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc61006705874666423c45f161df546">◆ </a></span>operator/=() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator/= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="ab88b476b2092b30c7d456d99df9f36e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88b476b2092b30c7d456d99df9f36e3">◆ </a></span>operator/=() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator/= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> &amp; </td>
<td class="paramname"><em>src</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>elementwise division from current ndarray this mutate the current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">src</td><td>the data to subtract </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="aa7a198e3e4c80a48cf92a913009aab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a198e3e4c80a48cf92a913009aab8f">◆ </a></span>operator=()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&amp; mxnet::NDArray::operator= </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a4421326e33f2a848cb2fa3e70ab24ff4">real_t</a> </td>
<td class="paramname"><em>scalar</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>set all the elements in ndarray to be scalar </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">scalar</td><td>the scalar to set </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference of self </dd></dl>
</div>
</div>
<a id="a1d01269333b9226fffddc89ce3b7fb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d01269333b9226fffddc89ce3b7fb63">◆ </a></span>Reshape()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Reshape </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Get an reshaped <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">shape</td><td>new shape </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> in new shape </dd></dl>
</div>
</div>
<a id="a15af0cf321dbe235b6900417d4847aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15af0cf321dbe235b6900417d4847aae">◆ </a></span>ReshapeAndAlloc()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::ReshapeAndAlloc </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Allocate the space if the allocation has been delayed or the requested size is bigger than the available one. This function can only be called by ndarray of default storage type and effectively changes the ndarray's shape_. Note: This function is named as this to avoid overload conflict with CheckAndAlloc(const std::vector&lt;TShape&gt; &amp;aux_shapes), since TShape tmp = some_shape is equivalent to TShape tmp = {some_shape}. </p>
</div>
</div>
<a id="a7dd1143eeb4fbe15cebe85f28142551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd1143eeb4fbe15cebe85f28142551f">◆ </a></span>Save() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::Save </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>strm</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>save the content into binary stream </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strm</td><td>the output stream </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af215b7a886e717b4bb3c911fe3c1a032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af215b7a886e717b4bb3c911fe3c1a032">◆ </a></span>Save() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static void mxnet::NDArray::Save </td>
<td>(</td>
<td class="paramtype">dmlc::Stream * </td>
<td class="paramname"><em>fo</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp; </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; std::string &gt; &amp; </td>
<td class="paramname"><em>names</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Save list of ndarray into the Stream.x. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">fo</td><td>The stream of output. </td></tr>
<tr><td class="paramname">data</td><td>the NDArrays to be saved. </td></tr>
<tr><td class="paramname">names</td><td>the name of the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>, optional, can be zero length. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a802d468a953ca85636e4c44ee3bdb61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d468a953ca85636e4c44ee3bdb61c">◆ </a></span>set_aux_shape()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::set_aux_shape </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>index</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a> &amp; </td>
<td class="paramname"><em>shape</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>For a sparse operation on a csr matrix for example, the size of the column index array is an estimated value in the beginning for allocating enough capacity for the final result. After the operation is done, the exact size of the shape is known and need to be reset using this function. </p>
</div>
</div>
<a id="aec1b90af51327c2956adf182c201de03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1b90af51327c2956adf182c201de03">◆ </a></span>set_fresh_out_grad()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::set_fresh_out_grad </td>
<td>(</td>
<td class="paramtype">bool </td>
<td class="paramname"><em>state</em></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>updated grad state in entry_ </dd></dl>
</div>
</div>
<a id="a2fc268d12168d39d9095829b3b9a3836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc268d12168d39d9095829b3b9a3836">◆ </a></span>shape()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>&amp; mxnet::NDArray::shape </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </dd></dl>
</div>
</div>
<a id="a0cfa7466a652feb2258bb990453a0a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfa7466a652feb2258bb990453a0a7d">◆ </a></span>Slice()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::Slice </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>begin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> </td>
<td class="paramname"><em>end</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Slice a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">begin</td><td>begin index in first dim (inclusive) </td></tr>
<tr><td class="paramname">end</td><td>end index in first dim (exclusive) </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sliced <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a id="ac4ccbd0815226566d65d53229f719222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ccbd0815226566d65d53229f719222">◆ </a></span>storage_initialized()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool mxnet::NDArray::storage_initialized </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2070a7c45abb9f0a788459391a8ac657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2070a7c45abb9f0a788459391a8ac657">◆ </a></span>storage_shape()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">TShape</a>&amp; mxnet::NDArray::storage_shape </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shape of underlying chunk which stores the <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> data/value. It is only intended for non-default storage. For row-sparse storage, it is the shape of the tensor which stores the non-zero values. </dd></dl>
</div>
</div>
<a id="a67cb416db42a52288bb0a693026a8b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cb416db42a52288bb0a693026a8b97">◆ </a></span>storage_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> mxnet::NDArray::storage_type </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac390edfdd8a7dd99f69ea373f4d18e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac390edfdd8a7dd99f69ea373f4d18e1a">◆ </a></span>SyncCopyFromCPU()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCopyFromCPU </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Do a synchronize copy from a continugous CPU memory region. </p>
<p>This function will call WaitToWrite before the copy is performed. This is useful to copy data from existing memory region that are not wrapped by NDArray(thus dependency not being tracked).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the data source to copy from. </td></tr>
<tr><td class="paramname">size</td><td>the size of the source array, in sizeof(DType) not raw btyes. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aa3943fcf632304f6ab165b8628710609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3943fcf632304f6ab165b8628710609">◆ </a></span>SyncCopyFromNDArray()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCopyFromNDArray </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp; </td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>i</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>j</em> = <code>-1</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copy from src.data()/aux_data(i) to this-&gt;<a class="el" href="classmxnet_1_1NDArray.html#ade5c291caf0e240892b1bffaf7e5c8b5">data()</a>/aux_data(j) </p>
</div>
</div>
<a id="afb3dbc357c53e1e0b980257f6c5e2cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3dbc357c53e1e0b980257f6c5e2cac">◆ </a></span>SyncCopyToCPU()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::SyncCopyToCPU </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>Do a synchronize copy to a continugous CPU memory region. </p>
<p>This function will call WaitToRead before the copy is performed. This is useful to copy data from existing memory region that are not wrapped by NDArray(thus dependency not being tracked).</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>the data source to copyinto. </td></tr>
<tr><td class="paramname">size</td><td>the memory size we want to copy into, in sizeof(DType) not raw btyes. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a7876b8d60109a18feabe767d85f66226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7876b8d60109a18feabe767d85f66226">◆ </a></span>T()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::NDArray::T </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div><div class="memdoc">
<p>return transpose of current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </p>
<dl class="section return"><dt>Returns</dt><dd>a new transposed <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> </dd></dl>
</div>
</div>
<a id="a168da55c01cc5c7a218d975af6b5b1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168da55c01cc5c7a218d975af6b5b1f9">◆ </a></span>var()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classmxnet_1_1Engine.html#aac31510c793a12944c33f9cac6150491">Engine::VarHandle</a> mxnet::NDArray::var </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the associated variable of the ndarray. </dd></dl>
</div>
</div>
<a id="a1cf4c49e6925d35586f75a1c9bdb51e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf4c49e6925d35586f75a1c9bdb51e4">◆ </a></span>WaitToRead()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::WaitToRead </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Block until all the pending write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and read can be performed. </p>
</div>
</div>
<a id="ad8599450a4ba06b5890c5d06bd024d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8599450a4ba06b5890c5d06bd024d8e">◆ </a></span>WaitToWrite()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void mxnet::NDArray::WaitToWrite </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Block until all the pending read/write operations with respect to current <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface ">NDArray</a> are finished, and write can be performed. </p>
<p>Push an empty mutable function to flush all preceding reads to the variable.</p>
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a423cc97aa03ee0dd8bc13781b77b8e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423cc97aa03ee0dd8bc13781b77b8e50">◆ </a></span>autograd::AutogradRuntime</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">friend class autograd::AutogradRuntime</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mxnet/<a class="el" href="ndarray_8h_source.html">ndarray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 8 2017 08:20:39 for mxnet by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.13
</small></address>
</body>
</html>
