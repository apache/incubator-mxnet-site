<!DOCTYPE html >

<html>
<head>
<title>NDArray - org.apache.mxnet.NDArray</title>
<meta content="NDArray - org.apache.mxnet.NDArray" name="description"/>
<meta content="NDArray org.apache.mxnet.NDArray" name="keywords"/>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<link href="../../../lib/template.css" media="screen" rel="stylesheet" type="text/css"/>
<link href="../../../lib/diagrams.css" id="diagrams-css" media="screen" rel="stylesheet" type="text/css"/>
<script id="jquery-js" src="../../../lib/jquery.js" type="text/javascript"></script>
<script src="../../../lib/jquery-ui.js" type="text/javascript"></script>
<script src="../../../lib/template.js" type="text/javascript"></script>
<script src="../../../lib/tools.tooltip.js" type="text/javascript"></script>
<script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'org.apache.mxnet.NDArray$';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
</head>
<body class="value">
<div id="definition">
<a href="NDArray.html" title="See companion class"><img src="../../../lib/object_to_class_big.png"/></a>
<p id="owner"><a class="extype" href="../../package.html" name="org">org</a>.<a class="extype" href="../package.html" name="org.apache">apache</a>.<a class="extype" href="package.html" name="org.apache.mxnet">mxnet</a></p>
<h1><a href="NDArray.html" title="See companion class">NDArray</a></h1><h3><span class="morelinks"><div>
            Related Docs:
            <a href="NDArray.html" title="See companion class">class NDArray</a>
            | <a class="extype" href="package.html" name="org.apache.mxnet">package mxnet</a>
</div></span></h3><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</div>
<h4 class="signature" id="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">object</span>
</span>
<span class="symbol">
<span class="name">NDArray</span><span class="result"> extends <a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></span>
</span>
</h4>
<div class="fullcommenttop" id="comment"><div class="comment cmt"><p>NDArray Object extends from NDArrayBase for abstract function signatures
Main code will be generated during compile time through Macros
</p></div><div class="toggleContainer block">
<span class="toggle">Linear Supertypes</span>
<div class="superTypes hiddenContent"><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
</div></div>
<div id="mbrsel">
<div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" id="mbrsel-input" type="text"/></span><span class="post"></span></div>
<div id="order">
<span class="filtertype">Ordering</span>
<ol>
<li class="alpha in"><span>Alphabetic</span></li>
<li class="inherit out"><span>By inheritance</span></li>
</ol>
</div>
<div id="ancestors">
<span class="filtertype">Inherited<br/>
</span>
<ol id="linearization">
<li class="in" name="org.apache.mxnet.NDArray"><span>NDArray</span></li><li class="in" name="org.apache.mxnet.NDArrayBase"><span>NDArrayBase</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
</ol>
</div><div id="ancestors">
<span class="filtertype"></span>
<ol>
<li class="hideall out"><span>Hide All</span></li>
<li class="showall in"><span>Show all</span></li>
</ol>
<a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
</div>
<div id="visbl">
<span class="filtertype">Visibility</span>
<ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
</div>
</div>
<div id="template">
<div id="allMembers">
<div class="values members" id="values">
<h3>Abstract Value Members</h3>
<ol><li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Activation" visbl="pub">
<a id="Activation(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Activation(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Activation</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Activation(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies an activation function element-wise to the input.

The following activation functions are supported:

- `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
- `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
- `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
- `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
- `softsign`: :math:`y = \frac{x}{1 + abs(x)}`



Defined in src/operator/nn/activation.cc:L184
</pre></p></li></ol></div></div></div></body></html><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies an activation function element-wise to the input.

The following activation functions are supported:

- `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
- `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
- `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
- `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
- `softsign`: :math:`y = \frac{x}{1 + abs(x)}`



Defined in src/operator/nn/activation.cc:L184
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Activation" visbl="pub">
<a id="Activation(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Activation(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Activation</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Activation(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies an activation function element-wise to the input.

The following activation functions are supported:

- `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
- `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
- `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
- `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
- `softsign`: :math:`y = \frac{x}{1 + abs(x)}`



Defined in src/operator/nn/activation.cc:L184
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies an activation function element-wise to the input.

The following activation functions are supported:

- `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`
- `sigmoid`: :math:`y = \frac{1}{1 + exp(-x)}`
- `tanh`: Hyperbolic tangent, :math:`y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`
- `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`
- `softsign`: :math:`y = \frac{x}{1 + abs(x)}`



Defined in src/operator/nn/activation.cc:L184
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BatchNorm" visbl="pub">
<a id="BatchNorm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BatchNorm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BatchNorm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BatchNorm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Batch normalization.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
two outputs are blocked.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
axis to be the last item in the input shape.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

Note::

When fix_gamma is set to True, no sparse support is provided. If fix_gamma is set to False,
the sparse tensors will fallback.



Defined in src/operator/nn/batch_norm.cc:L574
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Batch normalization.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
two outputs are blocked.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
axis to be the last item in the input shape.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

Note::

When fix_gamma is set to True, no sparse support is provided. If fix_gamma is set to False,
the sparse tensors will fallback.



Defined in src/operator/nn/batch_norm.cc:L574
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BatchNorm" visbl="pub">
<a id="BatchNorm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BatchNorm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BatchNorm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BatchNorm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Batch normalization.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
two outputs are blocked.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
axis to be the last item in the input shape.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

Note::

When fix_gamma is set to True, no sparse support is provided. If fix_gamma is set to False,
the sparse tensors will fallback.



Defined in src/operator/nn/batch_norm.cc:L574
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Batch normalization.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
the inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these
two outputs are blocked.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
axis to be the last item in the input shape.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

Note::

When fix_gamma is set to True, no sparse support is provided. If fix_gamma is set to False,
the sparse tensors will fallback.



Defined in src/operator/nn/batch_norm.cc:L574
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BatchNorm_v1" visbl="pub">
<a id="BatchNorm_v1(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BatchNorm_v1(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BatchNorm_v1</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BatchNorm_v1(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Batch normalization.

This operator is DEPRECATED. Perform BatchNorm on the input.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_var`` as well, which are needed for the backward pass.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

There's no sparse support for this operator, and it will exhibit problematic behavior if used with
sparse tensors.



Defined in src/operator/batch_norm_v1.cc:L95
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Batch normalization.

This operator is DEPRECATED. Perform BatchNorm on the input.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_var`` as well, which are needed for the backward pass.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

There's no sparse support for this operator, and it will exhibit problematic behavior if used with
sparse tensors.



Defined in src/operator/batch_norm_v1.cc:L95
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BatchNorm_v1" visbl="pub">
<a id="BatchNorm_v1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BatchNorm_v1(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BatchNorm_v1</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BatchNorm_v1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Batch normalization.

This operator is DEPRECATED. Perform BatchNorm on the input.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_var`` as well, which are needed for the backward pass.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

There's no sparse support for this operator, and it will exhibit problematic behavior if used with
sparse tensors.



Defined in src/operator/batch_norm_v1.cc:L95
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Batch normalization.

This operator is DEPRECATED. Perform BatchNorm on the input.

Normalizes a data batch by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:

.. math::

  data\_mean[i] = mean(data[:,i,:,...]) \\
  data\_var[i] = var(data[:,i,:,...])

Then compute the normalized output, which has the same shape as input, as following:

.. math::

  out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]

Both *mean* and *var* returns a scalar by treating the input as a vector.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_var`` as well, which are needed for the backward pass.

Besides the inputs and the outputs, this operator accepts two auxiliary
states, ``moving_mean`` and ``moving_var``, which are *k*-length
vectors. They are global statistics for the whole dataset, which are updated
by::

  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)
  moving_var = moving_var * momentum + data_var * (1 - momentum)

If ``use_global_stats`` is set to be true, then ``moving_mean`` and
``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute
the output. It is often used during inference.

Both ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,
then set ``gamma`` to 1 and its gradient to 0.

There's no sparse support for this operator, and it will exhibit problematic behavior if used with
sparse tensors.



Defined in src/operator/batch_norm_v1.cc:L95
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BilinearSampler" visbl="pub">
<a id="BilinearSampler(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BilinearSampler(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BilinearSampler</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BilinearSampler(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies bilinear sampling to input feature map.

Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\". The usage of the operator is very similar to remap function in OpenCV,
except that the operator has the backward pass.

Given :math:`data` and :math:`grid`, then the output is computed by

.. math::
  x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
  y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
  output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})

:math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).

The operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has been normalized to [-1, 1].

BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.

Example 1::

  ## Zoom out data two times
  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  affine_matrix = array([[2, 0, 0],
                         [0, 2, 0]])

  affine_matrix = reshape(affine_matrix, shape=(1, 6))

  grid = GridGenerator(data=affine_matrix, transform_type='affine', target_shape=(4, 4))

  out = BilinearSampler(data, grid)

  out
  [[[[ 0,   0,     0,   0],
     [ 0,   3.5,   6.5, 0],
     [ 0,   1.25,  2.5, 0],
     [ 0,   0,     0,   0]]]


Example 2::

  ## shift data horizontally by -1 pixel

  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  warp_maxtrix = array([[[[1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1]],
                         [[0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0]]]])

  grid = GridGenerator(data=warp_matrix, transform_type='warp')
  out = BilinearSampler(data, grid)

  out
  [[[[ 4,  3,  6,  0],
     [ 8,  8,  9,  0],
     [ 4,  1,  5,  0],
     [ 0,  1,  3,  0]]]


Defined in src/operator/bilinear_sampler.cc:L245
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies bilinear sampling to input feature map.

Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\". The usage of the operator is very similar to remap function in OpenCV,
except that the operator has the backward pass.

Given :math:`data` and :math:`grid`, then the output is computed by

.. math::
  x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
  y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
  output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})

:math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).

The operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has been normalized to [-1, 1].

BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.

Example 1::

  ## Zoom out data two times
  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  affine_matrix = array([[2, 0, 0],
                         [0, 2, 0]])

  affine_matrix = reshape(affine_matrix, shape=(1, 6))

  grid = GridGenerator(data=affine_matrix, transform_type='affine', target_shape=(4, 4))

  out = BilinearSampler(data, grid)

  out
  [[[[ 0,   0,     0,   0],
     [ 0,   3.5,   6.5, 0],
     [ 0,   1.25,  2.5, 0],
     [ 0,   0,     0,   0]]]


Example 2::

  ## shift data horizontally by -1 pixel

  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  warp_maxtrix = array([[[[1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1]],
                         [[0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0]]]])

  grid = GridGenerator(data=warp_matrix, transform_type='warp')
  out = BilinearSampler(data, grid)

  out
  [[[[ 4,  3,  6,  0],
     [ 8,  8,  9,  0],
     [ 4,  1,  5,  0],
     [ 0,  1,  3,  0]]]


Defined in src/operator/bilinear_sampler.cc:L245
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BilinearSampler" visbl="pub">
<a id="BilinearSampler(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BilinearSampler(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BilinearSampler</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BilinearSampler(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies bilinear sampling to input feature map.

Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\". The usage of the operator is very similar to remap function in OpenCV,
except that the operator has the backward pass.

Given :math:`data` and :math:`grid`, then the output is computed by

.. math::
  x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
  y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
  output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})

:math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).

The operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has been normalized to [-1, 1].

BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.

Example 1::

  ## Zoom out data two times
  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  affine_matrix = array([[2, 0, 0],
                         [0, 2, 0]])

  affine_matrix = reshape(affine_matrix, shape=(1, 6))

  grid = GridGenerator(data=affine_matrix, transform_type='affine', target_shape=(4, 4))

  out = BilinearSampler(data, grid)

  out
  [[[[ 0,   0,     0,   0],
     [ 0,   3.5,   6.5, 0],
     [ 0,   1.25,  2.5, 0],
     [ 0,   0,     0,   0]]]


Example 2::

  ## shift data horizontally by -1 pixel

  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  warp_maxtrix = array([[[[1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1]],
                         [[0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0]]]])

  grid = GridGenerator(data=warp_matrix, transform_type='warp')
  out = BilinearSampler(data, grid)

  out
  [[[[ 4,  3,  6,  0],
     [ 8,  8,  9,  0],
     [ 4,  1,  5,  0],
     [ 0,  1,  3,  0]]]


Defined in src/operator/bilinear_sampler.cc:L245
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies bilinear sampling to input feature map.

Bilinear Sampling is the key of  [NIPS2015] \"Spatial Transformer Networks\". The usage of the operator is very similar to remap function in OpenCV,
except that the operator has the backward pass.

Given :math:`data` and :math:`grid`, then the output is computed by

.. math::
  x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
  y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
  output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})

:math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.
The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).

The operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has been normalized to [-1, 1].

BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
GridGenerator supports two kinds of transformation: ``affine`` and ``warp``.
If users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.

Example 1::

  ## Zoom out data two times
  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  affine_matrix = array([[2, 0, 0],
                         [0, 2, 0]])

  affine_matrix = reshape(affine_matrix, shape=(1, 6))

  grid = GridGenerator(data=affine_matrix, transform_type='affine', target_shape=(4, 4))

  out = BilinearSampler(data, grid)

  out
  [[[[ 0,   0,     0,   0],
     [ 0,   3.5,   6.5, 0],
     [ 0,   1.25,  2.5, 0],
     [ 0,   0,     0,   0]]]


Example 2::

  ## shift data horizontally by -1 pixel

  data = array([[[[1, 4, 3, 6],
                  [1, 8, 8, 9],
                  [0, 4, 1, 5],
                  [1, 0, 1, 3]]]])

  warp_maxtrix = array([[[[1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1],
                          [1, 1, 1, 1]],
                         [[0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0],
                          [0, 0, 0, 0]]]])

  grid = GridGenerator(data=warp_matrix, transform_type='warp')
  out = BilinearSampler(data, grid)

  out
  [[[[ 4,  3,  6,  0],
     [ 8,  8,  9,  0],
     [ 4,  1,  5,  0],
     [ 0,  1,  3,  0]]]


Defined in src/operator/bilinear_sampler.cc:L245
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BlockGrad" visbl="pub">
<a id="BlockGrad(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BlockGrad(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BlockGrad</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BlockGrad(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#BlockGrad" visbl="pub">
<a id="BlockGrad(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="BlockGrad(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">BlockGrad</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@BlockGrad(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Cast" visbl="pub">
<a id="Cast(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Cast(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Cast</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Cast(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Cast" visbl="pub">
<a id="Cast(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Cast(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Cast</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Cast(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Concat" visbl="pub">
<a id="Concat(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Concat(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Concat</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Concat(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Concat" visbl="pub">
<a id="Concat(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Concat(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Concat</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Concat(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Convolution" visbl="pub">
<a id="Convolution(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Convolution(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Convolution</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Convolution(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Compute *N*-D convolution on *(N+2)*-D input.

In the 2-D convolution, given input data with shape *(batch_size,
channel, height, width)*, the output is computed by

.. math::

   out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
   weight[i,j,:,:]

where :math:`\star` is the 2-D cross-correlation operator.

For general 2-D convolution, the shapes are

- **data**: *(batch_size, channel, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_height, out_width)*.

Define::

  f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1

then we have::

  out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
  out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
width)*. We can choose other layouts such as *NWC*.

If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
evenly into *g* parts along the channel axis, and also evenly split ``weight``
along the first dimension. Next compute the convolution on the *i*-th part of
the data with the *i*-th weight part. The output is obtained by concatenating all
the *g* results.

1-D convolution does not have *height* dimension but only *width* in space.

- **data**: *(batch_size, channel, width)*
- **weight**: *(num_filter, channel, kernel[0])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_width)*.

3-D convolution adds an additional *depth* dimension besides *height* and
*width*. The shapes are

- **data**: *(batch_size, channel, depth, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.

Both ``weight`` and ``bias`` are learnable parameters.

There are other options to tune the performance.

- **cudnn_tune**: enable this option leads to higher startup time but may give
  faster speed. Options are

  - **off**: no tuning
  - **limited_workspace**:run test and pick the fastest algorithm that doesn't
    exceed workspace limit.
  - **fastest**: pick the fastest algorithm and ignore workspace limit.
  - **None** (default): the behavior is determined by environment variable
    ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    (default), 2 for fastest.

- **workspace**: A large number leads to more (GPU) memory usage but may improve
  the performance.



Defined in src/operator/nn/convolution.cc:L474
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Compute *N*-D convolution on *(N+2)*-D input.

In the 2-D convolution, given input data with shape *(batch_size,
channel, height, width)*, the output is computed by

.. math::

   out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
   weight[i,j,:,:]

where :math:`\star` is the 2-D cross-correlation operator.

For general 2-D convolution, the shapes are

- **data**: *(batch_size, channel, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_height, out_width)*.

Define::

  f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1

then we have::

  out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
  out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
width)*. We can choose other layouts such as *NWC*.

If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
evenly into *g* parts along the channel axis, and also evenly split ``weight``
along the first dimension. Next compute the convolution on the *i*-th part of
the data with the *i*-th weight part. The output is obtained by concatenating all
the *g* results.

1-D convolution does not have *height* dimension but only *width* in space.

- **data**: *(batch_size, channel, width)*
- **weight**: *(num_filter, channel, kernel[0])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_width)*.

3-D convolution adds an additional *depth* dimension besides *height* and
*width*. The shapes are

- **data**: *(batch_size, channel, depth, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.

Both ``weight`` and ``bias`` are learnable parameters.

There are other options to tune the performance.

- **cudnn_tune**: enable this option leads to higher startup time but may give
  faster speed. Options are

  - **off**: no tuning
  - **limited_workspace**:run test and pick the fastest algorithm that doesn't
    exceed workspace limit.
  - **fastest**: pick the fastest algorithm and ignore workspace limit.
  - **None** (default): the behavior is determined by environment variable
    ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    (default), 2 for fastest.

- **workspace**: A large number leads to more (GPU) memory usage but may improve
  the performance.



Defined in src/operator/nn/convolution.cc:L474
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Convolution" visbl="pub">
<a id="Convolution(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Convolution(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Convolution</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Convolution(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Compute *N*-D convolution on *(N+2)*-D input.

In the 2-D convolution, given input data with shape *(batch_size,
channel, height, width)*, the output is computed by

.. math::

   out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
   weight[i,j,:,:]

where :math:`\star` is the 2-D cross-correlation operator.

For general 2-D convolution, the shapes are

- **data**: *(batch_size, channel, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_height, out_width)*.

Define::

  f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1

then we have::

  out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
  out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
width)*. We can choose other layouts such as *NWC*.

If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
evenly into *g* parts along the channel axis, and also evenly split ``weight``
along the first dimension. Next compute the convolution on the *i*-th part of
the data with the *i*-th weight part. The output is obtained by concatenating all
the *g* results.

1-D convolution does not have *height* dimension but only *width* in space.

- **data**: *(batch_size, channel, width)*
- **weight**: *(num_filter, channel, kernel[0])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_width)*.

3-D convolution adds an additional *depth* dimension besides *height* and
*width*. The shapes are

- **data**: *(batch_size, channel, depth, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.

Both ``weight`` and ``bias`` are learnable parameters.

There are other options to tune the performance.

- **cudnn_tune**: enable this option leads to higher startup time but may give
  faster speed. Options are

  - **off**: no tuning
  - **limited_workspace**:run test and pick the fastest algorithm that doesn't
    exceed workspace limit.
  - **fastest**: pick the fastest algorithm and ignore workspace limit.
  - **None** (default): the behavior is determined by environment variable
    ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    (default), 2 for fastest.

- **workspace**: A large number leads to more (GPU) memory usage but may improve
  the performance.



Defined in src/operator/nn/convolution.cc:L474
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Compute *N*-D convolution on *(N+2)*-D input.

In the 2-D convolution, given input data with shape *(batch_size,
channel, height, width)*, the output is computed by

.. math::

   out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
   weight[i,j,:,:]

where :math:`\star` is the 2-D cross-correlation operator.

For general 2-D convolution, the shapes are

- **data**: *(batch_size, channel, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_height, out_width)*.

Define::

  f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1

then we have::

  out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])
  out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

The default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,
width)*. We can choose other layouts such as *NWC*.

If ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``
evenly into *g* parts along the channel axis, and also evenly split ``weight``
along the first dimension. Next compute the convolution on the *i*-th part of
the data with the *i*-th weight part. The output is obtained by concatenating all
the *g* results.

1-D convolution does not have *height* dimension but only *width* in space.

- **data**: *(batch_size, channel, width)*
- **weight**: *(num_filter, channel, kernel[0])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_width)*.

3-D convolution adds an additional *depth* dimension besides *height* and
*width*. The shapes are

- **data**: *(batch_size, channel, depth, height, width)*
- **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*
- **bias**: *(num_filter,)*
- **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.

Both ``weight`` and ``bias`` are learnable parameters.

There are other options to tune the performance.

- **cudnn_tune**: enable this option leads to higher startup time but may give
  faster speed. Options are

  - **off**: no tuning
  - **limited_workspace**:run test and pick the fastest algorithm that doesn't
    exceed workspace limit.
  - **fastest**: pick the fastest algorithm and ignore workspace limit.
  - **None** (default): the behavior is determined by environment variable
    ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace
    (default), 2 for fastest.

- **workspace**: A large number leads to more (GPU) memory usage but may improve
  the performance.



Defined in src/operator/nn/convolution.cc:L474
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Convolution_v1" visbl="pub">
<a id="Convolution_v1(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Convolution_v1(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Convolution_v1</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Convolution_v1(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
This operator is DEPRECATED. Apply convolution to input then add a bias.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
This operator is DEPRECATED. Apply convolution to input then add a bias.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Convolution_v1" visbl="pub">
<a id="Convolution_v1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Convolution_v1(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Convolution_v1</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Convolution_v1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
This operator is DEPRECATED. Apply convolution to input then add a bias.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
This operator is DEPRECATED. Apply convolution to input then add a bias.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Correlation" visbl="pub">
<a id="Correlation(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Correlation(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Correlation</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Correlation(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies correlation to inputs.

The correlation layer performs multiplicative patch comparisons between two feature maps.

Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.

For now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:`x_{1}` in the first map and
:math:`x_{2}` in the second map is then defined as:

.. math::

   c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} +="" f_{2}(x_{2}="" o)="" o),="">

for a square patch of size :math:`K:=2k+1`.

Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
data. For this reason, it has no training weights.

Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.

Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
centered around :math:`x_{1}`.

The final output is defined by the following expression:

.. math::
  out[n, q, i, j] = c(x_{i, j}, x_{q})

where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.


Defined in src/operator/correlation.cc:L198
</f_{1}(x_{1}></pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies correlation to inputs.

The correlation layer performs multiplicative patch comparisons between two feature maps.

Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.

For now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:`x_{1}` in the first map and
:math:`x_{2}` in the second map is then defined as:

.. math::

   c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} +="" f_{2}(x_{2}="" o)="" o),="">

for a square patch of size :math:`K:=2k+1`.

Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
data. For this reason, it has no training weights.

Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.

Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
centered around :math:`x_{1}`.

The final output is defined by the following expression:

.. math::
  out[n, q, i, j] = c(x_{i, j}, x_{q})

where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.


Defined in src/operator/correlation.cc:L198
</f_{1}(x_{1}></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Correlation" visbl="pub">
<a id="Correlation(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Correlation(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Correlation</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Correlation(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies correlation to inputs.

The correlation layer performs multiplicative patch comparisons between two feature maps.

Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.

For now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:`x_{1}` in the first map and
:math:`x_{2}` in the second map is then defined as:

.. math::

   c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} +="" f_{2}(x_{2}="" o)="" o),="">

for a square patch of size :math:`K:=2k+1`.

Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
data. For this reason, it has no training weights.

Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.

Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
centered around :math:`x_{1}`.

The final output is defined by the following expression:

.. math::
  out[n, q, i, j] = c(x_{i, j}, x_{q})

where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.


Defined in src/operator/correlation.cc:L198
</f_{1}(x_{1}></pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies correlation to inputs.

The correlation layer performs multiplicative patch comparisons between two feature maps.

Given two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,
the correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.

For now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:`x_{1}` in the first map and
:math:`x_{2}` in the second map is then defined as:

.. math::

   c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} +="" f_{2}(x_{2}="" o)="" o),="">

for a square patch of size :math:`K:=2k+1`.

Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
data. For this reason, it has no training weights.

Computing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.

Given a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,
by limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood
centered around :math:`x_{1}`.

The final output is defined by the following expression:

.. math::
  out[n, q, i, j] = c(x_{i, j}, x_{q})

where :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.


Defined in src/operator/correlation.cc:L198
</f_{1}(x_{1}></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Crop" visbl="pub">
<a id="Crop(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Crop(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Crop</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Crop(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>


.. note:: `Crop` is deprecated. Use `slice` instead.

Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
with width and height of the second input symbol, i.e., with one input, we need h_w to
specify the crop height and width, otherwise the second input symbol's size will be used


Defined in src/operator/crop.cc:L50
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>


.. note:: `Crop` is deprecated. Use `slice` instead.

Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
with width and height of the second input symbol, i.e., with one input, we need h_w to
specify the crop height and width, otherwise the second input symbol's size will be used


Defined in src/operator/crop.cc:L50
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Crop" visbl="pub">
<a id="Crop(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Crop(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Crop</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Crop(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>


.. note:: `Crop` is deprecated. Use `slice` instead.

Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
with width and height of the second input symbol, i.e., with one input, we need h_w to
specify the crop height and width, otherwise the second input symbol's size will be used


Defined in src/operator/crop.cc:L50
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>


.. note:: `Crop` is deprecated. Use `slice` instead.

Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
with width and height of the second input symbol, i.e., with one input, we need h_w to
specify the crop height and width, otherwise the second input symbol's size will be used


Defined in src/operator/crop.cc:L50
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Custom" visbl="pub">
<a id="Custom(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Custom(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Custom</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Custom(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Apply a custom operator implemented in a frontend language (like Python).

Custom operators should override required methods like `forward` and `backward`.
The custom operator must be registered before it can be used.
Please check the tutorial here: https://mxnet.incubator.apache.org/versions/1.2.1/faq/new_op.html.



Defined in src/operator/custom/custom.cc:L547
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Apply a custom operator implemented in a frontend language (like Python).

Custom operators should override required methods like `forward` and `backward`.
The custom operator must be registered before it can be used.
Please check the tutorial here: https://mxnet.incubator.apache.org/versions/1.2.1/faq/new_op.html.



Defined in src/operator/custom/custom.cc:L547
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Custom" visbl="pub">
<a id="Custom(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Custom(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Custom</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Custom(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Apply a custom operator implemented in a frontend language (like Python).

Custom operators should override required methods like `forward` and `backward`.
The custom operator must be registered before it can be used.
Please check the tutorial here: https://mxnet.incubator.apache.org/versions/1.2.1/faq/new_op.html.



Defined in src/operator/custom/custom.cc:L547
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Apply a custom operator implemented in a frontend language (like Python).

Custom operators should override required methods like `forward` and `backward`.
The custom operator must be registered before it can be used.
Please check the tutorial here: https://mxnet.incubator.apache.org/versions/1.2.1/faq/new_op.html.



Defined in src/operator/custom/custom.cc:L547
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Deconvolution" visbl="pub">
<a id="Deconvolution(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Deconvolution(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Deconvolution</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Deconvolution(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Deconvolution" visbl="pub">
<a id="Deconvolution(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Deconvolution(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Deconvolution</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Deconvolution(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Dropout" visbl="pub">
<a id="Dropout(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Dropout(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Dropout</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Dropout(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies dropout operation to input array.

- During training, each element of the input is set to zero with probability p.
  The whole array is rescaled by :math:`1/(1-p)` to keep the expected
  sum of the input unchanged.

- During testing, this operator does not change the input if mode is 'training'.
  If mode is 'always', the same computaion as during training will be applied.

Example::

  random.seed(998)
  input_array = array([[3., 0.5,  -0.5,  2., 7.],
                      [2., -0.4,   7.,  3., 0.2]])
  a = symbol.Variable('a')
  dropout = symbol.Dropout(a, p = 0.2)
  executor = dropout.simple_bind(a = input_array.shape)

  ## If training
  executor.forward(is_train = True, a = input_array)
  executor.outputs
  [[ 3.75   0.625 -0.     2.5    8.75 ]
   [ 2.5   -0.5    8.75   3.75   0.   ]]

  ## If testing
  executor.forward(is_train = False, a = input_array)
  executor.outputs
  [[ 3.     0.5   -0.5    2.     7.   ]
   [ 2.    -0.4    7.     3.     0.2  ]]


Defined in src/operator/nn/dropout.cc:L76
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies dropout operation to input array.

- During training, each element of the input is set to zero with probability p.
  The whole array is rescaled by :math:`1/(1-p)` to keep the expected
  sum of the input unchanged.

- During testing, this operator does not change the input if mode is 'training'.
  If mode is 'always', the same computaion as during training will be applied.

Example::

  random.seed(998)
  input_array = array([[3., 0.5,  -0.5,  2., 7.],
                      [2., -0.4,   7.,  3., 0.2]])
  a = symbol.Variable('a')
  dropout = symbol.Dropout(a, p = 0.2)
  executor = dropout.simple_bind(a = input_array.shape)

  ## If training
  executor.forward(is_train = True, a = input_array)
  executor.outputs
  [[ 3.75   0.625 -0.     2.5    8.75 ]
   [ 2.5   -0.5    8.75   3.75   0.   ]]

  ## If testing
  executor.forward(is_train = False, a = input_array)
  executor.outputs
  [[ 3.     0.5   -0.5    2.     7.   ]
   [ 2.    -0.4    7.     3.     0.2  ]]


Defined in src/operator/nn/dropout.cc:L76
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Dropout" visbl="pub">
<a id="Dropout(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Dropout(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Dropout</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Dropout(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies dropout operation to input array.

- During training, each element of the input is set to zero with probability p.
  The whole array is rescaled by :math:`1/(1-p)` to keep the expected
  sum of the input unchanged.

- During testing, this operator does not change the input if mode is 'training'.
  If mode is 'always', the same computaion as during training will be applied.

Example::

  random.seed(998)
  input_array = array([[3., 0.5,  -0.5,  2., 7.],
                      [2., -0.4,   7.,  3., 0.2]])
  a = symbol.Variable('a')
  dropout = symbol.Dropout(a, p = 0.2)
  executor = dropout.simple_bind(a = input_array.shape)

  ## If training
  executor.forward(is_train = True, a = input_array)
  executor.outputs
  [[ 3.75   0.625 -0.     2.5    8.75 ]
   [ 2.5   -0.5    8.75   3.75   0.   ]]

  ## If testing
  executor.forward(is_train = False, a = input_array)
  executor.outputs
  [[ 3.     0.5   -0.5    2.     7.   ]
   [ 2.    -0.4    7.     3.     0.2  ]]


Defined in src/operator/nn/dropout.cc:L76
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies dropout operation to input array.

- During training, each element of the input is set to zero with probability p.
  The whole array is rescaled by :math:`1/(1-p)` to keep the expected
  sum of the input unchanged.

- During testing, this operator does not change the input if mode is 'training'.
  If mode is 'always', the same computaion as during training will be applied.

Example::

  random.seed(998)
  input_array = array([[3., 0.5,  -0.5,  2., 7.],
                      [2., -0.4,   7.,  3., 0.2]])
  a = symbol.Variable('a')
  dropout = symbol.Dropout(a, p = 0.2)
  executor = dropout.simple_bind(a = input_array.shape)

  ## If training
  executor.forward(is_train = True, a = input_array)
  executor.outputs
  [[ 3.75   0.625 -0.     2.5    8.75 ]
   [ 2.5   -0.5    8.75   3.75   0.   ]]

  ## If testing
  executor.forward(is_train = False, a = input_array)
  executor.outputs
  [[ 3.     0.5   -0.5    2.     7.   ]
   [ 2.    -0.4    7.     3.     0.2  ]]


Defined in src/operator/nn/dropout.cc:L76
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ElementWiseSum" visbl="pub">
<a id="ElementWiseSum(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ElementWiseSum(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ElementWiseSum</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ElementWiseSum(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ElementWiseSum" visbl="pub">
<a id="ElementWiseSum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ElementWiseSum(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ElementWiseSum</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ElementWiseSum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Embedding" visbl="pub">
<a id="Embedding(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Embedding(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Embedding</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Embedding(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Maps integer indices to vector representations (embeddings).

This operator maps words to real-valued vectors in a high-dimensional space,
called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
For example, it has been noted that in the learned embedding spaces, similar words tend
to be close to each other and dissimilar words far apart.

For an input array of shape (d1, ..., dK),
the shape of an output array is (d1, ..., dK, output_dim).
All the input values should be integers in the range [0, input_dim).

If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
(ip0, op0).

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last vector in an embedding matrix.

Examples::

  input_dim = 4
  output_dim = 5

  // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
  y = [[  0.,   1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.,   9.],
       [ 10.,  11.,  12.,  13.,  14.],
       [ 15.,  16.,  17.,  18.,  19.]]

  // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
  x = [[ 1.,  3.],
       [ 0.,  2.]]

  // Mapped input x to its vector representation y.
  Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
                            [ 15.,  16.,  17.,  18.,  19.]],

                           [[  0.,   1.,   2.,   3.,   4.],
                            [ 10.,  11.,  12.,  13.,  14.]]]


The storage type of weight can be either row_sparse or default.

.. Note::

    If "sparse_grad" is set to True, the storage type of gradient w.r.t weights will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/indexing_op.cc:L267
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Maps integer indices to vector representations (embeddings).

This operator maps words to real-valued vectors in a high-dimensional space,
called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
For example, it has been noted that in the learned embedding spaces, similar words tend
to be close to each other and dissimilar words far apart.

For an input array of shape (d1, ..., dK),
the shape of an output array is (d1, ..., dK, output_dim).
All the input values should be integers in the range [0, input_dim).

If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
(ip0, op0).

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last vector in an embedding matrix.

Examples::

  input_dim = 4
  output_dim = 5

  // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
  y = [[  0.,   1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.,   9.],
       [ 10.,  11.,  12.,  13.,  14.],
       [ 15.,  16.,  17.,  18.,  19.]]

  // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
  x = [[ 1.,  3.],
       [ 0.,  2.]]

  // Mapped input x to its vector representation y.
  Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
                            [ 15.,  16.,  17.,  18.,  19.]],

                           [[  0.,   1.,   2.,   3.,   4.],
                            [ 10.,  11.,  12.,  13.,  14.]]]


The storage type of weight can be either row_sparse or default.

.. Note::

    If "sparse_grad" is set to True, the storage type of gradient w.r.t weights will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/indexing_op.cc:L267
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Embedding" visbl="pub">
<a id="Embedding(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Embedding(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Embedding</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Embedding(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Maps integer indices to vector representations (embeddings).

This operator maps words to real-valued vectors in a high-dimensional space,
called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
For example, it has been noted that in the learned embedding spaces, similar words tend
to be close to each other and dissimilar words far apart.

For an input array of shape (d1, ..., dK),
the shape of an output array is (d1, ..., dK, output_dim).
All the input values should be integers in the range [0, input_dim).

If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
(ip0, op0).

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last vector in an embedding matrix.

Examples::

  input_dim = 4
  output_dim = 5

  // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
  y = [[  0.,   1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.,   9.],
       [ 10.,  11.,  12.,  13.,  14.],
       [ 15.,  16.,  17.,  18.,  19.]]

  // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
  x = [[ 1.,  3.],
       [ 0.,  2.]]

  // Mapped input x to its vector representation y.
  Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
                            [ 15.,  16.,  17.,  18.,  19.]],

                           [[  0.,   1.,   2.,   3.,   4.],
                            [ 10.,  11.,  12.,  13.,  14.]]]


The storage type of weight can be either row_sparse or default.

.. Note::

    If "sparse_grad" is set to True, the storage type of gradient w.r.t weights will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/indexing_op.cc:L267
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Maps integer indices to vector representations (embeddings).

This operator maps words to real-valued vectors in a high-dimensional space,
called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
For example, it has been noted that in the learned embedding spaces, similar words tend
to be close to each other and dissimilar words far apart.

For an input array of shape (d1, ..., dK),
the shape of an output array is (d1, ..., dK, output_dim).
All the input values should be integers in the range [0, input_dim).

If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
(ip0, op0).

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last vector in an embedding matrix.

Examples::

  input_dim = 4
  output_dim = 5

  // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)
  y = [[  0.,   1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.,   9.],
       [ 10.,  11.,  12.,  13.,  14.],
       [ 15.,  16.,  17.,  18.,  19.]]

  // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]
  x = [[ 1.,  3.],
       [ 0.,  2.]]

  // Mapped input x to its vector representation y.
  Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],
                            [ 15.,  16.,  17.,  18.,  19.]],

                           [[  0.,   1.,   2.,   3.,   4.],
                            [ 10.,  11.,  12.,  13.,  14.]]]


The storage type of weight can be either row_sparse or default.

.. Note::

    If "sparse_grad" is set to True, the storage type of gradient w.r.t weights will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/indexing_op.cc:L267
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Flatten" visbl="pub">
<a id="Flatten(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Flatten(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Flatten</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Flatten(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Flatten" visbl="pub">
<a id="Flatten(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Flatten(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Flatten</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Flatten(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#FullyConnected" visbl="pub">
<a id="FullyConnected(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="FullyConnected(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">FullyConnected</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@FullyConnected(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies a linear transformation: :math:`Y = XW^T + b`.

If ``flatten`` is set to be true, then the shapes are:

- **data**: `(batch_size, x1, x2, ..., xn)`
- **weight**: `(num_hidden, x1 * x2 * ... * xn)`
- **bias**: `(num_hidden,)`
- **out**: `(batch_size, num_hidden)`

If ``flatten`` is set to be false, then the shapes are:

- **data**: `(x1, x2, ..., xn, input_dim)`
- **weight**: `(num_hidden, input_dim)`
- **bias**: `(num_hidden,)`
- **out**: `(x1, x2, ..., xn, num_hidden)`

The learnable parameters include both ``weight`` and ``bias``.

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

.. Note::

    The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    trained with importance sampling or noise contrastive estimation.

    To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
    of sparse.FullyConnected.



Defined in src/operator/nn/fully_connected.cc:L272
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies a linear transformation: :math:`Y = XW^T + b`.

If ``flatten`` is set to be true, then the shapes are:

- **data**: `(batch_size, x1, x2, ..., xn)`
- **weight**: `(num_hidden, x1 * x2 * ... * xn)`
- **bias**: `(num_hidden,)`
- **out**: `(batch_size, num_hidden)`

If ``flatten`` is set to be false, then the shapes are:

- **data**: `(x1, x2, ..., xn, input_dim)`
- **weight**: `(num_hidden, input_dim)`
- **bias**: `(num_hidden,)`
- **out**: `(x1, x2, ..., xn, num_hidden)`

The learnable parameters include both ``weight`` and ``bias``.

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

.. Note::

    The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    trained with importance sampling or noise contrastive estimation.

    To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
    of sparse.FullyConnected.



Defined in src/operator/nn/fully_connected.cc:L272
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#FullyConnected" visbl="pub">
<a id="FullyConnected(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="FullyConnected(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">FullyConnected</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@FullyConnected(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies a linear transformation: :math:`Y = XW^T + b`.

If ``flatten`` is set to be true, then the shapes are:

- **data**: `(batch_size, x1, x2, ..., xn)`
- **weight**: `(num_hidden, x1 * x2 * ... * xn)`
- **bias**: `(num_hidden,)`
- **out**: `(batch_size, num_hidden)`

If ``flatten`` is set to be false, then the shapes are:

- **data**: `(x1, x2, ..., xn, input_dim)`
- **weight**: `(num_hidden, input_dim)`
- **bias**: `(num_hidden,)`
- **out**: `(x1, x2, ..., xn, num_hidden)`

The learnable parameters include both ``weight`` and ``bias``.

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

.. Note::

    The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    trained with importance sampling or noise contrastive estimation.

    To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
    of sparse.FullyConnected.



Defined in src/operator/nn/fully_connected.cc:L272
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies a linear transformation: :math:`Y = XW^T + b`.

If ``flatten`` is set to be true, then the shapes are:

- **data**: `(batch_size, x1, x2, ..., xn)`
- **weight**: `(num_hidden, x1 * x2 * ... * xn)`
- **bias**: `(num_hidden,)`
- **out**: `(batch_size, num_hidden)`

If ``flatten`` is set to be false, then the shapes are:

- **data**: `(x1, x2, ..., xn, input_dim)`
- **weight**: `(num_hidden, input_dim)`
- **bias**: `(num_hidden,)`
- **out**: `(x1, x2, ..., xn, num_hidden)`

The learnable parameters include both ``weight`` and ``bias``.

If ``no_bias`` is set to be true, then the ``bias`` term is ignored.

.. Note::

    The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`
    weight and bias, where the length of `weight.indices` and `bias.indices` must be equal
    to `num_hidden`. This could be useful for model inference with `row_sparse` weights
    trained with importance sampling or noise contrastive estimation.

    To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead
    of sparse.FullyConnected.



Defined in src/operator/nn/fully_connected.cc:L272
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#GridGenerator" visbl="pub">
<a id="GridGenerator(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="GridGenerator(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">GridGenerator</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@GridGenerator(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Generates 2D sampling grid for bilinear sampling.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Generates 2D sampling grid for bilinear sampling.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#GridGenerator" visbl="pub">
<a id="GridGenerator(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="GridGenerator(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">GridGenerator</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@GridGenerator(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Generates 2D sampling grid for bilinear sampling.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Generates 2D sampling grid for bilinear sampling.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#IdentityAttachKLSparseReg" visbl="pub">
<a id="IdentityAttachKLSparseReg(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="IdentityAttachKLSparseReg(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">IdentityAttachKLSparseReg</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@IdentityAttachKLSparseReg(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Apply a sparse regularization to the output a sigmoid activation function.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Apply a sparse regularization to the output a sigmoid activation function.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#IdentityAttachKLSparseReg" visbl="pub">
<a id="IdentityAttachKLSparseReg(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="IdentityAttachKLSparseReg(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">IdentityAttachKLSparseReg</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@IdentityAttachKLSparseReg(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Apply a sparse regularization to the output a sigmoid activation function.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Apply a sparse regularization to the output a sigmoid activation function.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#InstanceNorm" visbl="pub">
<a id="InstanceNorm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="InstanceNorm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">InstanceNorm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@InstanceNorm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies instance normalization to the n-dimensional input array.

This operator takes an n-dimensional input array where (n&gt;2) and normalizes
the input using the following formula:

.. math::

  out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta

This layer is similar to batch normalization layer (`BatchNorm`)
with two differences: first, the normalization is
carried out per example (instance), not over a batch. Second, the
same normalization is applied both at test and train time. This
operation is also known as `contrast normalization`.

If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
`gamma` and `beta` parameters must be vectors of shape [channel].

This implementation is based on paper:

.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).

Examples::

  // Input of shape (2,1,2)
  x = [[[ 1.1,  2.2]],
       [[ 3.3,  4.4]]]

  // gamma parameter of length 1
  gamma = [1.5]

  // beta parameter of length 1
  beta = [0.5]

  // Instance normalization is calculated with the above formula
  InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
                                [[-0.99752653,  1.99752724]]]



Defined in src/operator/instance_norm.cc:L95
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies instance normalization to the n-dimensional input array.

This operator takes an n-dimensional input array where (n&gt;2) and normalizes
the input using the following formula:

.. math::

  out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta

This layer is similar to batch normalization layer (`BatchNorm`)
with two differences: first, the normalization is
carried out per example (instance), not over a batch. Second, the
same normalization is applied both at test and train time. This
operation is also known as `contrast normalization`.

If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
`gamma` and `beta` parameters must be vectors of shape [channel].

This implementation is based on paper:

.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).

Examples::

  // Input of shape (2,1,2)
  x = [[[ 1.1,  2.2]],
       [[ 3.3,  4.4]]]

  // gamma parameter of length 1
  gamma = [1.5]

  // beta parameter of length 1
  beta = [0.5]

  // Instance normalization is calculated with the above formula
  InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
                                [[-0.99752653,  1.99752724]]]



Defined in src/operator/instance_norm.cc:L95
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#InstanceNorm" visbl="pub">
<a id="InstanceNorm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="InstanceNorm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">InstanceNorm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@InstanceNorm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies instance normalization to the n-dimensional input array.

This operator takes an n-dimensional input array where (n&gt;2) and normalizes
the input using the following formula:

.. math::

  out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta

This layer is similar to batch normalization layer (`BatchNorm`)
with two differences: first, the normalization is
carried out per example (instance), not over a batch. Second, the
same normalization is applied both at test and train time. This
operation is also known as `contrast normalization`.

If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
`gamma` and `beta` parameters must be vectors of shape [channel].

This implementation is based on paper:

.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).

Examples::

  // Input of shape (2,1,2)
  x = [[[ 1.1,  2.2]],
       [[ 3.3,  4.4]]]

  // gamma parameter of length 1
  gamma = [1.5]

  // beta parameter of length 1
  beta = [0.5]

  // Instance normalization is calculated with the above formula
  InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
                                [[-0.99752653,  1.99752724]]]



Defined in src/operator/instance_norm.cc:L95
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies instance normalization to the n-dimensional input array.

This operator takes an n-dimensional input array where (n&gt;2) and normalizes
the input using the following formula:

.. math::

  out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta

This layer is similar to batch normalization layer (`BatchNorm`)
with two differences: first, the normalization is
carried out per example (instance), not over a batch. Second, the
same normalization is applied both at test and train time. This
operation is also known as `contrast normalization`.

If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
`gamma` and `beta` parameters must be vectors of shape [channel].

This implementation is based on paper:

.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,
   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).

Examples::

  // Input of shape (2,1,2)
  x = [[[ 1.1,  2.2]],
       [[ 3.3,  4.4]]]

  // gamma parameter of length 1
  gamma = [1.5]

  // beta parameter of length 1
  beta = [0.5]

  // Instance normalization is calculated with the above formula
  InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],
                                [[-0.99752653,  1.99752724]]]



Defined in src/operator/instance_norm.cc:L95
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#L2Normalization" visbl="pub">
<a id="L2Normalization(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="L2Normalization(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">L2Normalization</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@L2Normalization(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Normalize the input array using the L2 norm.

For 1-D NDArray, it computes::

  out = data / sqrt(sum(data ** 2) + eps)

For N-D NDArray, if the input array has shape (N, N, ..., N),

with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
array by its L2 norm.::

  for i in 0...N
    out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)

with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::

  for i in 0...N
    out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)

with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
in the array by its L2 norm.::

  for dim in 2...N
    for i in 0...N
      out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
          -dim-

Example::

  x = [[[1,2],
        [3,4]],
       [[2,2],
        [5,6]]]

  L2Normalization(x, mode='instance')
  =[[[ 0.18257418  0.36514837]
     [ 0.54772252  0.73029673]]
    [[ 0.24077171  0.24077171]
     [ 0.60192931  0.72231513]]]

  L2Normalization(x, mode='channel')
  =[[[ 0.31622776  0.44721359]
     [ 0.94868326  0.89442718]]
    [[ 0.37139067  0.31622776]
     [ 0.92847669  0.94868326]]]

  L2Normalization(x, mode='spatial')
  =[[[ 0.44721359  0.89442718]
     [ 0.60000002  0.80000001]]
    [[ 0.70710677  0.70710677]
     [ 0.6401844   0.76822126]]]



Defined in src/operator/l2_normalization.cc:L98
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Normalize the input array using the L2 norm.

For 1-D NDArray, it computes::

  out = data / sqrt(sum(data ** 2) + eps)

For N-D NDArray, if the input array has shape (N, N, ..., N),

with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
array by its L2 norm.::

  for i in 0...N
    out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)

with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::

  for i in 0...N
    out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)

with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
in the array by its L2 norm.::

  for dim in 2...N
    for i in 0...N
      out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
          -dim-

Example::

  x = [[[1,2],
        [3,4]],
       [[2,2],
        [5,6]]]

  L2Normalization(x, mode='instance')
  =[[[ 0.18257418  0.36514837]
     [ 0.54772252  0.73029673]]
    [[ 0.24077171  0.24077171]
     [ 0.60192931  0.72231513]]]

  L2Normalization(x, mode='channel')
  =[[[ 0.31622776  0.44721359]
     [ 0.94868326  0.89442718]]
    [[ 0.37139067  0.31622776]
     [ 0.92847669  0.94868326]]]

  L2Normalization(x, mode='spatial')
  =[[[ 0.44721359  0.89442718]
     [ 0.60000002  0.80000001]]
    [[ 0.70710677  0.70710677]
     [ 0.6401844   0.76822126]]]



Defined in src/operator/l2_normalization.cc:L98
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#L2Normalization" visbl="pub">
<a id="L2Normalization(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="L2Normalization(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">L2Normalization</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@L2Normalization(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Normalize the input array using the L2 norm.

For 1-D NDArray, it computes::

  out = data / sqrt(sum(data ** 2) + eps)

For N-D NDArray, if the input array has shape (N, N, ..., N),

with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
array by its L2 norm.::

  for i in 0...N
    out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)

with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::

  for i in 0...N
    out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)

with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
in the array by its L2 norm.::

  for dim in 2...N
    for i in 0...N
      out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
          -dim-

Example::

  x = [[[1,2],
        [3,4]],
       [[2,2],
        [5,6]]]

  L2Normalization(x, mode='instance')
  =[[[ 0.18257418  0.36514837]
     [ 0.54772252  0.73029673]]
    [[ 0.24077171  0.24077171]
     [ 0.60192931  0.72231513]]]

  L2Normalization(x, mode='channel')
  =[[[ 0.31622776  0.44721359]
     [ 0.94868326  0.89442718]]
    [[ 0.37139067  0.31622776]
     [ 0.92847669  0.94868326]]]

  L2Normalization(x, mode='spatial')
  =[[[ 0.44721359  0.89442718]
     [ 0.60000002  0.80000001]]
    [[ 0.70710677  0.70710677]
     [ 0.6401844   0.76822126]]]



Defined in src/operator/l2_normalization.cc:L98
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Normalize the input array using the L2 norm.

For 1-D NDArray, it computes::

  out = data / sqrt(sum(data ** 2) + eps)

For N-D NDArray, if the input array has shape (N, N, ..., N),

with ``mode`` = ``instance``, it normalizes each instance in the multidimensional
array by its L2 norm.::

  for i in 0...N
    out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)

with ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::

  for i in 0...N
    out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)

with ``mode`` = ``spatial``, it normalizes the cross channel norm for each position
in the array by its L2 norm.::

  for dim in 2...N
    for i in 0...N
      out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)
          -dim-

Example::

  x = [[[1,2],
        [3,4]],
       [[2,2],
        [5,6]]]

  L2Normalization(x, mode='instance')
  =[[[ 0.18257418  0.36514837]
     [ 0.54772252  0.73029673]]
    [[ 0.24077171  0.24077171]
     [ 0.60192931  0.72231513]]]

  L2Normalization(x, mode='channel')
  =[[[ 0.31622776  0.44721359]
     [ 0.94868326  0.89442718]]
    [[ 0.37139067  0.31622776]
     [ 0.92847669  0.94868326]]]

  L2Normalization(x, mode='spatial')
  =[[[ 0.44721359  0.89442718]
     [ 0.60000002  0.80000001]]
    [[ 0.70710677  0.70710677]
     [ 0.6401844   0.76822126]]]



Defined in src/operator/l2_normalization.cc:L98
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LRN" visbl="pub">
<a id="LRN(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LRN(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LRN</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LRN(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies local response normalization to the input.

The local response normalization layer performs "lateral inhibition" by normalizing
over local input regions.

If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
:math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
activity :math:`b_{x,y}^{i}` is given by the expression:

.. math::
   b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}

where the sum runs over :math:`n` "adjacent" kernel maps at the same spatial position, and :math:`N` is the total
number of kernels in the layer.



Defined in src/operator/nn/lrn.cc:L178
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies local response normalization to the input.

The local response normalization layer performs "lateral inhibition" by normalizing
over local input regions.

If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
:math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
activity :math:`b_{x,y}^{i}` is given by the expression:

.. math::
   b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}

where the sum runs over :math:`n` "adjacent" kernel maps at the same spatial position, and :math:`N` is the total
number of kernels in the layer.



Defined in src/operator/nn/lrn.cc:L178
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LRN" visbl="pub">
<a id="LRN(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LRN(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LRN</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LRN(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies local response normalization to the input.

The local response normalization layer performs "lateral inhibition" by normalizing
over local input regions.

If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
:math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
activity :math:`b_{x,y}^{i}` is given by the expression:

.. math::
   b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}

where the sum runs over :math:`n` "adjacent" kernel maps at the same spatial position, and :math:`N` is the total
number of kernels in the layer.



Defined in src/operator/nn/lrn.cc:L178
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies local response normalization to the input.

The local response normalization layer performs "lateral inhibition" by normalizing
over local input regions.

If :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position
:math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized
activity :math:`b_{x,y}^{i}` is given by the expression:

.. math::
   b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}

where the sum runs over :math:`n` "adjacent" kernel maps at the same spatial position, and :math:`N` is the total
number of kernels in the layer.



Defined in src/operator/nn/lrn.cc:L178
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LayerNorm" visbl="pub">
<a id="LayerNorm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LayerNorm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LayerNorm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LayerNorm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Layer normalization.

Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis and then
compute the normalized output, which has the same shape as input, as following:

.. math::

  out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta

Both ``gamma`` and ``beta`` are learnable parameters.

Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_std``. Note that no gradient will be passed through these two outputs.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is -1, which sets the channel
axis to be the last item in the input shape.



Defined in src/operator/nn/layer_norm.cc:L94
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Layer normalization.

Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis and then
compute the normalized output, which has the same shape as input, as following:

.. math::

  out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta

Both ``gamma`` and ``beta`` are learnable parameters.

Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_std``. Note that no gradient will be passed through these two outputs.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is -1, which sets the channel
axis to be the last item in the input shape.



Defined in src/operator/nn/layer_norm.cc:L94
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LayerNorm" visbl="pub">
<a id="LayerNorm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LayerNorm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LayerNorm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LayerNorm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Layer normalization.

Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis and then
compute the normalized output, which has the same shape as input, as following:

.. math::

  out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta

Both ``gamma`` and ``beta`` are learnable parameters.

Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_std``. Note that no gradient will be passed through these two outputs.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is -1, which sets the channel
axis to be the last item in the input shape.



Defined in src/operator/nn/layer_norm.cc:L94
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Layer normalization.

Normalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as
well as offset ``beta``.

Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis and then
compute the normalized output, which has the same shape as input, as following:

.. math::

  out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta

Both ``gamma`` and ``beta`` are learnable parameters.

Unlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.

Assume the input has size *k* on axis 1, then both ``gamma`` and ``beta``
have shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and
``data_std``. Note that no gradient will be passed through these two outputs.

The parameter ``axis`` specifies which axis of the input shape denotes
the 'channel' (separately normalized groups).  The default is -1, which sets the channel
axis to be the last item in the input shape.



Defined in src/operator/nn/layer_norm.cc:L94
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LeakyReLU" visbl="pub">
<a id="LeakyReLU(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LeakyReLU(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LeakyReLU</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LeakyReLU(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies Leaky rectified linear unit activation element-wise to the input.

Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small `slope`
when the input is negative and has a slope of one when input is positive.

The following modified ReLU Activation functions are supported:

- *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
- *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
  *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
- *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
- *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
- *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
  *[lower_bound, upper_bound)* for training, while fixed to be
  *(lower_bound+upper_bound)/2* for inference.



Defined in src/operator/leaky_relu.cc:L65
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies Leaky rectified linear unit activation element-wise to the input.

Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small `slope`
when the input is negative and has a slope of one when input is positive.

The following modified ReLU Activation functions are supported:

- *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
- *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
  *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
- *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
- *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
- *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
  *[lower_bound, upper_bound)* for training, while fixed to be
  *(lower_bound+upper_bound)/2* for inference.



Defined in src/operator/leaky_relu.cc:L65
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LeakyReLU" visbl="pub">
<a id="LeakyReLU(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LeakyReLU(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LeakyReLU</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LeakyReLU(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies Leaky rectified linear unit activation element-wise to the input.

Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small `slope`
when the input is negative and has a slope of one when input is positive.

The following modified ReLU Activation functions are supported:

- *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
- *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
  *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
- *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
- *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
- *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
  *[lower_bound, upper_bound)* for training, while fixed to be
  *(lower_bound+upper_bound)/2* for inference.



Defined in src/operator/leaky_relu.cc:L65
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies Leaky rectified linear unit activation element-wise to the input.

Leaky ReLUs attempt to fix the "dying ReLU" problem by allowing a small `slope`
when the input is negative and has a slope of one when input is positive.

The following modified ReLU Activation functions are supported:

- *elu*: Exponential Linear Unit. `y = x &gt; 0 ? x : slope * (exp(x)-1)`
- *selu*: Scaled Exponential Linear Unit. `y = lambda * (x &gt; 0 ? x : alpha * (exp(x) - 1))` where
  *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.
- *leaky*: Leaky ReLU. `y = x &gt; 0 ? x : slope * x`
- *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.
- *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from
  *[lower_bound, upper_bound)* for training, while fixed to be
  *(lower_bound+upper_bound)/2* for inference.



Defined in src/operator/leaky_relu.cc:L65
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LinearRegressionOutput" visbl="pub">
<a id="LinearRegressionOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LinearRegressionOutput(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LinearRegressionOutput</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LinearRegressionOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes and optimizes for squared loss during backward propagation.
Just outputs ``data`` during forward propagation.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the squared loss estimated over :math:`n` samples is defined as

:math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`

.. note::
   Use the LinearRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LinearRegressionOutput(default, default) = default
- LinearRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L92
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes and optimizes for squared loss during backward propagation.
Just outputs ``data`` during forward propagation.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the squared loss estimated over :math:`n` samples is defined as

:math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`

.. note::
   Use the LinearRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LinearRegressionOutput(default, default) = default
- LinearRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L92
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LinearRegressionOutput" visbl="pub">
<a id="LinearRegressionOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LinearRegressionOutput(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LinearRegressionOutput</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LinearRegressionOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes and optimizes for squared loss during backward propagation.
Just outputs ``data`` during forward propagation.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the squared loss estimated over :math:`n` samples is defined as

:math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`

.. note::
   Use the LinearRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LinearRegressionOutput(default, default) = default
- LinearRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L92
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes and optimizes for squared loss during backward propagation.
Just outputs ``data`` during forward propagation.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the squared loss estimated over :math:`n` samples is defined as

:math:`\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2`

.. note::
   Use the LinearRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LinearRegressionOutput(default, default) = default
- LinearRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L92
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LogisticRegressionOutput" visbl="pub">
<a id="LogisticRegressionOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LogisticRegressionOutput(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LogisticRegressionOutput</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LogisticRegressionOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies a logistic function to the input.

The logistic function, also known as the sigmoid function, is computed as
:math:`\frac{1}{1+exp(-\textbf{x})}`.

Commonly, the sigmoid is used to squash the real-valued output of a linear model
:math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
It is suitable for binary classification or probability prediction tasks.

.. note::
   Use the LogisticRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LogisticRegressionOutput(default, default) = default
- LogisticRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L148
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies a logistic function to the input.

The logistic function, also known as the sigmoid function, is computed as
:math:`\frac{1}{1+exp(-\textbf{x})}`.

Commonly, the sigmoid is used to squash the real-valued output of a linear model
:math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
It is suitable for binary classification or probability prediction tasks.

.. note::
   Use the LogisticRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LogisticRegressionOutput(default, default) = default
- LogisticRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L148
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#LogisticRegressionOutput" visbl="pub">
<a id="LogisticRegressionOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="LogisticRegressionOutput(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">LogisticRegressionOutput</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@LogisticRegressionOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies a logistic function to the input.

The logistic function, also known as the sigmoid function, is computed as
:math:`\frac{1}{1+exp(-\textbf{x})}`.

Commonly, the sigmoid is used to squash the real-valued output of a linear model
:math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
It is suitable for binary classification or probability prediction tasks.

.. note::
   Use the LogisticRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LogisticRegressionOutput(default, default) = default
- LogisticRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L148
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies a logistic function to the input.

The logistic function, also known as the sigmoid function, is computed as
:math:`\frac{1}{1+exp(-\textbf{x})}`.

Commonly, the sigmoid is used to squash the real-valued output of a linear model
:math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.
It is suitable for binary classification or probability prediction tasks.

.. note::
   Use the LogisticRegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- LogisticRegressionOutput(default, default) = default
- LogisticRegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L148
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#MAERegressionOutput" visbl="pub">
<a id="MAERegressionOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="MAERegressionOutput(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">MAERegressionOutput</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@MAERegressionOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes mean absolute error of the input.

MAE is a risk metric corresponding to the expected value of the absolute error.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the mean absolute error (MAE) estimated over :math:`n` samples is defined as

:math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`

.. note::
   Use the MAERegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- MAERegressionOutput(default, default) = default
- MAERegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L120
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes mean absolute error of the input.

MAE is a risk metric corresponding to the expected value of the absolute error.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the mean absolute error (MAE) estimated over :math:`n` samples is defined as

:math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`

.. note::
   Use the MAERegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- MAERegressionOutput(default, default) = default
- MAERegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L120
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#MAERegressionOutput" visbl="pub">
<a id="MAERegressionOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="MAERegressionOutput(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">MAERegressionOutput</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@MAERegressionOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes mean absolute error of the input.

MAE is a risk metric corresponding to the expected value of the absolute error.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the mean absolute error (MAE) estimated over :math:`n` samples is defined as

:math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`

.. note::
   Use the MAERegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- MAERegressionOutput(default, default) = default
- MAERegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L120
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes mean absolute error of the input.

MAE is a risk metric corresponding to the expected value of the absolute error.

If :math:`\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,
then the mean absolute error (MAE) estimated over :math:`n` samples is defined as

:math:`\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1`

.. note::
   Use the MAERegressionOutput as the final output layer of a net.

The storage type of ``label`` can be ``default`` or ``csr``

- MAERegressionOutput(default, default) = default
- MAERegressionOutput(default, csr) = default

By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.
The parameter `grad_scale` can be used to change this scale to `grad_scale/m`.



Defined in src/operator/regression_output.cc:L120
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#MakeLoss" visbl="pub">
<a id="MakeLoss(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="MakeLoss(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">MakeLoss</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@MakeLoss(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = MakeLoss(cross_entropy)

We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

In addition, we can give a scale to the loss by setting ``grad_scale``,
so that the gradient of the loss will be rescaled in the backpropagation.

.. note:: This operator should be used as a Symbol instead of NDArray.



Defined in src/operator/make_loss.cc:L71
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = MakeLoss(cross_entropy)

We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

In addition, we can give a scale to the loss by setting ``grad_scale``,
so that the gradient of the loss will be rescaled in the backpropagation.

.. note:: This operator should be used as a Symbol instead of NDArray.



Defined in src/operator/make_loss.cc:L71
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#MakeLoss" visbl="pub">
<a id="MakeLoss(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="MakeLoss(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">MakeLoss</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@MakeLoss(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = MakeLoss(cross_entropy)

We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

In addition, we can give a scale to the loss by setting ``grad_scale``,
so that the gradient of the loss will be rescaled in the backpropagation.

.. note:: This operator should be used as a Symbol instead of NDArray.



Defined in src/operator/make_loss.cc:L71
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = MakeLoss(cross_entropy)

We will need to use ``MakeLoss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

In addition, we can give a scale to the loss by setting ``grad_scale``,
so that the gradient of the loss will be rescaled in the backpropagation.

.. note:: This operator should be used as a Symbol instead of NDArray.



Defined in src/operator/make_loss.cc:L71
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Pad" visbl="pub">
<a id="Pad(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Pad(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Pad</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Pad(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Pad" visbl="pub">
<a id="Pad(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Pad(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Pad</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Pad(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Pooling" visbl="pub">
<a id="Pooling(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Pooling(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Pooling</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Pooling(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs pooling on the input.

The shapes for 1-D pooling are

- **data**: *(batch_size, channel, width)*,
- **out**: *(batch_size, num_filter, out_width)*.

The shapes for 2-D pooling are

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling
- **lp**: Lp pooling

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.

Notes on Lp pooling:

Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
We can see that Lp pooling stands between those two, in practice the most common value for p is 2.

For each window ``X``, the mathematical expression for Lp pooling is:

:math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`



Defined in src/operator/nn/pooling.cc:L388
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs pooling on the input.

The shapes for 1-D pooling are

- **data**: *(batch_size, channel, width)*,
- **out**: *(batch_size, num_filter, out_width)*.

The shapes for 2-D pooling are

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling
- **lp**: Lp pooling

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.

Notes on Lp pooling:

Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
We can see that Lp pooling stands between those two, in practice the most common value for p is 2.

For each window ``X``, the mathematical expression for Lp pooling is:

:math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`



Defined in src/operator/nn/pooling.cc:L388
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Pooling" visbl="pub">
<a id="Pooling(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Pooling(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Pooling</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Pooling(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs pooling on the input.

The shapes for 1-D pooling are

- **data**: *(batch_size, channel, width)*,
- **out**: *(batch_size, num_filter, out_width)*.

The shapes for 2-D pooling are

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling
- **lp**: Lp pooling

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.

Notes on Lp pooling:

Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
We can see that Lp pooling stands between those two, in practice the most common value for p is 2.

For each window ``X``, the mathematical expression for Lp pooling is:

:math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`



Defined in src/operator/nn/pooling.cc:L388
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs pooling on the input.

The shapes for 1-D pooling are

- **data**: *(batch_size, channel, width)*,
- **out**: *(batch_size, num_filter, out_width)*.

The shapes for 2-D pooling are

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling
- **lp**: Lp pooling

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.

Notes on Lp pooling:

Lp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.
L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
We can see that Lp pooling stands between those two, in practice the most common value for p is 2.

For each window ``X``, the mathematical expression for Lp pooling is:

:math:`f(X) = \sqrt[p]{\sum_{x}^{X} x^p}`



Defined in src/operator/nn/pooling.cc:L388
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Pooling_v1" visbl="pub">
<a id="Pooling_v1(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Pooling_v1(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Pooling_v1</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Pooling_v1(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
This operator is DEPRECATED.
Perform pooling on the input.

The shapes for 2-D pooling is

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling

1-D pooling is special case of 2-D pooling with *weight=1* and
*kernel[1]=1*.

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.



Defined in src/operator/pooling_v1.cc:L104
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
This operator is DEPRECATED.
Perform pooling on the input.

The shapes for 2-D pooling is

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling

1-D pooling is special case of 2-D pooling with *weight=1* and
*kernel[1]=1*.

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.



Defined in src/operator/pooling_v1.cc:L104
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Pooling_v1" visbl="pub">
<a id="Pooling_v1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Pooling_v1(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Pooling_v1</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Pooling_v1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
This operator is DEPRECATED.
Perform pooling on the input.

The shapes for 2-D pooling is

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling

1-D pooling is special case of 2-D pooling with *weight=1* and
*kernel[1]=1*.

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.



Defined in src/operator/pooling_v1.cc:L104
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
This operator is DEPRECATED.
Perform pooling on the input.

The shapes for 2-D pooling is

- **data**: *(batch_size, channel, height, width)*
- **out**: *(batch_size, num_filter, out_height, out_width)*, with::

    out_height = f(height, kernel[0], pad[0], stride[0])
    out_width = f(width, kernel[1], pad[1], stride[1])

The definition of *f* depends on ``pooling_convention``, which has two options:

- **valid** (default)::

    f(x, k, p, s) = floor((x+2*p-k)/s)+1

- **full**, which is compatible with Caffe::

    f(x, k, p, s) = ceil((x+2*p-k)/s)+1

But ``global_pool`` is set to be true, then do a global pooling, namely reset
``kernel=(height, width)``.

Three pooling options are supported by ``pool_type``:

- **avg**: average pooling
- **max**: max pooling
- **sum**: sum pooling

1-D pooling is special case of 2-D pooling with *weight=1* and
*kernel[1]=1*.

For 3-D pooling, an additional *depth* dimension is added before
*height*. Namely the input data will have shape *(batch_size, channel, depth,
height, width)*.



Defined in src/operator/pooling_v1.cc:L104
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#RNN" visbl="pub">
<a id="RNN(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="RNN(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">RNN</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@RNN(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
implemented, with both multi-layer and bidirectional support.

**Vanilla RNN**

Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
ReLU and Tanh.

With ReLU activation function:

.. math::
    h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

With Tanh activtion function:

.. math::
    h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

Reference paper: Finding structure in time - Elman, 1988.
https://crl.ucsd.edu/~elman/Papers/fsit.pdf

**LSTM**

Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf

.. math::
  \begin{array}{ll}
            i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
            f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
            g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
            o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
            c_t = f_t * c_{(t-1)} + i_t * g_t \\
            h_t = o_t * \tanh(c_t)
            \end{array}

**GRU**

Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078

The definition of GRU here is slightly different from paper but compatible with CUDNN.

.. math::
  \begin{array}{ll}
            r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
            z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
            n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
            h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
            \end{array}
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
implemented, with both multi-layer and bidirectional support.

**Vanilla RNN**

Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
ReLU and Tanh.

With ReLU activation function:

.. math::
    h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

With Tanh activtion function:

.. math::
    h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

Reference paper: Finding structure in time - Elman, 1988.
https://crl.ucsd.edu/~elman/Papers/fsit.pdf

**LSTM**

Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf

.. math::
  \begin{array}{ll}
            i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
            f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
            g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
            o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
            c_t = f_t * c_{(t-1)} + i_t * g_t \\
            h_t = o_t * \tanh(c_t)
            \end{array}

**GRU**

Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078

The definition of GRU here is slightly different from paper but compatible with CUDNN.

.. math::
  \begin{array}{ll}
            r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
            z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
            n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
            h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
            \end{array}
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#RNN" visbl="pub">
<a id="RNN(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="RNN(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">RNN</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@RNN(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
implemented, with both multi-layer and bidirectional support.

**Vanilla RNN**

Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
ReLU and Tanh.

With ReLU activation function:

.. math::
    h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

With Tanh activtion function:

.. math::
    h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

Reference paper: Finding structure in time - Elman, 1988.
https://crl.ucsd.edu/~elman/Papers/fsit.pdf

**LSTM**

Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf

.. math::
  \begin{array}{ll}
            i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
            f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
            g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
            o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
            c_t = f_t * c_{(t-1)} + i_t * g_t \\
            h_t = o_t * \tanh(c_t)
            \end{array}

**GRU**

Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078

The definition of GRU here is slightly different from paper but compatible with CUDNN.

.. math::
  \begin{array}{ll}
            r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
            z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
            n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
            h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
            \end{array}
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
implemented, with both multi-layer and bidirectional support.

**Vanilla RNN**

Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
ReLU and Tanh.

With ReLU activation function:

.. math::
    h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

With Tanh activtion function:

.. math::
    h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})

Reference paper: Finding structure in time - Elman, 1988.
https://crl.ucsd.edu/~elman/Papers/fsit.pdf

**LSTM**

Long Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf

.. math::
  \begin{array}{ll}
            i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
            f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
            g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
            o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
            c_t = f_t * c_{(t-1)} + i_t * g_t \\
            h_t = o_t * \tanh(c_t)
            \end{array}

**GRU**

Gated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078

The definition of GRU here is slightly different from paper but compatible with CUDNN.

.. math::
  \begin{array}{ll}
            r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
            z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
            n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
            h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
            \end{array}
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ROIPooling" visbl="pub">
<a id="ROIPooling(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ROIPooling(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ROIPooling</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ROIPooling(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs region of interest(ROI) pooling on the input array.

ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
region of interest is a parameter. Its purpose is to perform max pooling on the inputs
of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
layer mostly used in training a `Fast R-CNN` network for object detection.

This operator takes a 4D feature map as an input array and region proposals as `rois`,
then it pools over sub-regions of input and produces a fixed-sized output array
regardless of the ROI size.

To crop the feature map accordingly, you can resize the bounding box coordinates
by changing the parameters `rois` and `spatial_scale`.

The cropped feature maps are pooled by standard max pooling operation to a fixed size output
indicated by a `pooled_size` parameter. batch_size will change to the number of region
bounding boxes after `ROIPooling`.

The size of each region of interest doesn't have to be perfectly divisible by
the number of pooling sections(`pooled_size`).

Example::

  x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
         [  6.,   7.,   8.,   9.,  10.,  11.],
         [ 12.,  13.,  14.,  15.,  16.,  17.],
         [ 18.,  19.,  20.,  21.,  22.,  23.],
         [ 24.,  25.,  26.,  27.,  28.,  29.],
         [ 30.,  31.,  32.,  33.,  34.,  35.],
         [ 36.,  37.,  38.,  39.,  40.,  41.],
         [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

  // region of interest i.e. bounding box coordinates.
  y = [[0,0,0,4,4]]

  // returns array of shape (2,2) according to the given roi with max pooling.
  ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
                                    [ 26.,  28.]]]]

  // region of interest is changed due to the change in `spacial_scale` parameter.
  ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
                                    [ 19.,  21.]]]]



Defined in src/operator/roi_pooling.cc:L295
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs region of interest(ROI) pooling on the input array.

ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
region of interest is a parameter. Its purpose is to perform max pooling on the inputs
of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
layer mostly used in training a `Fast R-CNN` network for object detection.

This operator takes a 4D feature map as an input array and region proposals as `rois`,
then it pools over sub-regions of input and produces a fixed-sized output array
regardless of the ROI size.

To crop the feature map accordingly, you can resize the bounding box coordinates
by changing the parameters `rois` and `spatial_scale`.

The cropped feature maps are pooled by standard max pooling operation to a fixed size output
indicated by a `pooled_size` parameter. batch_size will change to the number of region
bounding boxes after `ROIPooling`.

The size of each region of interest doesn't have to be perfectly divisible by
the number of pooling sections(`pooled_size`).

Example::

  x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
         [  6.,   7.,   8.,   9.,  10.,  11.],
         [ 12.,  13.,  14.,  15.,  16.,  17.],
         [ 18.,  19.,  20.,  21.,  22.,  23.],
         [ 24.,  25.,  26.,  27.,  28.,  29.],
         [ 30.,  31.,  32.,  33.,  34.,  35.],
         [ 36.,  37.,  38.,  39.,  40.,  41.],
         [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

  // region of interest i.e. bounding box coordinates.
  y = [[0,0,0,4,4]]

  // returns array of shape (2,2) according to the given roi with max pooling.
  ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
                                    [ 26.,  28.]]]]

  // region of interest is changed due to the change in `spacial_scale` parameter.
  ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
                                    [ 19.,  21.]]]]



Defined in src/operator/roi_pooling.cc:L295
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ROIPooling" visbl="pub">
<a id="ROIPooling(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ROIPooling(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ROIPooling</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ROIPooling(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs region of interest(ROI) pooling on the input array.

ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
region of interest is a parameter. Its purpose is to perform max pooling on the inputs
of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
layer mostly used in training a `Fast R-CNN` network for object detection.

This operator takes a 4D feature map as an input array and region proposals as `rois`,
then it pools over sub-regions of input and produces a fixed-sized output array
regardless of the ROI size.

To crop the feature map accordingly, you can resize the bounding box coordinates
by changing the parameters `rois` and `spatial_scale`.

The cropped feature maps are pooled by standard max pooling operation to a fixed size output
indicated by a `pooled_size` parameter. batch_size will change to the number of region
bounding boxes after `ROIPooling`.

The size of each region of interest doesn't have to be perfectly divisible by
the number of pooling sections(`pooled_size`).

Example::

  x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
         [  6.,   7.,   8.,   9.,  10.,  11.],
         [ 12.,  13.,  14.,  15.,  16.,  17.],
         [ 18.,  19.,  20.,  21.,  22.,  23.],
         [ 24.,  25.,  26.,  27.,  28.,  29.],
         [ 30.,  31.,  32.,  33.,  34.,  35.],
         [ 36.,  37.,  38.,  39.,  40.,  41.],
         [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

  // region of interest i.e. bounding box coordinates.
  y = [[0,0,0,4,4]]

  // returns array of shape (2,2) according to the given roi with max pooling.
  ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
                                    [ 26.,  28.]]]]

  // region of interest is changed due to the change in `spacial_scale` parameter.
  ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
                                    [ 19.,  21.]]]]



Defined in src/operator/roi_pooling.cc:L295
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs region of interest(ROI) pooling on the input array.

ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
region of interest is a parameter. Its purpose is to perform max pooling on the inputs
of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
layer mostly used in training a `Fast R-CNN` network for object detection.

This operator takes a 4D feature map as an input array and region proposals as `rois`,
then it pools over sub-regions of input and produces a fixed-sized output array
regardless of the ROI size.

To crop the feature map accordingly, you can resize the bounding box coordinates
by changing the parameters `rois` and `spatial_scale`.

The cropped feature maps are pooled by standard max pooling operation to a fixed size output
indicated by a `pooled_size` parameter. batch_size will change to the number of region
bounding boxes after `ROIPooling`.

The size of each region of interest doesn't have to be perfectly divisible by
the number of pooling sections(`pooled_size`).

Example::

  x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
         [  6.,   7.,   8.,   9.,  10.,  11.],
         [ 12.,  13.,  14.,  15.,  16.,  17.],
         [ 18.,  19.,  20.,  21.,  22.,  23.],
         [ 24.,  25.,  26.,  27.,  28.,  29.],
         [ 30.,  31.,  32.,  33.,  34.,  35.],
         [ 36.,  37.,  38.,  39.,  40.,  41.],
         [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

  // region of interest i.e. bounding box coordinates.
  y = [[0,0,0,4,4]]

  // returns array of shape (2,2) according to the given roi with max pooling.
  ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
                                    [ 26.,  28.]]]]

  // region of interest is changed due to the change in `spacial_scale` parameter.
  ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
                                    [ 19.,  21.]]]]



Defined in src/operator/roi_pooling.cc:L295
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Reshape" visbl="pub">
<a id="Reshape(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Reshape(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Reshape</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Reshape(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Reshape" visbl="pub">
<a id="Reshape(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Reshape(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Reshape</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Reshape(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SVMOutput" visbl="pub">
<a id="SVMOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SVMOutput(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SVMOutput</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SVMOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes support vector machine based transformation of the input.

This tutorial demonstrates using SVM as output layer for classification instead of softmax:
https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes support vector machine based transformation of the input.

This tutorial demonstrates using SVM as output layer for classification instead of softmax:
https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SVMOutput" visbl="pub">
<a id="SVMOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SVMOutput(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SVMOutput</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SVMOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes support vector machine based transformation of the input.

This tutorial demonstrates using SVM as output layer for classification instead of softmax:
https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes support vector machine based transformation of the input.

This tutorial demonstrates using SVM as output layer for classification instead of softmax:
https://github.com/dmlc/mxnet/tree/master/example/svm_mnist.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SequenceLast" visbl="pub">
<a id="SequenceLast(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SequenceLast(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SequenceLast</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SequenceLast(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Takes the last element of a sequence.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
of the form [batch_size, other_feature_dims].

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
an input array of positive ints of dimension [batch_size]. To use this parameter,
set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
to have the max sequence length.

.. note:: Alternatively, you can also use `take` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.],
         [  7.,   8.,   9.]],

        [[ 10.,   11.,   12.],
         [ 13.,   14.,   15.],
         [ 16.,   17.,   18.]],

        [[  19.,   20.,   21.],
         [  22.,   23.,   24.],
         [  25.,   26.,   27.]]]

   // returns last sequence when sequence_length parameter is not used
   SequenceLast(x) = [[  19.,   20.,   21.],
                      [  22.,   23.,   24.],
                      [  25.,   26.,   27.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
            [[  1.,   2.,   3.],
             [  4.,   5.,   6.],
             [  7.,   8.,   9.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
            [[  1.,    2.,   3.],
             [  13.,  14.,  15.],
             [  25.,  26.,  27.]]



Defined in src/operator/sequence_last.cc:L92
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Takes the last element of a sequence.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
of the form [batch_size, other_feature_dims].

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
an input array of positive ints of dimension [batch_size]. To use this parameter,
set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
to have the max sequence length.

.. note:: Alternatively, you can also use `take` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.],
         [  7.,   8.,   9.]],

        [[ 10.,   11.,   12.],
         [ 13.,   14.,   15.],
         [ 16.,   17.,   18.]],

        [[  19.,   20.,   21.],
         [  22.,   23.,   24.],
         [  25.,   26.,   27.]]]

   // returns last sequence when sequence_length parameter is not used
   SequenceLast(x) = [[  19.,   20.,   21.],
                      [  22.,   23.,   24.],
                      [  25.,   26.,   27.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
            [[  1.,   2.,   3.],
             [  4.,   5.,   6.],
             [  7.,   8.,   9.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
            [[  1.,    2.,   3.],
             [  13.,  14.,  15.],
             [  25.,  26.,  27.]]



Defined in src/operator/sequence_last.cc:L92
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SequenceLast" visbl="pub">
<a id="SequenceLast(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SequenceLast(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SequenceLast</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SequenceLast(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Takes the last element of a sequence.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
of the form [batch_size, other_feature_dims].

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
an input array of positive ints of dimension [batch_size]. To use this parameter,
set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
to have the max sequence length.

.. note:: Alternatively, you can also use `take` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.],
         [  7.,   8.,   9.]],

        [[ 10.,   11.,   12.],
         [ 13.,   14.,   15.],
         [ 16.,   17.,   18.]],

        [[  19.,   20.,   21.],
         [  22.,   23.,   24.],
         [  25.,   26.,   27.]]]

   // returns last sequence when sequence_length parameter is not used
   SequenceLast(x) = [[  19.,   20.,   21.],
                      [  22.,   23.,   24.],
                      [  25.,   26.,   27.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
            [[  1.,   2.,   3.],
             [  4.,   5.,   6.],
             [  7.,   8.,   9.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
            [[  1.,    2.,   3.],
             [  13.,  14.,  15.],
             [  25.,  26.,  27.]]



Defined in src/operator/sequence_last.cc:L92
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Takes the last element of a sequence.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
of the form [batch_size, other_feature_dims].

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be
an input array of positive ints of dimension [batch_size]. To use this parameter,
set `use_sequence_length` to `True`, otherwise each example in the batch is assumed
to have the max sequence length.

.. note:: Alternatively, you can also use `take` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.],
         [  7.,   8.,   9.]],

        [[ 10.,   11.,   12.],
         [ 13.,   14.,   15.],
         [ 16.,   17.,   18.]],

        [[  19.,   20.,   21.],
         [  22.,   23.,   24.],
         [  25.,   26.,   27.]]]

   // returns last sequence when sequence_length parameter is not used
   SequenceLast(x) = [[  19.,   20.,   21.],
                      [  22.,   23.,   24.],
                      [  25.,   26.,   27.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =
            [[  1.,   2.,   3.],
             [  4.,   5.,   6.],
             [  7.,   8.,   9.]]

   // sequence_length is used
   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =
            [[  1.,    2.,   3.],
             [  13.,  14.,  15.],
             [  25.,  26.,  27.]]



Defined in src/operator/sequence_last.cc:L92
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SequenceMask" visbl="pub">
<a id="SequenceMask(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SequenceMask(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SequenceMask</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SequenceMask(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Sets all elements outside the sequence to a constant value.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length and
this operator works as the `identity` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // works as identity operator when sequence_length parameter is not used
   SequenceMask(x) = [[[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [1,1] means 1 of each batch will be kept
   // and other rows are masked with default mask value = 0
   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]]]

   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
   // and other rows are masked with value = 1
   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  7.,   8.,   9.],
                  [  10.,  11.,  12.]],

                 [[   1.,   1.,   1.],
                  [  16.,  17.,  18.]]]



Defined in src/operator/sequence_mask.cc:L114
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Sets all elements outside the sequence to a constant value.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length and
this operator works as the `identity` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // works as identity operator when sequence_length parameter is not used
   SequenceMask(x) = [[[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [1,1] means 1 of each batch will be kept
   // and other rows are masked with default mask value = 0
   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]]]

   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
   // and other rows are masked with value = 1
   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  7.,   8.,   9.],
                  [  10.,  11.,  12.]],

                 [[   1.,   1.,   1.],
                  [  16.,  17.,  18.]]]



Defined in src/operator/sequence_mask.cc:L114
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SequenceMask" visbl="pub">
<a id="SequenceMask(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SequenceMask(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SequenceMask</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SequenceMask(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Sets all elements outside the sequence to a constant value.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length and
this operator works as the `identity` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // works as identity operator when sequence_length parameter is not used
   SequenceMask(x) = [[[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [1,1] means 1 of each batch will be kept
   // and other rows are masked with default mask value = 0
   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]]]

   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
   // and other rows are masked with value = 1
   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  7.,   8.,   9.],
                  [  10.,  11.,  12.]],

                 [[   1.,   1.,   1.],
                  [  16.,  17.,  18.]]]



Defined in src/operator/sequence_mask.cc:L114
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Sets all elements outside the sequence to a constant value.

This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences. `sequence_length`
should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length and
this operator works as the `identity` operator.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // works as identity operator when sequence_length parameter is not used
   SequenceMask(x) = [[[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [1,1] means 1 of each batch will be kept
   // and other rows are masked with default mask value = 0
   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]],

                 [[  0.,   0.,   0.],
                  [  0.,   0.,   0.]]]

   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept
   // and other rows are masked with value = 1
   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =
                [[[  1.,   2.,   3.],
                  [  4.,   5.,   6.]],

                 [[  7.,   8.,   9.],
                  [  10.,  11.,  12.]],

                 [[   1.,   1.,   1.],
                  [  16.,  17.,  18.]]]



Defined in src/operator/sequence_mask.cc:L114
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SequenceReverse" visbl="pub">
<a id="SequenceReverse(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SequenceReverse(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SequenceReverse</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SequenceReverse(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reverses the elements of each sequence.

This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences.
`sequence_length` should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // returns reverse sequence when sequence_length parameter is not used
   SequenceReverse(x) = [[[ 13.,  14.,   15.],
                          [ 16.,  17.,   18.]],

                         [[  7.,   8.,   9.],
                          [ 10.,  11.,  12.]],

                         [[  1.,   2.,   3.],
                          [  4.,   5.,   6.]]]

   // sequence_length [2,2] means 2 rows of
   // both batch B1 and B2 will be reversed.
   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
                     [[[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
   // will be reversed.
   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
                    [[[  7.,   8.,   9.],
                      [ 16.,  17.,  18.]],

                     [[  1.,   2.,   3.],
                      [ 10.,  11.,  12.]],

                     [[ 13.,  14,   15.],
                      [  4.,   5.,   6.]]]



Defined in src/operator/sequence_reverse.cc:L113
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reverses the elements of each sequence.

This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences.
`sequence_length` should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // returns reverse sequence when sequence_length parameter is not used
   SequenceReverse(x) = [[[ 13.,  14.,   15.],
                          [ 16.,  17.,   18.]],

                         [[  7.,   8.,   9.],
                          [ 10.,  11.,  12.]],

                         [[  1.,   2.,   3.],
                          [  4.,   5.,   6.]]]

   // sequence_length [2,2] means 2 rows of
   // both batch B1 and B2 will be reversed.
   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
                     [[[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
   // will be reversed.
   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
                    [[[  7.,   8.,   9.],
                      [ 16.,  17.,  18.]],

                     [[  1.,   2.,   3.],
                      [ 10.,  11.,  12.]],

                     [[ 13.,  14,   15.],
                      [  4.,   5.,   6.]]]



Defined in src/operator/sequence_reverse.cc:L113
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SequenceReverse" visbl="pub">
<a id="SequenceReverse(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SequenceReverse(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SequenceReverse</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SequenceReverse(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reverses the elements of each sequence.

This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences.
`sequence_length` should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // returns reverse sequence when sequence_length parameter is not used
   SequenceReverse(x) = [[[ 13.,  14.,   15.],
                          [ 16.,  17.,   18.]],

                         [[  7.,   8.,   9.],
                          [ 10.,  11.,  12.]],

                         [[  1.,   2.,   3.],
                          [  4.,   5.,   6.]]]

   // sequence_length [2,2] means 2 rows of
   // both batch B1 and B2 will be reversed.
   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
                     [[[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
   // will be reversed.
   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
                    [[[  7.,   8.,   9.],
                      [ 16.,  17.,  18.]],

                     [[  1.,   2.,   3.],
                      [ 10.,  11.,  12.]],

                     [[ 13.,  14,   15.],
                      [  4.,   5.,   6.]]]



Defined in src/operator/sequence_reverse.cc:L113
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reverses the elements of each sequence.

This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
and returns an array of the same shape.

Parameter `sequence_length` is used to handle variable-length sequences.
`sequence_length` should be an input array of positive ints of dimension [batch_size].
To use this parameter, set `use_sequence_length` to `True`,
otherwise each example in the batch is assumed to have the max sequence length.

Example::

   x = [[[  1.,   2.,   3.],
         [  4.,   5.,   6.]],

        [[  7.,   8.,   9.],
         [ 10.,  11.,  12.]],

        [[ 13.,  14.,   15.],
         [ 16.,  17.,   18.]]]

   // Batch 1
   B1 = [[  1.,   2.,   3.],
         [  7.,   8.,   9.],
         [ 13.,  14.,  15.]]

   // Batch 2
   B2 = [[  4.,   5.,   6.],
         [ 10.,  11.,  12.],
         [ 16.,  17.,  18.]]

   // returns reverse sequence when sequence_length parameter is not used
   SequenceReverse(x) = [[[ 13.,  14.,   15.],
                          [ 16.,  17.,   18.]],

                         [[  7.,   8.,   9.],
                          [ 10.,  11.,  12.]],

                         [[  1.,   2.,   3.],
                          [  4.,   5.,   6.]]]

   // sequence_length [2,2] means 2 rows of
   // both batch B1 and B2 will be reversed.
   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =
                     [[[  7.,   8.,   9.],
                       [ 10.,  11.,  12.]],

                      [[  1.,   2.,   3.],
                       [  4.,   5.,   6.]],

                      [[ 13.,  14.,   15.],
                       [ 16.,  17.,   18.]]]

   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3
   // will be reversed.
   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =
                    [[[  7.,   8.,   9.],
                      [ 16.,  17.,  18.]],

                     [[  1.,   2.,   3.],
                      [ 10.,  11.,  12.]],

                     [[ 13.,  14,   15.],
                      [  4.,   5.,   6.]]]



Defined in src/operator/sequence_reverse.cc:L113
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SliceChannel" visbl="pub">
<a id="SliceChannel(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SliceChannel(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SliceChannel</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SliceChannel(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SliceChannel" visbl="pub">
<a id="SliceChannel(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SliceChannel(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SliceChannel</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SliceChannel(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Softmax" visbl="pub">
<a id="Softmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Softmax(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Softmax</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Softmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Please use `SoftmaxOutput`.

.. note::

  This operator has been renamed to `SoftmaxOutput`, which
  computes the gradient of cross-entropy loss w.r.t softmax output.
  To just compute softmax output, use the `softmax` operator.



Defined in src/operator/softmax_output.cc:L138
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Please use `SoftmaxOutput`.

.. note::

  This operator has been renamed to `SoftmaxOutput`, which
  computes the gradient of cross-entropy loss w.r.t softmax output.
  To just compute softmax output, use the `softmax` operator.



Defined in src/operator/softmax_output.cc:L138
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#Softmax" visbl="pub">
<a id="Softmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="Softmax(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">Softmax</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@Softmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Please use `SoftmaxOutput`.

.. note::

  This operator has been renamed to `SoftmaxOutput`, which
  computes the gradient of cross-entropy loss w.r.t softmax output.
  To just compute softmax output, use the `softmax` operator.



Defined in src/operator/softmax_output.cc:L138
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Please use `SoftmaxOutput`.

.. note::

  This operator has been renamed to `SoftmaxOutput`, which
  computes the gradient of cross-entropy loss w.r.t softmax output.
  To just compute softmax output, use the `softmax` operator.



Defined in src/operator/softmax_output.cc:L138
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SoftmaxActivation" visbl="pub">
<a id="SoftmaxActivation(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SoftmaxActivation(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SoftmaxActivation</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SoftmaxActivation(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies softmax activation to input. This is intended for internal layers.

.. note::

  This operator has been deprecated, please use `softmax`.

If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
This is the default mode.

If `mode` = ``channel``, this operator will compute a k-class softmax at each position
of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
has at least 3 dimensions.
This can be used for `fully convolutional network`, `image segmentation`, etc.

Example::

  &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
  &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
  &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
  &gt;&gt;&gt; print softmax_act.asnumpy()
  [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]



Defined in src/operator/nn/softmax_activation.cc:L59
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies softmax activation to input. This is intended for internal layers.

.. note::

  This operator has been deprecated, please use `softmax`.

If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
This is the default mode.

If `mode` = ``channel``, this operator will compute a k-class softmax at each position
of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
has at least 3 dimensions.
This can be used for `fully convolutional network`, `image segmentation`, etc.

Example::

  &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
  &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
  &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
  &gt;&gt;&gt; print softmax_act.asnumpy()
  [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]



Defined in src/operator/nn/softmax_activation.cc:L59
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SoftmaxActivation" visbl="pub">
<a id="SoftmaxActivation(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SoftmaxActivation(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SoftmaxActivation</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SoftmaxActivation(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies softmax activation to input. This is intended for internal layers.

.. note::

  This operator has been deprecated, please use `softmax`.

If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
This is the default mode.

If `mode` = ``channel``, this operator will compute a k-class softmax at each position
of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
has at least 3 dimensions.
This can be used for `fully convolutional network`, `image segmentation`, etc.

Example::

  &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
  &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
  &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
  &gt;&gt;&gt; print softmax_act.asnumpy()
  [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]



Defined in src/operator/nn/softmax_activation.cc:L59
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies softmax activation to input. This is intended for internal layers.

.. note::

  This operator has been deprecated, please use `softmax`.

If `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.
This is the default mode.

If `mode` = ``channel``, this operator will compute a k-class softmax at each position
of each instance, where `k` = ``num_channel``. This mode can only be used when the input array
has at least 3 dimensions.
This can be used for `fully convolutional network`, `image segmentation`, etc.

Example::

  &gt;&gt;&gt; input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],
  &gt;&gt;&gt;                            [2., -.4, 7.,   3., 0.2]])
  &gt;&gt;&gt; softmax_act = mx.nd.SoftmaxActivation(input_array)
  &gt;&gt;&gt; print softmax_act.asnumpy()
  [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]
   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]



Defined in src/operator/nn/softmax_activation.cc:L59
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SoftmaxOutput" visbl="pub">
<a id="SoftmaxOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SoftmaxOutput(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SoftmaxOutput</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SoftmaxOutput(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the gradient of cross entropy loss with respect to softmax output.

- This operator computes the gradient in two steps.
  The cross entropy loss does not actually need to be computed.

  - Applies softmax function on the input array.
  - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.

- The softmax function, cross entropy loss and gradient is given by:

  - Softmax Function:

    .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

    .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

  - The gradient of cross entropy loss w.r.t softmax output:

    .. math:: \text{gradient} = \text{output} - \text{label}

- During forward propagation, the softmax function is computed for each instance in the input array.

  For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
  :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
  and `multi_output` to specify the way to compute softmax:

  - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    each row in the reshaped array, and afterwards reshape it back to the original shape
    :math:`(d_1, d_2, ..., d_n)`.
  - If `preserve_shape` is ``true``, the softmax function will be computed along
    the last axis (`axis` = ``-1``).
  - If `multi_output` is ``true``, the softmax function will be computed along
    the second axis (`axis` = ``1``).

- During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
  The provided label can be a one-hot label array or a probability label array.

  - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    with a particular label to be ignored during backward propagation. **This has no effect when
    softmax `output` has same shape as `label`**.

    Example::

      data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
      label = [1,0,2,3]
      ignore_label = 1
      SoftmaxOutput(data=data, label = label,\
                    multi_output=true, use_ignore=true,\
                    ignore_label=ignore_label)
      ## forward softmax output
      [[ 0.0320586   0.08714432  0.23688284  0.64391428]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]]
      ## backward gradient output
      [[ 0.    0.    0.    0.  ]
       [-0.75  0.25  0.25  0.25]
       [ 0.25  0.25 -0.75  0.25]
       [ 0.25  0.25  0.25 -0.75]]
      ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.

  - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    give each loss function different weights.

  - This operator also supports various ways to normalize the gradient by `normalization`,
    The `normalization` is applied if softmax output has different shape than the labels.
    The `normalization` mode can be set to the followings:

    - ``'null'``: do nothing.
    - ``'batch'``: divide the gradient by the batch size.
    - ``'valid'``: divide the gradient by the number of instances which are not ignored.



Defined in src/operator/softmax_output.cc:L123
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the gradient of cross entropy loss with respect to softmax output.

- This operator computes the gradient in two steps.
  The cross entropy loss does not actually need to be computed.

  - Applies softmax function on the input array.
  - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.

- The softmax function, cross entropy loss and gradient is given by:

  - Softmax Function:

    .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

    .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

  - The gradient of cross entropy loss w.r.t softmax output:

    .. math:: \text{gradient} = \text{output} - \text{label}

- During forward propagation, the softmax function is computed for each instance in the input array.

  For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
  :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
  and `multi_output` to specify the way to compute softmax:

  - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    each row in the reshaped array, and afterwards reshape it back to the original shape
    :math:`(d_1, d_2, ..., d_n)`.
  - If `preserve_shape` is ``true``, the softmax function will be computed along
    the last axis (`axis` = ``-1``).
  - If `multi_output` is ``true``, the softmax function will be computed along
    the second axis (`axis` = ``1``).

- During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
  The provided label can be a one-hot label array or a probability label array.

  - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    with a particular label to be ignored during backward propagation. **This has no effect when
    softmax `output` has same shape as `label`**.

    Example::

      data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
      label = [1,0,2,3]
      ignore_label = 1
      SoftmaxOutput(data=data, label = label,\
                    multi_output=true, use_ignore=true,\
                    ignore_label=ignore_label)
      ## forward softmax output
      [[ 0.0320586   0.08714432  0.23688284  0.64391428]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]]
      ## backward gradient output
      [[ 0.    0.    0.    0.  ]
       [-0.75  0.25  0.25  0.25]
       [ 0.25  0.25 -0.75  0.25]
       [ 0.25  0.25  0.25 -0.75]]
      ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.

  - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    give each loss function different weights.

  - This operator also supports various ways to normalize the gradient by `normalization`,
    The `normalization` is applied if softmax output has different shape than the labels.
    The `normalization` mode can be set to the followings:

    - ``'null'``: do nothing.
    - ``'batch'``: divide the gradient by the batch size.
    - ``'valid'``: divide the gradient by the number of instances which are not ignored.



Defined in src/operator/softmax_output.cc:L123
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SoftmaxOutput" visbl="pub">
<a id="SoftmaxOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SoftmaxOutput(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SoftmaxOutput</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SoftmaxOutput(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the gradient of cross entropy loss with respect to softmax output.

- This operator computes the gradient in two steps.
  The cross entropy loss does not actually need to be computed.

  - Applies softmax function on the input array.
  - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.

- The softmax function, cross entropy loss and gradient is given by:

  - Softmax Function:

    .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

    .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

  - The gradient of cross entropy loss w.r.t softmax output:

    .. math:: \text{gradient} = \text{output} - \text{label}

- During forward propagation, the softmax function is computed for each instance in the input array.

  For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
  :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
  and `multi_output` to specify the way to compute softmax:

  - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    each row in the reshaped array, and afterwards reshape it back to the original shape
    :math:`(d_1, d_2, ..., d_n)`.
  - If `preserve_shape` is ``true``, the softmax function will be computed along
    the last axis (`axis` = ``-1``).
  - If `multi_output` is ``true``, the softmax function will be computed along
    the second axis (`axis` = ``1``).

- During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
  The provided label can be a one-hot label array or a probability label array.

  - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    with a particular label to be ignored during backward propagation. **This has no effect when
    softmax `output` has same shape as `label`**.

    Example::

      data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
      label = [1,0,2,3]
      ignore_label = 1
      SoftmaxOutput(data=data, label = label,\
                    multi_output=true, use_ignore=true,\
                    ignore_label=ignore_label)
      ## forward softmax output
      [[ 0.0320586   0.08714432  0.23688284  0.64391428]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]]
      ## backward gradient output
      [[ 0.    0.    0.    0.  ]
       [-0.75  0.25  0.25  0.25]
       [ 0.25  0.25 -0.75  0.25]
       [ 0.25  0.25  0.25 -0.75]]
      ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.

  - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    give each loss function different weights.

  - This operator also supports various ways to normalize the gradient by `normalization`,
    The `normalization` is applied if softmax output has different shape than the labels.
    The `normalization` mode can be set to the followings:

    - ``'null'``: do nothing.
    - ``'batch'``: divide the gradient by the batch size.
    - ``'valid'``: divide the gradient by the number of instances which are not ignored.



Defined in src/operator/softmax_output.cc:L123
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the gradient of cross entropy loss with respect to softmax output.

- This operator computes the gradient in two steps.
  The cross entropy loss does not actually need to be computed.

  - Applies softmax function on the input array.
  - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.

- The softmax function, cross entropy loss and gradient is given by:

  - Softmax Function:

    .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

    .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

  - The gradient of cross entropy loss w.r.t softmax output:

    .. math:: \text{gradient} = \text{output} - \text{label}

- During forward propagation, the softmax function is computed for each instance in the input array.

  For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is
  :math:`s=d_1 \cdot d_2 \cdot \cdot \cdot d_n`. We can use the parameters `preserve_shape`
  and `multi_output` to specify the way to compute softmax:

  - By default, `preserve_shape` is ``false``. This operator will reshape the input array
    into a 2-D array with shape :math:`(d_1, \frac{s}{d_1})` and then compute the softmax function for
    each row in the reshaped array, and afterwards reshape it back to the original shape
    :math:`(d_1, d_2, ..., d_n)`.
  - If `preserve_shape` is ``true``, the softmax function will be computed along
    the last axis (`axis` = ``-1``).
  - If `multi_output` is ``true``, the softmax function will be computed along
    the second axis (`axis` = ``1``).

- During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
  The provided label can be a one-hot label array or a probability label array.

  - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances
    with a particular label to be ignored during backward propagation. **This has no effect when
    softmax `output` has same shape as `label`**.

    Example::

      data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
      label = [1,0,2,3]
      ignore_label = 1
      SoftmaxOutput(data=data, label = label,\
                    multi_output=true, use_ignore=true,\
                    ignore_label=ignore_label)
      ## forward softmax output
      [[ 0.0320586   0.08714432  0.23688284  0.64391428]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]
       [ 0.25        0.25        0.25        0.25      ]]
      ## backward gradient output
      [[ 0.    0.    0.    0.  ]
       [-0.75  0.25  0.25  0.25]
       [ 0.25  0.25 -0.75  0.25]
       [ 0.25  0.25  0.25 -0.75]]
      ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.

  - The parameter `grad_scale` can be used to rescale the gradient, which is often used to
    give each loss function different weights.

  - This operator also supports various ways to normalize the gradient by `normalization`,
    The `normalization` is applied if softmax output has different shape than the labels.
    The `normalization` mode can be set to the followings:

    - ``'null'``: do nothing.
    - ``'batch'``: divide the gradient by the batch size.
    - ``'valid'``: divide the gradient by the number of instances which are not ignored.



Defined in src/operator/softmax_output.cc:L123
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SpatialTransformer" visbl="pub">
<a id="SpatialTransformer(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SpatialTransformer(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SpatialTransformer</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SpatialTransformer(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies a spatial transformer to input feature map.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies a spatial transformer to input feature map.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SpatialTransformer" visbl="pub">
<a id="SpatialTransformer(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SpatialTransformer(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SpatialTransformer</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SpatialTransformer(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies a spatial transformer to input feature map.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies a spatial transformer to input feature map.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SwapAxis" visbl="pub">
<a id="SwapAxis(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SwapAxis(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SwapAxis</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SwapAxis(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#SwapAxis" visbl="pub">
<a id="SwapAxis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="SwapAxis(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">SwapAxis</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@SwapAxis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#UpSampling" visbl="pub">
<a id="UpSampling(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="UpSampling(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">UpSampling</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@UpSampling(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs nearest neighbor/bilinear up sampling to inputs.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs nearest neighbor/bilinear up sampling to inputs.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#UpSampling" visbl="pub">
<a id="UpSampling(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="UpSampling(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">UpSampling</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@UpSampling(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs nearest neighbor/bilinear up sampling to inputs.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs nearest neighbor/bilinear up sampling to inputs.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#abs" visbl="pub">
<a id="abs(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="abs(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">abs</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@abs(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise absolute value of the input.

Example::

   abs([-2, 0, 3]) = [2, 0, 3]

The storage type of ``abs`` output depends upon the input storage type:

   - abs(default) = default
   - abs(row_sparse) = row_sparse
   - abs(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L666
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise absolute value of the input.

Example::

   abs([-2, 0, 3]) = [2, 0, 3]

The storage type of ``abs`` output depends upon the input storage type:

   - abs(default) = default
   - abs(row_sparse) = row_sparse
   - abs(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L666
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#abs" visbl="pub">
<a id="abs(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="abs(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">abs</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@abs(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise absolute value of the input.

Example::

   abs([-2, 0, 3]) = [2, 0, 3]

The storage type of ``abs`` output depends upon the input storage type:

   - abs(default) = default
   - abs(row_sparse) = row_sparse
   - abs(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L666
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise absolute value of the input.

Example::

   abs([-2, 0, 3]) = [2, 0, 3]

The storage type of ``abs`` output depends upon the input storage type:

   - abs(default) = default
   - abs(row_sparse) = row_sparse
   - abs(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L666
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#adam_update" visbl="pub">
<a id="adam_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="adam_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">adam_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@adam_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for Adam optimizer. Adam is seen as a generalization
of AdaGrad.

Adam update consists of the following steps, where g represents gradient and m, v
are 1st and 2nd order moment estimates (mean and variance).

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }

It updates the weights using::

 m = beta1*m + (1-beta1)*grad
 v = beta2*v + (1-beta2)*(grad**2)
 w += - learning_rate * m / (sqrt(v) + epsilon)

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and the storage
type of weight is the same as those of m and v,
only the row slices whose indices appear in grad.indices are updated (for w, m and v)::

 for row in grad.indices:
     m[row] = beta1*m[row] + (1-beta1)*grad[row]
     v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
     w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)



Defined in src/operator/optimizer_op.cc:L495
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for Adam optimizer. Adam is seen as a generalization
of AdaGrad.

Adam update consists of the following steps, where g represents gradient and m, v
are 1st and 2nd order moment estimates (mean and variance).

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }

It updates the weights using::

 m = beta1*m + (1-beta1)*grad
 v = beta2*v + (1-beta2)*(grad**2)
 w += - learning_rate * m / (sqrt(v) + epsilon)

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and the storage
type of weight is the same as those of m and v,
only the row slices whose indices appear in grad.indices are updated (for w, m and v)::

 for row in grad.indices:
     m[row] = beta1*m[row] + (1-beta1)*grad[row]
     v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
     w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)



Defined in src/operator/optimizer_op.cc:L495
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#adam_update" visbl="pub">
<a id="adam_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="adam_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">adam_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@adam_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for Adam optimizer. Adam is seen as a generalization
of AdaGrad.

Adam update consists of the following steps, where g represents gradient and m, v
are 1st and 2nd order moment estimates (mean and variance).

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }

It updates the weights using::

 m = beta1*m + (1-beta1)*grad
 v = beta2*v + (1-beta2)*(grad**2)
 w += - learning_rate * m / (sqrt(v) + epsilon)

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and the storage
type of weight is the same as those of m and v,
only the row slices whose indices appear in grad.indices are updated (for w, m and v)::

 for row in grad.indices:
     m[row] = beta1*m[row] + (1-beta1)*grad[row]
     v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
     w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)



Defined in src/operator/optimizer_op.cc:L495
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for Adam optimizer. Adam is seen as a generalization
of AdaGrad.

Adam update consists of the following steps, where g represents gradient and m, v
are 1st and 2nd order moment estimates (mean and variance).

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }

It updates the weights using::

 m = beta1*m + (1-beta1)*grad
 v = beta2*v + (1-beta2)*(grad**2)
 w += - learning_rate * m / (sqrt(v) + epsilon)

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and the storage
type of weight is the same as those of m and v,
only the row slices whose indices appear in grad.indices are updated (for w, m and v)::

 for row in grad.indices:
     m[row] = beta1*m[row] + (1-beta1)*grad[row]
     v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)
     w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)



Defined in src/operator/optimizer_op.cc:L495
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#add_n" visbl="pub">
<a id="add_n(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="add_n(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">add_n</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@add_n(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#add_n" visbl="pub">
<a id="add_n(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="add_n(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">add_n</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@add_n(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Adds all input arguments element-wise.

.. math::
   add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n

``add_n`` is potentially more efficient than calling ``add`` by `n` times.

The storage type of ``add_n`` output depends on storage types of inputs

- add_n(row_sparse, row_sparse, ..) = row_sparse
- add_n(default, csr, default) = default
- add_n(any input combinations longer than 4 (&gt;4) with at least one default type) = default
- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage



Defined in src/operator/tensor/elemwise_sum.cc:L156
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arccos" visbl="pub">
<a id="arccos(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arccos(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arccos</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arccos(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse cosine of the input array.

The input should be in range `[-1, 1]`.
The output is in the closed interval :math:`[0, \pi]`

.. math::
   arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]

The storage type of ``arccos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse cosine of the input array.

The input should be in range `[-1, 1]`.
The output is in the closed interval :math:`[0, \pi]`

.. math::
   arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]

The storage type of ``arccos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arccos" visbl="pub">
<a id="arccos(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arccos(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arccos</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arccos(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse cosine of the input array.

The input should be in range `[-1, 1]`.
The output is in the closed interval :math:`[0, \pi]`

.. math::
   arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]

The storage type of ``arccos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse cosine of the input array.

The input should be in range `[-1, 1]`.
The output is in the closed interval :math:`[0, \pi]`

.. math::
   arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]

The storage type of ``arccos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L123
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arccosh" visbl="pub">
<a id="arccosh(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arccosh(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arccosh</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arccosh(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the element-wise inverse hyperbolic cosine of the input array, \
computed element-wise.

The storage type of ``arccosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the element-wise inverse hyperbolic cosine of the input array, \
computed element-wise.

The storage type of ``arccosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arccosh" visbl="pub">
<a id="arccosh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arccosh(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arccosh</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arccosh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the element-wise inverse hyperbolic cosine of the input array, \
computed element-wise.

The storage type of ``arccosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the element-wise inverse hyperbolic cosine of the input array, \
computed element-wise.

The storage type of ``arccosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L264
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arcsin" visbl="pub">
<a id="arcsin(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arcsin(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arcsin</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arcsin(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse sine of the input array.

The input should be in the range `[-1, 1]`.
The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].

.. math::
   arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]

The storage type of ``arcsin`` output depends upon the input storage type:

   - arcsin(default) = default
   - arcsin(row_sparse) = row_sparse
   - arcsin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse sine of the input array.

The input should be in the range `[-1, 1]`.
The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].

.. math::
   arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]

The storage type of ``arcsin`` output depends upon the input storage type:

   - arcsin(default) = default
   - arcsin(row_sparse) = row_sparse
   - arcsin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arcsin" visbl="pub">
<a id="arcsin(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arcsin(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arcsin</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arcsin(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse sine of the input array.

The input should be in the range `[-1, 1]`.
The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].

.. math::
   arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]

The storage type of ``arcsin`` output depends upon the input storage type:

   - arcsin(default) = default
   - arcsin(row_sparse) = row_sparse
   - arcsin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse sine of the input array.

The input should be in the range `[-1, 1]`.
The output is in the closed interval of [:math:`-\pi/2`, :math:`\pi/2`].

.. math::
   arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]

The storage type of ``arcsin`` output depends upon the input storage type:

   - arcsin(default) = default
   - arcsin(row_sparse) = row_sparse
   - arcsin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L104
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arcsinh" visbl="pub">
<a id="arcsinh(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arcsinh(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arcsinh</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arcsinh(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the element-wise inverse hyperbolic sine of the input array, \
computed element-wise.

The storage type of ``arcsinh`` output depends upon the input storage type:

   - arcsinh(default) = default
   - arcsinh(row_sparse) = row_sparse
   - arcsinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the element-wise inverse hyperbolic sine of the input array, \
computed element-wise.

The storage type of ``arcsinh`` output depends upon the input storage type:

   - arcsinh(default) = default
   - arcsinh(row_sparse) = row_sparse
   - arcsinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arcsinh" visbl="pub">
<a id="arcsinh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arcsinh(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arcsinh</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arcsinh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the element-wise inverse hyperbolic sine of the input array, \
computed element-wise.

The storage type of ``arcsinh`` output depends upon the input storage type:

   - arcsinh(default) = default
   - arcsinh(row_sparse) = row_sparse
   - arcsinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the element-wise inverse hyperbolic sine of the input array, \
computed element-wise.

The storage type of ``arcsinh`` output depends upon the input storage type:

   - arcsinh(default) = default
   - arcsinh(row_sparse) = row_sparse
   - arcsinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L250
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arctan" visbl="pub">
<a id="arctan(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arctan(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arctan</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arctan(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse tangent of the input array.

The output is in the closed interval :math:`[-\pi/2, \pi/2]`

.. math::
   arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]

The storage type of ``arctan`` output depends upon the input storage type:

   - arctan(default) = default
   - arctan(row_sparse) = row_sparse
   - arctan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse tangent of the input array.

The output is in the closed interval :math:`[-\pi/2, \pi/2]`

.. math::
   arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]

The storage type of ``arctan`` output depends upon the input storage type:

   - arctan(default) = default
   - arctan(row_sparse) = row_sparse
   - arctan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arctan" visbl="pub">
<a id="arctan(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arctan(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arctan</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arctan(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse tangent of the input array.

The output is in the closed interval :math:`[-\pi/2, \pi/2]`

.. math::
   arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]

The storage type of ``arctan`` output depends upon the input storage type:

   - arctan(default) = default
   - arctan(row_sparse) = row_sparse
   - arctan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse tangent of the input array.

The output is in the closed interval :math:`[-\pi/2, \pi/2]`

.. math::
   arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]

The storage type of ``arctan`` output depends upon the input storage type:

   - arctan(default) = default
   - arctan(row_sparse) = row_sparse
   - arctan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L144
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arctanh" visbl="pub">
<a id="arctanh(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arctanh(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arctanh</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arctanh(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the element-wise inverse hyperbolic tangent of the input array, \
computed element-wise.

The storage type of ``arctanh`` output depends upon the input storage type:

   - arctanh(default) = default
   - arctanh(row_sparse) = row_sparse
   - arctanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the element-wise inverse hyperbolic tangent of the input array, \
computed element-wise.

The storage type of ``arctanh`` output depends upon the input storage type:

   - arctanh(default) = default
   - arctanh(row_sparse) = row_sparse
   - arctanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#arctanh" visbl="pub">
<a id="arctanh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="arctanh(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arctanh</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arctanh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the element-wise inverse hyperbolic tangent of the input array, \
computed element-wise.

The storage type of ``arctanh`` output depends upon the input storage type:

   - arctanh(default) = default
   - arctanh(row_sparse) = row_sparse
   - arctanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the element-wise inverse hyperbolic tangent of the input array, \
computed element-wise.

The storage type of ``arctanh`` output depends upon the input storage type:

   - arctanh(default) = default
   - arctanh(row_sparse) = row_sparse
   - arctanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L281
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argmax" visbl="pub">
<a id="argmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argmax(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argmax</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns indices of the maximum values along an axis.

In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmax along axis 0
  argmax(x, axis=0) = [ 1.,  1.,  1.]

  // argmax along axis 1
  argmax(x, axis=1) = [ 2.,  2.]

  // argmax along axis 1 keeping same dims as an input array
  argmax(x, axis=1, keepdims=True) = [[ 2.],
                                      [ 2.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns indices of the maximum values along an axis.

In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmax along axis 0
  argmax(x, axis=0) = [ 1.,  1.,  1.]

  // argmax along axis 1
  argmax(x, axis=1) = [ 2.,  2.]

  // argmax along axis 1 keeping same dims as an input array
  argmax(x, axis=1, keepdims=True) = [[ 2.],
                                      [ 2.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argmax" visbl="pub">
<a id="argmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argmax(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argmax</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns indices of the maximum values along an axis.

In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmax along axis 0
  argmax(x, axis=0) = [ 1.,  1.,  1.]

  // argmax along axis 1
  argmax(x, axis=1) = [ 2.,  2.]

  // argmax along axis 1 keeping same dims as an input array
  argmax(x, axis=1, keepdims=True) = [[ 2.],
                                      [ 2.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns indices of the maximum values along an axis.

In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmax along axis 0
  argmax(x, axis=0) = [ 1.,  1.,  1.]

  // argmax along axis 1
  argmax(x, axis=1) = [ 2.,  2.]

  // argmax along axis 1 keeping same dims as an input array
  argmax(x, axis=1, keepdims=True) = [[ 2.],
                                      [ 2.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argmax_channel" visbl="pub">
<a id="argmax_channel(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argmax_channel(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argmax_channel</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argmax_channel(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns argmax indices of each channel from the input array.

The result will be an NDArray of shape (num_channel,).

In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  argmax_channel(x) = [ 2.,  2.]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns argmax indices of each channel from the input array.

The result will be an NDArray of shape (num_channel,).

In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  argmax_channel(x) = [ 2.,  2.]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argmax_channel" visbl="pub">
<a id="argmax_channel(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argmax_channel(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argmax_channel</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argmax_channel(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns argmax indices of each channel from the input array.

The result will be an NDArray of shape (num_channel,).

In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  argmax_channel(x) = [ 2.,  2.]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns argmax indices of each channel from the input array.

The result will be an NDArray of shape (num_channel,).

In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  argmax_channel(x) = [ 2.,  2.]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argmin" visbl="pub">
<a id="argmin(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argmin(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argmin</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argmin(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns indices of the minimum values along an axis.

In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmin along axis 0
  argmin(x, axis=0) = [ 0.,  0.,  0.]

  // argmin along axis 1
  argmin(x, axis=1) = [ 0.,  0.]

  // argmin along axis 1 keeping same dims as an input array
  argmin(x, axis=1, keepdims=True) = [[ 0.],
                                      [ 0.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns indices of the minimum values along an axis.

In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmin along axis 0
  argmin(x, axis=0) = [ 0.,  0.,  0.]

  // argmin along axis 1
  argmin(x, axis=1) = [ 0.,  0.]

  // argmin along axis 1 keeping same dims as an input array
  argmin(x, axis=1, keepdims=True) = [[ 0.],
                                      [ 0.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argmin" visbl="pub">
<a id="argmin(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argmin(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argmin</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argmin(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns indices of the minimum values along an axis.

In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmin along axis 0
  argmin(x, axis=0) = [ 0.,  0.,  0.]

  // argmin along axis 1
  argmin(x, axis=1) = [ 0.,  0.]

  // argmin along axis 1 keeping same dims as an input array
  argmin(x, axis=1, keepdims=True) = [[ 0.],
                                      [ 0.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns indices of the minimum values along an axis.

In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
are returned.

Examples::

  x = [[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]]

  // argmin along axis 0
  argmin(x, axis=0) = [ 0.,  0.,  0.]

  // argmin along axis 1
  argmin(x, axis=1) = [ 0.,  0.]

  // argmin along axis 1 keeping same dims as an input array
  argmin(x, axis=1, keepdims=True) = [[ 0.],
                                      [ 0.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argsort" visbl="pub">
<a id="argsort(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argsort(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argsort</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argsort(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the indices that would sort an input array along the given axis.

This function performs sorting along the given axis and returns an array of indices having same shape
as an input array that index data in sorted order.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // sort along axis -1
  argsort(x) = [[ 1.,  0.,  2.],
                [ 0.,  2.,  1.]]

  // sort along axis 0
  argsort(x, axis=0) = [[ 1.,  0.,  1.]
                        [ 0.,  1.,  0.]]

  // flatten and then sort
  argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]


Defined in src/operator/tensor/ordering_op.cc:L176
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the indices that would sort an input array along the given axis.

This function performs sorting along the given axis and returns an array of indices having same shape
as an input array that index data in sorted order.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // sort along axis -1
  argsort(x) = [[ 1.,  0.,  2.],
                [ 0.,  2.,  1.]]

  // sort along axis 0
  argsort(x, axis=0) = [[ 1.,  0.,  1.]
                        [ 0.,  1.,  0.]]

  // flatten and then sort
  argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]


Defined in src/operator/tensor/ordering_op.cc:L176
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#argsort" visbl="pub">
<a id="argsort(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="argsort(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">argsort</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@argsort(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the indices that would sort an input array along the given axis.

This function performs sorting along the given axis and returns an array of indices having same shape
as an input array that index data in sorted order.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // sort along axis -1
  argsort(x) = [[ 1.,  0.,  2.],
                [ 0.,  2.,  1.]]

  // sort along axis 0
  argsort(x, axis=0) = [[ 1.,  0.,  1.]
                        [ 0.,  1.,  0.]]

  // flatten and then sort
  argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]


Defined in src/operator/tensor/ordering_op.cc:L176
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the indices that would sort an input array along the given axis.

This function performs sorting along the given axis and returns an array of indices having same shape
as an input array that index data in sorted order.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // sort along axis -1
  argsort(x) = [[ 1.,  0.,  2.],
                [ 0.,  2.,  1.]]

  // sort along axis 0
  argsort(x, axis=0) = [[ 1.,  0.,  1.]
                        [ 0.,  1.,  0.]]

  // flatten and then sort
  argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]


Defined in src/operator/tensor/ordering_op.cc:L176
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#batch_dot" visbl="pub">
<a id="batch_dot(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="batch_dot(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">batch_dot</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@batch_dot(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Batchwise dot product.

``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.

For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
`(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
which is computed by::

   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])



Defined in src/operator/tensor/dot.cc:L125
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Batchwise dot product.

``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.

For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
`(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
which is computed by::

   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])



Defined in src/operator/tensor/dot.cc:L125
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#batch_dot" visbl="pub">
<a id="batch_dot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="batch_dot(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">batch_dot</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@batch_dot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Batchwise dot product.

``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.

For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
`(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
which is computed by::

   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])



Defined in src/operator/tensor/dot.cc:L125
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Batchwise dot product.

``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and
``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.

For example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape
`(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,
which is computed by::

   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])



Defined in src/operator/tensor/dot.cc:L125
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#batch_take" visbl="pub">
<a id="batch_take(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="batch_take(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">batch_take</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@batch_take(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Takes elements from a data batch.

.. note::
  `batch_take` is deprecated. Use `pick` instead.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // takes elements with specified indices
  batch_take(x, [0,1,0]) = [ 1.  4.  5.]



Defined in src/operator/tensor/indexing_op.cc:L490
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Takes elements from a data batch.

.. note::
  `batch_take` is deprecated. Use `pick` instead.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // takes elements with specified indices
  batch_take(x, [0,1,0]) = [ 1.  4.  5.]



Defined in src/operator/tensor/indexing_op.cc:L490
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#batch_take" visbl="pub">
<a id="batch_take(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="batch_take(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">batch_take</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@batch_take(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Takes elements from a data batch.

.. note::
  `batch_take` is deprecated. Use `pick` instead.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // takes elements with specified indices
  batch_take(x, [0,1,0]) = [ 1.  4.  5.]



Defined in src/operator/tensor/indexing_op.cc:L490
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Takes elements from a data batch.

.. note::
  `batch_take` is deprecated. Use `pick` instead.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // takes elements with specified indices
  batch_take(x, [0,1,0]) = [ 1.  4.  5.]



Defined in src/operator/tensor/indexing_op.cc:L490
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_add" visbl="pub">
<a id="broadcast_add(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_add(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_add</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_add(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_add" visbl="pub">
<a id="broadcast_add(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_add(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_add</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_add(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_axes" visbl="pub">
<a id="broadcast_axes(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_axes(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_axes</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_axes(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_axes" visbl="pub">
<a id="broadcast_axes(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_axes(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_axes</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_axes(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_axis" visbl="pub">
<a id="broadcast_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_axis(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_axis</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_axis" visbl="pub">
<a id="broadcast_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_axis(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_axis</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts the input array over particular axes.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

Example::

   // given x of shape (1,2,1)
   x = [[[ 1.],
         [ 2.]]]

   // broadcast x on on axis 2
   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],
                                         [ 2.,  2.,  2.]]]
   // broadcast x on on axes 0 and 2
   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]],
                                                [[ 1.,  1.,  1.],
                                                 [ 2.,  2.,  2.]]]


Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L237
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_div" visbl="pub">
<a id="broadcast_div(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_div(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_div</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_div(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise division of the input arrays with broadcasting.

Example::

   x = [[ 6.,  6.,  6.],
        [ 6.,  6.,  6.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_div(x, y) = [[ 3.,  3.,  3.],
                          [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_div(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise division of the input arrays with broadcasting.

Example::

   x = [[ 6.,  6.,  6.],
        [ 6.,  6.,  6.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_div(x, y) = [[ 3.,  3.,  3.],
                          [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_div(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_div" visbl="pub">
<a id="broadcast_div(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_div(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_div</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_div(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise division of the input arrays with broadcasting.

Example::

   x = [[ 6.,  6.,  6.],
        [ 6.,  6.,  6.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_div(x, y) = [[ 3.,  3.,  3.],
                          [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_div(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise division of the input arrays with broadcasting.

Example::

   x = [[ 6.,  6.,  6.],
        [ 6.,  6.,  6.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_div(x, y) = [[ 3.,  3.,  3.],
                          [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_div(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_equal" visbl="pub">
<a id="broadcast_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_equal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_equal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_equal(x, y) = [[ 0.,  0.,  0.],
                            [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_equal(x, y) = [[ 0.,  0.,  0.],
                            [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_equal" visbl="pub">
<a id="broadcast_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_equal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_equal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_equal(x, y) = [[ 0.,  0.,  0.],
                            [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_equal(x, y) = [[ 0.,  0.,  0.],
                            [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_greater" visbl="pub">
<a id="broadcast_greater(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_greater(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_greater</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_greater(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater(x, y) = [[ 1.,  1.,  1.],
                              [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater(x, y) = [[ 1.,  1.,  1.],
                              [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_greater" visbl="pub">
<a id="broadcast_greater(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_greater(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_greater</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_greater(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater(x, y) = [[ 1.,  1.,  1.],
                              [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **greater than** (&gt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater(x, y) = [[ 1.,  1.,  1.],
                              [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_greater_equal" visbl="pub">
<a id="broadcast_greater_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_greater_equal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_greater_equal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_greater_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
                                    [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
                                    [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_greater_equal" visbl="pub">
<a id="broadcast_greater_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_greater_equal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_greater_equal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_greater_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
                                    [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **greater than or equal to** (&gt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],
                                    [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_hypot" visbl="pub">
<a id="broadcast_hypot(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_hypot(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_hypot</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_hypot(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
 Returns the hypotenuse of a right angled triangle, given its "legs"
with broadcasting.

It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.

Example::

   x = [[ 3.,  3.,  3.]]

   y = [[ 4.],
        [ 4.]]

   broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
                            [ 5.,  5.,  5.]]

   z = [[ 0.],
        [ 4.]]

   broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
                            [ 5.,  5.,  5.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
 Returns the hypotenuse of a right angled triangle, given its "legs"
with broadcasting.

It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.

Example::

   x = [[ 3.,  3.,  3.]]

   y = [[ 4.],
        [ 4.]]

   broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
                            [ 5.,  5.,  5.]]

   z = [[ 0.],
        [ 4.]]

   broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
                            [ 5.,  5.,  5.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_hypot" visbl="pub">
<a id="broadcast_hypot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_hypot(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_hypot</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_hypot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
 Returns the hypotenuse of a right angled triangle, given its "legs"
with broadcasting.

It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.

Example::

   x = [[ 3.,  3.,  3.]]

   y = [[ 4.],
        [ 4.]]

   broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
                            [ 5.,  5.,  5.]]

   z = [[ 0.],
        [ 4.]]

   broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
                            [ 5.,  5.,  5.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
 Returns the hypotenuse of a right angled triangle, given its "legs"
with broadcasting.

It is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.

Example::

   x = [[ 3.,  3.,  3.]]

   y = [[ 4.],
        [ 4.]]

   broadcast_hypot(x, y) = [[ 5.,  5.,  5.],
                            [ 5.,  5.,  5.]]

   z = [[ 0.],
        [ 4.]]

   broadcast_hypot(x, z) = [[ 3.,  3.,  3.],
                            [ 5.,  5.,  5.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_lesser" visbl="pub">
<a id="broadcast_lesser(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_lesser(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_lesser</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_lesser(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
                             [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
                             [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_lesser" visbl="pub">
<a id="broadcast_lesser(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_lesser(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_lesser</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_lesser(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
                             [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **lesser than** (&lt;) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],
                             [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_lesser_equal" visbl="pub">
<a id="broadcast_lesser_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_lesser_equal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_lesser_equal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_lesser_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
                                   [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
                                   [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_lesser_equal" visbl="pub">
<a id="broadcast_lesser_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_lesser_equal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_lesser_equal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_lesser_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
                                   [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],
                                   [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_like" visbl="pub">
<a id="broadcast_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_like(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_like</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts lhs to have the same shape as rhs.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
                                                   [ 1.,  2.,  3.]])



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L312
</https:></pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts lhs to have the same shape as rhs.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
                                                   [ 1.,  2.,  3.]])



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L312
</https:></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_like" visbl="pub">
<a id="broadcast_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_like(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_like</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts lhs to have the same shape as rhs.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
                                                   [ 1.,  2.,  3.]])



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L312
</https:></pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts lhs to have the same shape as rhs.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],
                                                   [ 1.,  2.,  3.]])



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L312
</https:></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_logical_and" visbl="pub">
<a id="broadcast_logical_and(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_logical_and(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_logical_and</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_logical_and(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **logical and** with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
                                  [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **logical and** with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
                                  [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_logical_and" visbl="pub">
<a id="broadcast_logical_and(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_logical_and(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_logical_and</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_logical_and(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **logical and** with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
                                  [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **logical and** with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],
                                  [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_logical_or" visbl="pub">
<a id="broadcast_logical_or(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_logical_or(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_logical_or</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_logical_or(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **logical or** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
                                 [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **logical or** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
                                 [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_logical_or" visbl="pub">
<a id="broadcast_logical_or(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_logical_or(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_logical_or</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_logical_or(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **logical or** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
                                 [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **logical or** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],
                                 [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_logical_xor" visbl="pub">
<a id="broadcast_logical_xor(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_logical_xor(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_logical_xor</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_logical_xor(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **logical xor** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
                                  [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **logical xor** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
                                  [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_logical_xor" visbl="pub">
<a id="broadcast_logical_xor(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_logical_xor(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_logical_xor</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_logical_xor(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **logical xor** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
                                  [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **logical xor** with broadcasting.

Example::

   x = [[ 1.,  1.,  0.],
        [ 1.,  1.,  0.]]

   y = [[ 1.],
        [ 0.]]

   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],
                                  [ 1.,  1.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_maximum" visbl="pub">
<a id="broadcast_maximum(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_maximum(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_maximum</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_maximum(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise maximum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise maxima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise maximum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise maxima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_maximum" visbl="pub">
<a id="broadcast_maximum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_maximum(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_maximum</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_maximum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise maximum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise maxima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise maximum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise maxima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_minimum" visbl="pub">
<a id="broadcast_minimum(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_minimum(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_minimum</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_minimum(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise minimum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise minima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise minimum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise minima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_minimum" visbl="pub">
<a id="broadcast_minimum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_minimum(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_minimum</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_minimum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise minimum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise minima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise minimum of the input arrays with broadcasting.

This function compares two input arrays and returns a new array having the element-wise minima.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],
                              [ 1.,  1.,  1.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_minus" visbl="pub">
<a id="broadcast_minus(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_minus(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_minus</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_minus(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_minus" visbl="pub">
<a id="broadcast_minus(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_minus(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_minus</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_minus(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_mod" visbl="pub">
<a id="broadcast_mod(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_mod(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_mod</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_mod(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise modulo of the input arrays with broadcasting.

Example::

   x = [[ 8.,  8.,  8.],
        [ 8.,  8.,  8.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_mod(x, y) = [[ 0.,  0.,  0.],
                          [ 2.,  2.,  2.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise modulo of the input arrays with broadcasting.

Example::

   x = [[ 8.,  8.,  8.],
        [ 8.,  8.,  8.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_mod(x, y) = [[ 0.,  0.,  0.],
                          [ 2.,  2.,  2.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_mod" visbl="pub">
<a id="broadcast_mod(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_mod(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_mod</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_mod(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise modulo of the input arrays with broadcasting.

Example::

   x = [[ 8.,  8.,  8.],
        [ 8.,  8.,  8.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_mod(x, y) = [[ 0.,  0.,  0.],
                          [ 2.,  2.,  2.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise modulo of the input arrays with broadcasting.

Example::

   x = [[ 8.,  8.,  8.],
        [ 8.,  8.,  8.]]

   y = [[ 2.],
        [ 3.]]

   broadcast_mod(x, y) = [[ 0.,  0.,  0.],
                          [ 2.,  2.,  2.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_mul" visbl="pub">
<a id="broadcast_mul(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_mul(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_mul</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_mul(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise product of the input arrays with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_mul(x, y) = [[ 0.,  0.,  0.],
                          [ 1.,  1.,  1.]]

Supported sparse operations:

   broadcast_mul(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise product of the input arrays with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_mul(x, y) = [[ 0.,  0.,  0.],
                          [ 1.,  1.,  1.]]

Supported sparse operations:

   broadcast_mul(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_mul" visbl="pub">
<a id="broadcast_mul(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_mul(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_mul</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_mul(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise product of the input arrays with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_mul(x, y) = [[ 0.,  0.,  0.],
                          [ 1.,  1.,  1.]]

Supported sparse operations:

   broadcast_mul(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise product of the input arrays with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_mul(x, y) = [[ 0.,  0.,  0.],
                          [ 1.,  1.,  1.]]

Supported sparse operations:

   broadcast_mul(csr, dense(1D)) = csr



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_not_equal" visbl="pub">
<a id="broadcast_not_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_not_equal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_not_equal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_not_equal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
                                [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
                                [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_not_equal" visbl="pub">
<a id="broadcast_not_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_not_equal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_not_equal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_not_equal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
                                [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],
                                [ 0.,  0.,  0.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_plus" visbl="pub">
<a id="broadcast_plus(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_plus(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_plus</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_plus(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_plus" visbl="pub">
<a id="broadcast_plus(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_plus(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_plus</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_plus(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise sum of the input arrays with broadcasting.

`broadcast_plus` is an alias to the function `broadcast_add`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_add(x, y) = [[ 1.,  1.,  1.],
                          [ 2.,  2.,  2.]]

   broadcast_plus(x, y) = [[ 1.,  1.,  1.],
                           [ 2.,  2.,  2.]]

Supported sparse operations:

   broadcast_add(csr, dense(1D)) = dense
   broadcast_add(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_power" visbl="pub">
<a id="broadcast_power(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_power(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_power</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_power(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns result of first array elements raised to powers from second array, element-wise with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_power(x, y) = [[ 2.,  2.,  2.],
                            [ 4.,  4.,  4.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns result of first array elements raised to powers from second array, element-wise with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_power(x, y) = [[ 2.,  2.,  2.],
                            [ 4.,  4.,  4.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_power" visbl="pub">
<a id="broadcast_power(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_power(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_power</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_power(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns result of first array elements raised to powers from second array, element-wise with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_power(x, y) = [[ 2.,  2.,  2.],
                            [ 4.,  4.,  4.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns result of first array elements raised to powers from second array, element-wise with broadcasting.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_power(x, y) = [[ 2.,  2.,  2.],
                            [ 4.,  4.,  4.]]



Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_sub" visbl="pub">
<a id="broadcast_sub(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_sub(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_sub</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_sub(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_sub" visbl="pub">
<a id="broadcast_sub(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_sub(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_sub</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_sub(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise difference of the input arrays with broadcasting.

`broadcast_minus` is an alias to the function `broadcast_sub`.

Example::

   x = [[ 1.,  1.,  1.],
        [ 1.,  1.,  1.]]

   y = [[ 0.],
        [ 1.]]

   broadcast_sub(x, y) = [[ 1.,  1.,  1.],
                          [ 0.,  0.,  0.]]

   broadcast_minus(x, y) = [[ 1.,  1.,  1.],
                            [ 0.,  0.,  0.]]

Supported sparse operations:

   broadcast_sub/minus(csr, dense(1D)) = dense
   broadcast_sub/minus(dense(1D), csr) = dense



Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_to" visbl="pub">
<a id="broadcast_to(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_to(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_to</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_to(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts the input array to a new shape.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
                                           [ 1.,  2.,  3.]])

The dimension which you do not want to change can also be kept as `0` which means copy the original value.
So with `shape=(2,0)`, we will obtain the same result as in the above example.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L261
</https:></pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts the input array to a new shape.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
                                           [ 1.,  2.,  3.]])

The dimension which you do not want to change can also be kept as `0` which means copy the original value.
So with `shape=(2,0)`, we will obtain the same result as in the above example.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L261
</https:></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#broadcast_to" visbl="pub">
<a id="broadcast_to(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="broadcast_to(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">broadcast_to</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@broadcast_to(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Broadcasts the input array to a new shape.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
                                           [ 1.,  2.,  3.]])

The dimension which you do not want to change can also be kept as `0` which means copy the original value.
So with `shape=(2,0)`, we will obtain the same result as in the above example.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L261
</https:></pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Broadcasts the input array to a new shape.

Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, `Broadcasting <https: basics.broadcasting.html="" doc="" docs.scipy.org="" numpy="" user="">`_ for more explanation.

Broadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to
`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.

For example::

   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],
                                           [ 1.,  2.,  3.]])

The dimension which you do not want to change can also be kept as `0` which means copy the original value.
So with `shape=(2,0)`, we will obtain the same result as in the above example.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L261
</https:></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cast" visbl="pub">
<a id="cast(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cast(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cast</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cast(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cast" visbl="pub">
<a id="cast(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cast(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cast</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cast(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Casts all elements of the input to a new type.

.. note:: ``Cast`` is deprecated. Use ``cast`` instead.

Example::

   cast([0.9, 1.3], dtype='int32') = [0, 1]
   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]
   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L592
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cast_storage" visbl="pub">
<a id="cast_storage(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cast_storage(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cast_storage</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cast_storage(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Casts tensor storage type to the new type.

When an NDArray with default storage type is cast to csr or row_sparse storage,
the result is compact, which means:

- for csr, zero values will not be retained
- for row_sparse, row slices of all zeros will not be retained

The storage type of ``cast_storage`` output depends on stype parameter:

- cast_storage(csr, 'default') = default
- cast_storage(row_sparse, 'default') = default
- cast_storage(default, 'csr') = csr
- cast_storage(default, 'row_sparse') = row_sparse
- cast_storage(csr, 'csr') = csr
- cast_storage(row_sparse, 'row_sparse') = row_sparse

Example::

    dense = [[ 0.,  1.,  0.],
             [ 2.,  0.,  3.],
             [ 0.,  0.,  0.],
             [ 0.,  0.,  0.]]

    # cast to row_sparse storage type
    rsp = cast_storage(dense, 'row_sparse')
    rsp.indices = [0, 1]
    rsp.values = [[ 0.,  1.,  0.],
                  [ 2.,  0.,  3.]]

    # cast to csr storage type
    csr = cast_storage(dense, 'csr')
    csr.indices = [1, 0, 2]
    csr.values = [ 1.,  2.,  3.]
    csr.indptr = [0, 1, 3, 3, 3]



Defined in src/operator/tensor/cast_storage.cc:L71
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Casts tensor storage type to the new type.

When an NDArray with default storage type is cast to csr or row_sparse storage,
the result is compact, which means:

- for csr, zero values will not be retained
- for row_sparse, row slices of all zeros will not be retained

The storage type of ``cast_storage`` output depends on stype parameter:

- cast_storage(csr, 'default') = default
- cast_storage(row_sparse, 'default') = default
- cast_storage(default, 'csr') = csr
- cast_storage(default, 'row_sparse') = row_sparse
- cast_storage(csr, 'csr') = csr
- cast_storage(row_sparse, 'row_sparse') = row_sparse

Example::

    dense = [[ 0.,  1.,  0.],
             [ 2.,  0.,  3.],
             [ 0.,  0.,  0.],
             [ 0.,  0.,  0.]]

    # cast to row_sparse storage type
    rsp = cast_storage(dense, 'row_sparse')
    rsp.indices = [0, 1]
    rsp.values = [[ 0.,  1.,  0.],
                  [ 2.,  0.,  3.]]

    # cast to csr storage type
    csr = cast_storage(dense, 'csr')
    csr.indices = [1, 0, 2]
    csr.values = [ 1.,  2.,  3.]
    csr.indptr = [0, 1, 3, 3, 3]



Defined in src/operator/tensor/cast_storage.cc:L71
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cast_storage" visbl="pub">
<a id="cast_storage(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cast_storage(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cast_storage</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cast_storage(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Casts tensor storage type to the new type.

When an NDArray with default storage type is cast to csr or row_sparse storage,
the result is compact, which means:

- for csr, zero values will not be retained
- for row_sparse, row slices of all zeros will not be retained

The storage type of ``cast_storage`` output depends on stype parameter:

- cast_storage(csr, 'default') = default
- cast_storage(row_sparse, 'default') = default
- cast_storage(default, 'csr') = csr
- cast_storage(default, 'row_sparse') = row_sparse
- cast_storage(csr, 'csr') = csr
- cast_storage(row_sparse, 'row_sparse') = row_sparse

Example::

    dense = [[ 0.,  1.,  0.],
             [ 2.,  0.,  3.],
             [ 0.,  0.,  0.],
             [ 0.,  0.,  0.]]

    # cast to row_sparse storage type
    rsp = cast_storage(dense, 'row_sparse')
    rsp.indices = [0, 1]
    rsp.values = [[ 0.,  1.,  0.],
                  [ 2.,  0.,  3.]]

    # cast to csr storage type
    csr = cast_storage(dense, 'csr')
    csr.indices = [1, 0, 2]
    csr.values = [ 1.,  2.,  3.]
    csr.indptr = [0, 1, 3, 3, 3]



Defined in src/operator/tensor/cast_storage.cc:L71
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Casts tensor storage type to the new type.

When an NDArray with default storage type is cast to csr or row_sparse storage,
the result is compact, which means:

- for csr, zero values will not be retained
- for row_sparse, row slices of all zeros will not be retained

The storage type of ``cast_storage`` output depends on stype parameter:

- cast_storage(csr, 'default') = default
- cast_storage(row_sparse, 'default') = default
- cast_storage(default, 'csr') = csr
- cast_storage(default, 'row_sparse') = row_sparse
- cast_storage(csr, 'csr') = csr
- cast_storage(row_sparse, 'row_sparse') = row_sparse

Example::

    dense = [[ 0.,  1.,  0.],
             [ 2.,  0.,  3.],
             [ 0.,  0.,  0.],
             [ 0.,  0.,  0.]]

    # cast to row_sparse storage type
    rsp = cast_storage(dense, 'row_sparse')
    rsp.indices = [0, 1]
    rsp.values = [[ 0.,  1.,  0.],
                  [ 2.,  0.,  3.]]

    # cast to csr storage type
    csr = cast_storage(dense, 'csr')
    csr.indices = [1, 0, 2]
    csr.values = [ 1.,  2.,  3.]
    csr.indptr = [0, 1, 3, 3, 3]



Defined in src/operator/tensor/cast_storage.cc:L71
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cbrt" visbl="pub">
<a id="cbrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cbrt(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cbrt</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cbrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise cube-root value of the input.

.. math::
   cbrt(x) = \sqrt[3]{x}

Example::

   cbrt([1, 8, -125]) = [1, 2, -5]

The storage type of ``cbrt`` output depends upon the input storage type:

   - cbrt(default) = default
   - cbrt(row_sparse) = row_sparse
   - cbrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L887
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise cube-root value of the input.

.. math::
   cbrt(x) = \sqrt[3]{x}

Example::

   cbrt([1, 8, -125]) = [1, 2, -5]

The storage type of ``cbrt`` output depends upon the input storage type:

   - cbrt(default) = default
   - cbrt(row_sparse) = row_sparse
   - cbrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L887
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cbrt" visbl="pub">
<a id="cbrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cbrt(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cbrt</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cbrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise cube-root value of the input.

.. math::
   cbrt(x) = \sqrt[3]{x}

Example::

   cbrt([1, 8, -125]) = [1, 2, -5]

The storage type of ``cbrt`` output depends upon the input storage type:

   - cbrt(default) = default
   - cbrt(row_sparse) = row_sparse
   - cbrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L887
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise cube-root value of the input.

.. math::
   cbrt(x) = \sqrt[3]{x}

Example::

   cbrt([1, 8, -125]) = [1, 2, -5]

The storage type of ``cbrt`` output depends upon the input storage type:

   - cbrt(default) = default
   - cbrt(row_sparse) = row_sparse
   - cbrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L887
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ceil" visbl="pub">
<a id="ceil(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ceil(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ceil</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ceil(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise ceiling of the input.

The ceil of the scalar x is the smallest integer i, such that i &gt;= x.

Example::

   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]

The storage type of ``ceil`` output depends upon the input storage type:

   - ceil(default) = default
   - ceil(row_sparse) = row_sparse
   - ceil(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L744
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise ceiling of the input.

The ceil of the scalar x is the smallest integer i, such that i &gt;= x.

Example::

   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]

The storage type of ``ceil`` output depends upon the input storage type:

   - ceil(default) = default
   - ceil(row_sparse) = row_sparse
   - ceil(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L744
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ceil" visbl="pub">
<a id="ceil(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ceil(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ceil</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ceil(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise ceiling of the input.

The ceil of the scalar x is the smallest integer i, such that i &gt;= x.

Example::

   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]

The storage type of ``ceil`` output depends upon the input storage type:

   - ceil(default) = default
   - ceil(row_sparse) = row_sparse
   - ceil(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L744
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise ceiling of the input.

The ceil of the scalar x is the smallest integer i, such that i &gt;= x.

Example::

   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]

The storage type of ``ceil`` output depends upon the input storage type:

   - ceil(default) = default
   - ceil(row_sparse) = row_sparse
   - ceil(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L744
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#choose_element_0index" visbl="pub">
<a id="choose_element_0index(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="choose_element_0index(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">choose_element_0index</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@choose_element_0index(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based index.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based index.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#choose_element_0index" visbl="pub">
<a id="choose_element_0index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="choose_element_0index(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">choose_element_0index</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@choose_element_0index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based index.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Choose one element from each line(row for python, column for R/Julia) in lhs according to index indicated by rhs. This function assume rhs uses 0-based index.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#clip" visbl="pub">
<a id="clip(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="clip(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">clip</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@clip(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Clips (limits) the values in an array.

Given an interval, values outside the interval are clipped to the interval edges.
Clipping ``x`` between `a_min` and `a_x` would be::

   clip(x, a_min, a_max) = max(min(x, a_max), a_min))

Example::

    x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]

The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
parameter values:

   - clip(default) = default
   - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
   - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
   - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
   - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
   - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
   - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr



Defined in src/operator/tensor/matrix_op.cc:L618
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Clips (limits) the values in an array.

Given an interval, values outside the interval are clipped to the interval edges.
Clipping ``x`` between `a_min` and `a_x` would be::

   clip(x, a_min, a_max) = max(min(x, a_max), a_min))

Example::

    x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]

The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
parameter values:

   - clip(default) = default
   - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
   - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
   - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
   - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
   - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
   - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr



Defined in src/operator/tensor/matrix_op.cc:L618
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#clip" visbl="pub">
<a id="clip(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="clip(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">clip</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@clip(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Clips (limits) the values in an array.

Given an interval, values outside the interval are clipped to the interval edges.
Clipping ``x`` between `a_min` and `a_x` would be::

   clip(x, a_min, a_max) = max(min(x, a_max), a_min))

Example::

    x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]

The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
parameter values:

   - clip(default) = default
   - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
   - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
   - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
   - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
   - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
   - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr



Defined in src/operator/tensor/matrix_op.cc:L618
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Clips (limits) the values in an array.

Given an interval, values outside the interval are clipped to the interval edges.
Clipping ``x`` between `a_min` and `a_x` would be::

   clip(x, a_min, a_max) = max(min(x, a_max), a_min))

Example::

    x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]

The storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \
parameter values:

   - clip(default) = default
   - clip(row_sparse, a_min &lt;= 0, a_max &gt;= 0) = row_sparse
   - clip(csr, a_min &lt;= 0, a_max &gt;= 0) = csr
   - clip(row_sparse, a_min &lt; 0, a_max &lt; 0) = default
   - clip(row_sparse, a_min &gt; 0, a_max &gt; 0) = default
   - clip(csr, a_min &lt; 0, a_max &lt; 0) = csr
   - clip(csr, a_min &gt; 0, a_max &gt; 0) = csr



Defined in src/operator/tensor/matrix_op.cc:L618
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#concat" visbl="pub">
<a id="concat(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="concat(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">concat</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@concat(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#concat" visbl="pub">
<a id="concat(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="concat(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">concat</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@concat(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Joins input arrays along a given axis.

.. note:: `Concat` is deprecated. Use `concat` instead.

The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.

The storage type of ``concat`` output depends on storage types of inputs

- concat(csr, csr, ..., csr, dim=0) = csr
- otherwise, ``concat`` generates output with default storage

Example::

   x = [[1,1],[2,2]]
   y = [[3,3],[4,4],[5,5]]
   z = [[6,6], [7,7],[8,8]]

   concat(x,y,z,dim=0) = [[ 1.,  1.],
                          [ 2.,  2.],
                          [ 3.,  3.],
                          [ 4.,  4.],
                          [ 5.,  5.],
                          [ 6.,  6.],
                          [ 7.,  7.],
                          [ 8.,  8.]]

   Note that you cannot concat x,y,z along dimension 1 since dimension
   0 is not the same for all the input arrays.

   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],
                         [ 4.,  4.,  7.,  7.],
                         [ 5.,  5.,  8.,  8.]]



Defined in src/operator/nn/concat.cc:L365
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cos" visbl="pub">
<a id="cos(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cos(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cos</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cos(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the element-wise cosine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]

The storage type of ``cos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the element-wise cosine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]

The storage type of ``cos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cos" visbl="pub">
<a id="cos(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cos(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cos</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cos(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the element-wise cosine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]

The storage type of ``cos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the element-wise cosine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]

The storage type of ``cos`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L63
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cosh" visbl="pub">
<a id="cosh(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cosh(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cosh</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cosh(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the hyperbolic cosine  of the input array, computed element-wise.

.. math::
   cosh(x) = 0.5\times(exp(x) + exp(-x))

The storage type of ``cosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the hyperbolic cosine  of the input array, computed element-wise.

.. math::
   cosh(x) = 0.5\times(exp(x) + exp(-x))

The storage type of ``cosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#cosh" visbl="pub">
<a id="cosh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="cosh(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">cosh</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@cosh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the hyperbolic cosine  of the input array, computed element-wise.

.. math::
   cosh(x) = 0.5\times(exp(x) + exp(-x))

The storage type of ``cosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the hyperbolic cosine  of the input array, computed element-wise.

.. math::
   cosh(x) = 0.5\times(exp(x) + exp(-x))

The storage type of ``cosh`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L216
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#crop" visbl="pub">
<a id="crop(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="crop(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">crop</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@crop(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#crop" visbl="pub">
<a id="crop(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="crop(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">crop</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@crop(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#degrees" visbl="pub">
<a id="degrees(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="degrees(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">degrees</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@degrees(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts each element of the input array from radians to degrees.

.. math::
   degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]

The storage type of ``degrees`` output depends upon the input storage type:

   - degrees(default) = default
   - degrees(row_sparse) = row_sparse
   - degrees(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts each element of the input array from radians to degrees.

.. math::
   degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]

The storage type of ``degrees`` output depends upon the input storage type:

   - degrees(default) = default
   - degrees(row_sparse) = row_sparse
   - degrees(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#degrees" visbl="pub">
<a id="degrees(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="degrees(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">degrees</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@degrees(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts each element of the input array from radians to degrees.

.. math::
   degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]

The storage type of ``degrees`` output depends upon the input storage type:

   - degrees(default) = default
   - degrees(row_sparse) = row_sparse
   - degrees(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts each element of the input array from radians to degrees.

.. math::
   degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]

The storage type of ``degrees`` output depends upon the input storage type:

   - degrees(default) = default
   - degrees(row_sparse) = row_sparse
   - degrees(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L163
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#depth_to_space" visbl="pub">
<a id="depth_to_space(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="depth_to_space(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">depth_to_space</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@depth_to_space(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Rearranges(permutes) data from depth into blocks of spatial data.
Similar to ONNX DepthToSpace operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
The output is a new tensor where the values from depth dimension are moved in spatial blocks
to height and width dimension. The reverse of this operation is ``space_to_depth``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`

Example::

  x = [[[[0, 1, 2],
         [3, 4, 5]],
        [[6, 7, 8],
         [9, 10, 11]],
        [[12, 13, 14],
         [15, 16, 17]],
        [[18, 19, 20],
         [21, 22, 23]]]]

  depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
                            [12, 18, 13, 19, 14, 20],
                            [3, 9, 4, 10, 5, 11],
                            [15, 21, 16, 22, 17, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L945
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Rearranges(permutes) data from depth into blocks of spatial data.
Similar to ONNX DepthToSpace operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
The output is a new tensor where the values from depth dimension are moved in spatial blocks
to height and width dimension. The reverse of this operation is ``space_to_depth``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`

Example::

  x = [[[[0, 1, 2],
         [3, 4, 5]],
        [[6, 7, 8],
         [9, 10, 11]],
        [[12, 13, 14],
         [15, 16, 17]],
        [[18, 19, 20],
         [21, 22, 23]]]]

  depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
                            [12, 18, 13, 19, 14, 20],
                            [3, 9, 4, 10, 5, 11],
                            [15, 21, 16, 22, 17, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L945
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#depth_to_space" visbl="pub">
<a id="depth_to_space(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="depth_to_space(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">depth_to_space</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@depth_to_space(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Rearranges(permutes) data from depth into blocks of spatial data.
Similar to ONNX DepthToSpace operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
The output is a new tensor where the values from depth dimension are moved in spatial blocks
to height and width dimension. The reverse of this operation is ``space_to_depth``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`

Example::

  x = [[[[0, 1, 2],
         [3, 4, 5]],
        [[6, 7, 8],
         [9, 10, 11]],
        [[12, 13, 14],
         [15, 16, 17]],
        [[18, 19, 20],
         [21, 22, 23]]]]

  depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
                            [12, 18, 13, 19, 14, 20],
                            [3, 9, 4, 10, 5, 11],
                            [15, 21, 16, 22, 17, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L945
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Rearranges(permutes) data from depth into blocks of spatial data.
Similar to ONNX DepthToSpace operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.
The output is a new tensor where the values from depth dimension are moved in spatial blocks
to height and width dimension. The reverse of this operation is ``space_to_depth``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
    y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C / (block\_size ^ 2), H * block\_size, W * block\_size]`

Example::

  x = [[[[0, 1, 2],
         [3, 4, 5]],
        [[6, 7, 8],
         [9, 10, 11]],
        [[12, 13, 14],
         [15, 16, 17]],
        [[18, 19, 20],
         [21, 22, 23]]]]

  depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],
                            [12, 18, 13, 19, 14, 20],
                            [3, 9, 4, 10, 5, 11],
                            [15, 21, 16, 22, 17, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L945
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#diag" visbl="pub">
<a id="diag(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="diag(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">diag</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@diag(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Extracts a diagonal or constructs a diagonal array.

``diag``'s behavior depends on the input array dimensions:

- 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero
- 2-D arrays: returns elements in the diagonal as a new 1-D array
- N-D arrays: not supported yet

Examples::

  x = [[1, 2, 3],
       [4, 5, 6]]

  diag(x) = [1, 5]

  diag(x, k=1) = [2, 6]

  diag(x, k=-1) = [4]

  x = [1, 2, 3]

  diag(x) = [[1, 0, 0],
             [0, 2, 0],
             [0, 0, 3]]

  diag(x, k=1) = [[0, 1, 0],
                  [0, 0, 2],
                  [0, 0, 0]]

  diag(x, k=-1) = [[0, 0, 0],
                   [1, 0, 0],
                   [0, 2, 0]]



Defined in src/operator/tensor/diag_op.cc:L68
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Extracts a diagonal or constructs a diagonal array.

``diag``'s behavior depends on the input array dimensions:

- 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero
- 2-D arrays: returns elements in the diagonal as a new 1-D array
- N-D arrays: not supported yet

Examples::

  x = [[1, 2, 3],
       [4, 5, 6]]

  diag(x) = [1, 5]

  diag(x, k=1) = [2, 6]

  diag(x, k=-1) = [4]

  x = [1, 2, 3]

  diag(x) = [[1, 0, 0],
             [0, 2, 0],
             [0, 0, 3]]

  diag(x, k=1) = [[0, 1, 0],
                  [0, 0, 2],
                  [0, 0, 0]]

  diag(x, k=-1) = [[0, 0, 0],
                   [1, 0, 0],
                   [0, 2, 0]]



Defined in src/operator/tensor/diag_op.cc:L68
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#diag" visbl="pub">
<a id="diag(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="diag(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">diag</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@diag(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Extracts a diagonal or constructs a diagonal array.

``diag``'s behavior depends on the input array dimensions:

- 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero
- 2-D arrays: returns elements in the diagonal as a new 1-D array
- N-D arrays: not supported yet

Examples::

  x = [[1, 2, 3],
       [4, 5, 6]]

  diag(x) = [1, 5]

  diag(x, k=1) = [2, 6]

  diag(x, k=-1) = [4]

  x = [1, 2, 3]

  diag(x) = [[1, 0, 0],
             [0, 2, 0],
             [0, 0, 3]]

  diag(x, k=1) = [[0, 1, 0],
                  [0, 0, 2],
                  [0, 0, 0]]

  diag(x, k=-1) = [[0, 0, 0],
                   [1, 0, 0],
                   [0, 2, 0]]



Defined in src/operator/tensor/diag_op.cc:L68
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Extracts a diagonal or constructs a diagonal array.

``diag``'s behavior depends on the input array dimensions:

- 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero
- 2-D arrays: returns elements in the diagonal as a new 1-D array
- N-D arrays: not supported yet

Examples::

  x = [[1, 2, 3],
       [4, 5, 6]]

  diag(x) = [1, 5]

  diag(x, k=1) = [2, 6]

  diag(x, k=-1) = [4]

  x = [1, 2, 3]

  diag(x) = [[1, 0, 0],
             [0, 2, 0],
             [0, 0, 3]]

  diag(x, k=1) = [[0, 1, 0],
                  [0, 0, 2],
                  [0, 0, 0]]

  diag(x, k=-1) = [[0, 0, 0],
                   [1, 0, 0],
                   [0, 2, 0]]



Defined in src/operator/tensor/diag_op.cc:L68
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#dot" visbl="pub">
<a id="dot(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="dot(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">dot</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@dot(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Dot product of two arrays.

``dot``'s behavior depends on the input array dimensions:

- 1-D arrays: inner product of vectors
- 2-D arrays: matrix multiplication
- N-D arrays: a sum product over the last axis of the first input and the first
  axis of the second input

  For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
  result array will have shape `(n,m,r,s)`. It is computed by::

    dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])

  Example::

    x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    dot(x,y)[0,0,1,1] = 0
    sum(x[0,0,:]*y[:,1,1]) = 0

The storage type of ``dot`` output depends on storage types of inputs, transpose option and
forward_stype option for output storage type. Implemented sparse operations include:

- dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
- dot(csr, default, transpose_a=True) = default
- dot(csr, default, transpose_a=True) = row_sparse
- dot(csr, default) = default
- dot(csr, row_sparse) = default
- dot(default, csr) = csr (CPU only)
- dot(default, csr, forward_stype='default') = default
- dot(default, csr, transpose_b=True, forward_stype='default') = default

If the combination of input storage types and forward_stype does not match any of the
above patterns, ``dot`` will fallback and generate output with default storage.

.. Note::

    If the storage type of the lhs is "csr", the storage type of gradient w.r.t rhs will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/dot.cc:L77
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Dot product of two arrays.

``dot``'s behavior depends on the input array dimensions:

- 1-D arrays: inner product of vectors
- 2-D arrays: matrix multiplication
- N-D arrays: a sum product over the last axis of the first input and the first
  axis of the second input

  For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
  result array will have shape `(n,m,r,s)`. It is computed by::

    dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])

  Example::

    x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    dot(x,y)[0,0,1,1] = 0
    sum(x[0,0,:]*y[:,1,1]) = 0

The storage type of ``dot`` output depends on storage types of inputs, transpose option and
forward_stype option for output storage type. Implemented sparse operations include:

- dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
- dot(csr, default, transpose_a=True) = default
- dot(csr, default, transpose_a=True) = row_sparse
- dot(csr, default) = default
- dot(csr, row_sparse) = default
- dot(default, csr) = csr (CPU only)
- dot(default, csr, forward_stype='default') = default
- dot(default, csr, transpose_b=True, forward_stype='default') = default

If the combination of input storage types and forward_stype does not match any of the
above patterns, ``dot`` will fallback and generate output with default storage.

.. Note::

    If the storage type of the lhs is "csr", the storage type of gradient w.r.t rhs will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/dot.cc:L77
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#dot" visbl="pub">
<a id="dot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="dot(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">dot</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@dot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Dot product of two arrays.

``dot``'s behavior depends on the input array dimensions:

- 1-D arrays: inner product of vectors
- 2-D arrays: matrix multiplication
- N-D arrays: a sum product over the last axis of the first input and the first
  axis of the second input

  For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
  result array will have shape `(n,m,r,s)`. It is computed by::

    dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])

  Example::

    x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    dot(x,y)[0,0,1,1] = 0
    sum(x[0,0,:]*y[:,1,1]) = 0

The storage type of ``dot`` output depends on storage types of inputs, transpose option and
forward_stype option for output storage type. Implemented sparse operations include:

- dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
- dot(csr, default, transpose_a=True) = default
- dot(csr, default, transpose_a=True) = row_sparse
- dot(csr, default) = default
- dot(csr, row_sparse) = default
- dot(default, csr) = csr (CPU only)
- dot(default, csr, forward_stype='default') = default
- dot(default, csr, transpose_b=True, forward_stype='default') = default

If the combination of input storage types and forward_stype does not match any of the
above patterns, ``dot`` will fallback and generate output with default storage.

.. Note::

    If the storage type of the lhs is "csr", the storage type of gradient w.r.t rhs will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/dot.cc:L77
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Dot product of two arrays.

``dot``'s behavior depends on the input array dimensions:

- 1-D arrays: inner product of vectors
- 2-D arrays: matrix multiplication
- N-D arrays: a sum product over the last axis of the first input and the first
  axis of the second input

  For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the
  result array will have shape `(n,m,r,s)`. It is computed by::

    dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])

  Example::

    x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))
    y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))
    dot(x,y)[0,0,1,1] = 0
    sum(x[0,0,:]*y[:,1,1]) = 0

The storage type of ``dot`` output depends on storage types of inputs, transpose option and
forward_stype option for output storage type. Implemented sparse operations include:

- dot(default, default, transpose_a=True/False, transpose_b=True/False) = default
- dot(csr, default, transpose_a=True) = default
- dot(csr, default, transpose_a=True) = row_sparse
- dot(csr, default) = default
- dot(csr, row_sparse) = default
- dot(default, csr) = csr (CPU only)
- dot(default, csr, forward_stype='default') = default
- dot(default, csr, transpose_b=True, forward_stype='default') = default

If the combination of input storage types and forward_stype does not match any of the
above patterns, ``dot`` will fallback and generate output with default storage.

.. Note::

    If the storage type of the lhs is "csr", the storage type of gradient w.r.t rhs will be
    "row_sparse". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
    and Adam. Note that by default lazy updates is turned on, which may perform differently
    from standard updates. For more details, please check the Optimization API at:
    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html



Defined in src/operator/tensor/dot.cc:L77
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_add" visbl="pub">
<a id="elemwise_add(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_add(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_add</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_add(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Adds arguments element-wise.

The storage type of ``elemwise_add`` output depends on storage types of inputs

   - elemwise_add(row_sparse, row_sparse) = row_sparse
   - elemwise_add(csr, csr) = csr
   - elemwise_add(default, csr) = default
   - elemwise_add(csr, default) = default
   - elemwise_add(default, rsp) = default
   - elemwise_add(rsp, default) = default
   - otherwise, ``elemwise_add`` generates output with default storage
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Adds arguments element-wise.

The storage type of ``elemwise_add`` output depends on storage types of inputs

   - elemwise_add(row_sparse, row_sparse) = row_sparse
   - elemwise_add(csr, csr) = csr
   - elemwise_add(default, csr) = default
   - elemwise_add(csr, default) = default
   - elemwise_add(default, rsp) = default
   - elemwise_add(rsp, default) = default
   - otherwise, ``elemwise_add`` generates output with default storage
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_add" visbl="pub">
<a id="elemwise_add(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_add(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_add</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_add(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Adds arguments element-wise.

The storage type of ``elemwise_add`` output depends on storage types of inputs

   - elemwise_add(row_sparse, row_sparse) = row_sparse
   - elemwise_add(csr, csr) = csr
   - elemwise_add(default, csr) = default
   - elemwise_add(csr, default) = default
   - elemwise_add(default, rsp) = default
   - elemwise_add(rsp, default) = default
   - otherwise, ``elemwise_add`` generates output with default storage
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Adds arguments element-wise.

The storage type of ``elemwise_add`` output depends on storage types of inputs

   - elemwise_add(row_sparse, row_sparse) = row_sparse
   - elemwise_add(csr, csr) = csr
   - elemwise_add(default, csr) = default
   - elemwise_add(csr, default) = default
   - elemwise_add(default, rsp) = default
   - elemwise_add(rsp, default) = default
   - otherwise, ``elemwise_add`` generates output with default storage
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_div" visbl="pub">
<a id="elemwise_div(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_div(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_div</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_div(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Divides arguments element-wise.

The storage type of ``elemwise_div`` output is always dense
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Divides arguments element-wise.

The storage type of ``elemwise_div`` output is always dense
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_div" visbl="pub">
<a id="elemwise_div(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_div(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_div</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_div(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Divides arguments element-wise.

The storage type of ``elemwise_div`` output is always dense
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Divides arguments element-wise.

The storage type of ``elemwise_div`` output is always dense
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_mul" visbl="pub">
<a id="elemwise_mul(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_mul(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_mul</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_mul(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Multiplies arguments element-wise.

The storage type of ``elemwise_mul`` output depends on storage types of inputs

   - elemwise_mul(default, default) = default
   - elemwise_mul(row_sparse, row_sparse) = row_sparse
   - elemwise_mul(default, row_sparse) = row_sparse
   - elemwise_mul(row_sparse, default) = row_sparse
   - elemwise_mul(csr, csr) = csr
   - otherwise, ``elemwise_mul`` generates output with default storage
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Multiplies arguments element-wise.

The storage type of ``elemwise_mul`` output depends on storage types of inputs

   - elemwise_mul(default, default) = default
   - elemwise_mul(row_sparse, row_sparse) = row_sparse
   - elemwise_mul(default, row_sparse) = row_sparse
   - elemwise_mul(row_sparse, default) = row_sparse
   - elemwise_mul(csr, csr) = csr
   - otherwise, ``elemwise_mul`` generates output with default storage
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_mul" visbl="pub">
<a id="elemwise_mul(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_mul(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_mul</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_mul(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Multiplies arguments element-wise.

The storage type of ``elemwise_mul`` output depends on storage types of inputs

   - elemwise_mul(default, default) = default
   - elemwise_mul(row_sparse, row_sparse) = row_sparse
   - elemwise_mul(default, row_sparse) = row_sparse
   - elemwise_mul(row_sparse, default) = row_sparse
   - elemwise_mul(csr, csr) = csr
   - otherwise, ``elemwise_mul`` generates output with default storage
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Multiplies arguments element-wise.

The storage type of ``elemwise_mul`` output depends on storage types of inputs

   - elemwise_mul(default, default) = default
   - elemwise_mul(row_sparse, row_sparse) = row_sparse
   - elemwise_mul(default, row_sparse) = row_sparse
   - elemwise_mul(row_sparse, default) = row_sparse
   - elemwise_mul(csr, csr) = csr
   - otherwise, ``elemwise_mul`` generates output with default storage
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_sub" visbl="pub">
<a id="elemwise_sub(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_sub(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_sub</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_sub(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Subtracts arguments element-wise.

The storage type of ``elemwise_sub`` output depends on storage types of inputs

   - elemwise_sub(row_sparse, row_sparse) = row_sparse
   - elemwise_sub(csr, csr) = csr
   - elemwise_sub(default, csr) = default
   - elemwise_sub(csr, default) = default
   - elemwise_sub(default, rsp) = default
   - elemwise_sub(rsp, default) = default
   - otherwise, ``elemwise_sub`` generates output with default storage
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Subtracts arguments element-wise.

The storage type of ``elemwise_sub`` output depends on storage types of inputs

   - elemwise_sub(row_sparse, row_sparse) = row_sparse
   - elemwise_sub(csr, csr) = csr
   - elemwise_sub(default, csr) = default
   - elemwise_sub(csr, default) = default
   - elemwise_sub(default, rsp) = default
   - elemwise_sub(rsp, default) = default
   - otherwise, ``elemwise_sub`` generates output with default storage
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#elemwise_sub" visbl="pub">
<a id="elemwise_sub(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="elemwise_sub(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">elemwise_sub</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@elemwise_sub(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Subtracts arguments element-wise.

The storage type of ``elemwise_sub`` output depends on storage types of inputs

   - elemwise_sub(row_sparse, row_sparse) = row_sparse
   - elemwise_sub(csr, csr) = csr
   - elemwise_sub(default, csr) = default
   - elemwise_sub(csr, default) = default
   - elemwise_sub(default, rsp) = default
   - elemwise_sub(rsp, default) = default
   - otherwise, ``elemwise_sub`` generates output with default storage
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Subtracts arguments element-wise.

The storage type of ``elemwise_sub`` output depends on storage types of inputs

   - elemwise_sub(row_sparse, row_sparse) = row_sparse
   - elemwise_sub(csr, csr) = csr
   - elemwise_sub(default, csr) = default
   - elemwise_sub(csr, default) = default
   - elemwise_sub(default, rsp) = default
   - elemwise_sub(rsp, default) = default
   - otherwise, ``elemwise_sub`` generates output with default storage
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#exp" visbl="pub">
<a id="exp(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="exp(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">exp</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@exp(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise exponential value of the input.

.. math::
   exp(x) = e^x \approx 2.718^x

Example::

   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]

The storage type of ``exp`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L927
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise exponential value of the input.

.. math::
   exp(x) = e^x \approx 2.718^x

Example::

   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]

The storage type of ``exp`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L927
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#exp" visbl="pub">
<a id="exp(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="exp(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">exp</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@exp(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise exponential value of the input.

.. math::
   exp(x) = e^x \approx 2.718^x

Example::

   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]

The storage type of ``exp`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L927
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise exponential value of the input.

.. math::
   exp(x) = e^x \approx 2.718^x

Example::

   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]

The storage type of ``exp`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L927
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#expand_dims" visbl="pub">
<a id="expand_dims(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="expand_dims(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">expand_dims</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@expand_dims(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Inserts a new axis of size 1 into the array shape

For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
will return a new array with shape ``(2,1,3,4)``.



Defined in src/operator/tensor/matrix_op.cc:L347
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Inserts a new axis of size 1 into the array shape

For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
will return a new array with shape ``(2,1,3,4)``.



Defined in src/operator/tensor/matrix_op.cc:L347
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#expand_dims" visbl="pub">
<a id="expand_dims(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="expand_dims(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">expand_dims</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@expand_dims(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Inserts a new axis of size 1 into the array shape

For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
will return a new array with shape ``(2,1,3,4)``.



Defined in src/operator/tensor/matrix_op.cc:L347
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Inserts a new axis of size 1 into the array shape

For example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``
will return a new array with shape ``(2,1,3,4)``.



Defined in src/operator/tensor/matrix_op.cc:L347
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#expm1" visbl="pub">
<a id="expm1(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="expm1(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">expm1</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@expm1(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns ``exp(x) - 1`` computed element-wise on the input.

This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.

The storage type of ``expm1`` output depends upon the input storage type:

   - expm1(default) = default
   - expm1(row_sparse) = row_sparse
   - expm1(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1006
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns ``exp(x) - 1`` computed element-wise on the input.

This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.

The storage type of ``expm1`` output depends upon the input storage type:

   - expm1(default) = default
   - expm1(row_sparse) = row_sparse
   - expm1(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1006
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#expm1" visbl="pub">
<a id="expm1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="expm1(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">expm1</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@expm1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns ``exp(x) - 1`` computed element-wise on the input.

This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.

The storage type of ``expm1`` output depends upon the input storage type:

   - expm1(default) = default
   - expm1(row_sparse) = row_sparse
   - expm1(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1006
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns ``exp(x) - 1`` computed element-wise on the input.

This function provides greater precision than ``exp(x) - 1`` for small values of ``x``.

The storage type of ``expm1`` output depends upon the input storage type:

   - expm1(default) = default
   - expm1(row_sparse) = row_sparse
   - expm1(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1006
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#fill_element_0index" visbl="pub">
<a id="fill_element_0index(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="fill_element_0index(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">fill_element_0index</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@fill_element_0index(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#fill_element_0index" visbl="pub">
<a id="fill_element_0index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="fill_element_0index(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">fill_element_0index</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@fill_element_0index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#fix" visbl="pub">
<a id="fix(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="fix(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">fix</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@fix(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise rounded value to the nearest \
integer towards zero of the input.

Example::

   fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]

The storage type of ``fix`` output depends upon the input storage type:

   - fix(default) = default
   - fix(row_sparse) = row_sparse
   - fix(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L801
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise rounded value to the nearest \
integer towards zero of the input.

Example::

   fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]

The storage type of ``fix`` output depends upon the input storage type:

   - fix(default) = default
   - fix(row_sparse) = row_sparse
   - fix(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L801
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#fix" visbl="pub">
<a id="fix(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="fix(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">fix</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@fix(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise rounded value to the nearest \
integer towards zero of the input.

Example::

   fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]

The storage type of ``fix`` output depends upon the input storage type:

   - fix(default) = default
   - fix(row_sparse) = row_sparse
   - fix(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L801
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise rounded value to the nearest \
integer towards zero of the input.

Example::

   fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]

The storage type of ``fix`` output depends upon the input storage type:

   - fix(default) = default
   - fix(row_sparse) = row_sparse
   - fix(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L801
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#flatten" visbl="pub">
<a id="flatten(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="flatten(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">flatten</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@flatten(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#flatten" visbl="pub">
<a id="flatten(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="flatten(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">flatten</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@flatten(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Flattens the input array into a 2-D array by collapsing the higher dimensions.

.. note:: `Flatten` is deprecated. Use `flatten` instead.

For an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes
the input array into an output array of shape ``(d1, d2*...*dk)``.

Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).

Example::

    x = [[
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    [    [1,2,3],
        [4,5,6],
        [7,8,9]
    ]],

    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]



Defined in src/operator/tensor/matrix_op.cc:L259
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#flip" visbl="pub">
<a id="flip(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="flip(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">flip</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@flip(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#flip" visbl="pub">
<a id="flip(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="flip(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">flip</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@flip(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#floor" visbl="pub">
<a id="floor(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="floor(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">floor</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@floor(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise floor of the input.

The floor of the scalar x is the largest integer i, such that i &lt;= x.

Example::

   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]

The storage type of ``floor`` output depends upon the input storage type:

   - floor(default) = default
   - floor(row_sparse) = row_sparse
   - floor(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L763
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise floor of the input.

The floor of the scalar x is the largest integer i, such that i &lt;= x.

Example::

   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]

The storage type of ``floor`` output depends upon the input storage type:

   - floor(default) = default
   - floor(row_sparse) = row_sparse
   - floor(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L763
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#floor" visbl="pub">
<a id="floor(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="floor(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">floor</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@floor(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise floor of the input.

The floor of the scalar x is the largest integer i, such that i &lt;= x.

Example::

   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]

The storage type of ``floor`` output depends upon the input storage type:

   - floor(default) = default
   - floor(row_sparse) = row_sparse
   - floor(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L763
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise floor of the input.

The floor of the scalar x is the largest integer i, such that i &lt;= x.

Example::

   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]

The storage type of ``floor`` output depends upon the input storage type:

   - floor(default) = default
   - floor(row_sparse) = row_sparse
   - floor(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L763
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ftml_update" visbl="pub">
<a id="ftml_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ftml_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ftml_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ftml_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
The FTML optimizer described in
*FTML - Follow the Moving Leader in Deep Learning*,
available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.

.. math::

 g_t = \nabla J(W_{t-1})\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
 \sigma_t = d_t - \beta_1 d_{t-1}
 z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
 W_t = - \frac{ z_t }{ d_t }



Defined in src/operator/optimizer_op.cc:L447
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
The FTML optimizer described in
*FTML - Follow the Moving Leader in Deep Learning*,
available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.

.. math::

 g_t = \nabla J(W_{t-1})\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
 \sigma_t = d_t - \beta_1 d_{t-1}
 z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
 W_t = - \frac{ z_t }{ d_t }



Defined in src/operator/optimizer_op.cc:L447
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ftml_update" visbl="pub">
<a id="ftml_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ftml_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ftml_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ftml_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
The FTML optimizer described in
*FTML - Follow the Moving Leader in Deep Learning*,
available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.

.. math::

 g_t = \nabla J(W_{t-1})\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
 \sigma_t = d_t - \beta_1 d_{t-1}
 z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
 W_t = - \frac{ z_t }{ d_t }



Defined in src/operator/optimizer_op.cc:L447
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
The FTML optimizer described in
*FTML - Follow the Moving Leader in Deep Learning*,
available at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.

.. math::

 g_t = \nabla J(W_{t-1})\\
 v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
 d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
 \sigma_t = d_t - \beta_1 d_{t-1}
 z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
 W_t = - \frac{ z_t }{ d_t }



Defined in src/operator/optimizer_op.cc:L447
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ftrl_update" visbl="pub">
<a id="ftrl_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ftrl_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ftrl_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ftrl_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for Ftrl optimizer.
Referenced from *Ad Click Prediction: a View from the Trenches*, available at
http://dl.acm.org/citation.cfm?id=2488200.

It updates the weights using::

 rescaled_grad = clip(grad * rescale_grad, clip_gradient)
 z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
 n += rescaled_grad**2
 w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)

If w, z and n are all of ``row_sparse`` storage type,
only the row slices whose indices appear in grad.indices are updated (for w, z and n)::

 for row in grad.indices:
     rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
     z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
     n[row] += rescaled_grad[row]**2
     w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)



Defined in src/operator/optimizer_op.cc:L632
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for Ftrl optimizer.
Referenced from *Ad Click Prediction: a View from the Trenches*, available at
http://dl.acm.org/citation.cfm?id=2488200.

It updates the weights using::

 rescaled_grad = clip(grad * rescale_grad, clip_gradient)
 z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
 n += rescaled_grad**2
 w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)

If w, z and n are all of ``row_sparse`` storage type,
only the row slices whose indices appear in grad.indices are updated (for w, z and n)::

 for row in grad.indices:
     rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
     z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
     n[row] += rescaled_grad[row]**2
     w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)



Defined in src/operator/optimizer_op.cc:L632
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ftrl_update" visbl="pub">
<a id="ftrl_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ftrl_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ftrl_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ftrl_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for Ftrl optimizer.
Referenced from *Ad Click Prediction: a View from the Trenches*, available at
http://dl.acm.org/citation.cfm?id=2488200.

It updates the weights using::

 rescaled_grad = clip(grad * rescale_grad, clip_gradient)
 z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
 n += rescaled_grad**2
 w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)

If w, z and n are all of ``row_sparse`` storage type,
only the row slices whose indices appear in grad.indices are updated (for w, z and n)::

 for row in grad.indices:
     rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
     z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
     n[row] += rescaled_grad[row]**2
     w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)



Defined in src/operator/optimizer_op.cc:L632
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for Ftrl optimizer.
Referenced from *Ad Click Prediction: a View from the Trenches*, available at
http://dl.acm.org/citation.cfm?id=2488200.

It updates the weights using::

 rescaled_grad = clip(grad * rescale_grad, clip_gradient)
 z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate
 n += rescaled_grad**2
 w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) &gt; lamda1)

If w, z and n are all of ``row_sparse`` storage type,
only the row slices whose indices appear in grad.indices are updated (for w, z and n)::

 for row in grad.indices:
     rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)
     z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate
     n[row] += rescaled_grad[row]**2
     w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) &gt; lamda1)



Defined in src/operator/optimizer_op.cc:L632
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#gamma" visbl="pub">
<a id="gamma(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="gamma(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">gamma</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@gamma(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the gamma function (extension of the factorial function \
to the reals), computed element-wise on the input array.

The storage type of ``gamma`` output is always dense
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the gamma function (extension of the factorial function \
to the reals), computed element-wise on the input array.

The storage type of ``gamma`` output is always dense
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#gamma" visbl="pub">
<a id="gamma(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="gamma(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">gamma</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@gamma(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the gamma function (extension of the factorial function \
to the reals), computed element-wise on the input array.

The storage type of ``gamma`` output is always dense
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the gamma function (extension of the factorial function \
to the reals), computed element-wise on the input array.

The storage type of ``gamma`` output is always dense
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#gammaln" visbl="pub">
<a id="gammaln(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="gammaln(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">gammaln</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@gammaln(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise log of the absolute value of the gamma function \
of the input.

The storage type of ``gammaln`` output is always dense
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise log of the absolute value of the gamma function \
of the input.

The storage type of ``gammaln`` output is always dense
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#gammaln" visbl="pub">
<a id="gammaln(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="gammaln(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">gammaln</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@gammaln(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise log of the absolute value of the gamma function \
of the input.

The storage type of ``gammaln`` output is always dense
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise log of the absolute value of the gamma function \
of the input.

The storage type of ``gammaln`` output is always dense
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#gather_nd" visbl="pub">
<a id="gather_nd(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="gather_nd(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">gather_nd</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@gather_nd(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Gather elements or slices from `data` and store to a tensor whose
shape is defined by `indices`.

Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
                                                      ...,
                                                      indices[M-1, y_0, ..., y_{K-1}],
                                                      x_M, ..., x_{N-1}]

Examples::

  data = [[0, 1], [2, 3]]
  indices = [[1, 1, 0], [0, 1, 0]]
  gather_nd(data, indices) = [2, 3, 0]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 0]]
  gather_nd(data, indices) = [[3, 4], [5, 6]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Gather elements or slices from `data` and store to a tensor whose
shape is defined by `indices`.

Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
                                                      ...,
                                                      indices[M-1, y_0, ..., y_{K-1}],
                                                      x_M, ..., x_{N-1}]

Examples::

  data = [[0, 1], [2, 3]]
  indices = [[1, 1, 0], [0, 1, 0]]
  gather_nd(data, indices) = [2, 3, 0]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 0]]
  gather_nd(data, indices) = [[3, 4], [5, 6]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#gather_nd" visbl="pub">
<a id="gather_nd(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="gather_nd(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">gather_nd</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@gather_nd(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Gather elements or slices from `data` and store to a tensor whose
shape is defined by `indices`.

Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
                                                      ...,
                                                      indices[M-1, y_0, ..., y_{K-1}],
                                                      x_M, ..., x_{N-1}]

Examples::

  data = [[0, 1], [2, 3]]
  indices = [[1, 1, 0], [0, 1, 0]]
  gather_nd(data, indices) = [2, 3, 0]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 0]]
  gather_nd(data, indices) = [[3, 4], [5, 6]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Gather elements or slices from `data` and store to a tensor whose
shape is defined by `indices`.

Given `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],
                                                      ...,
                                                      indices[M-1, y_0, ..., y_{K-1}],
                                                      x_M, ..., x_{N-1}]

Examples::

  data = [[0, 1], [2, 3]]
  indices = [[1, 1, 0], [0, 1, 0]]
  gather_nd(data, indices) = [2, 3, 0]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 0]]
  gather_nd(data, indices) = [[3, 4], [5, 6]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#hard_sigmoid" visbl="pub">
<a id="hard_sigmoid(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="hard_sigmoid(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">hard_sigmoid</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@hard_sigmoid(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes hard sigmoid of x element-wise.

.. math::
   y = max(0, min(1, alpha * x + beta))



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes hard sigmoid of x element-wise.

.. math::
   y = max(0, min(1, alpha * x + beta))



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#hard_sigmoid" visbl="pub">
<a id="hard_sigmoid(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="hard_sigmoid(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">hard_sigmoid</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@hard_sigmoid(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes hard sigmoid of x element-wise.

.. math::
   y = max(0, min(1, alpha * x + beta))



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes hard sigmoid of x element-wise.

.. math::
   y = max(0, min(1, alpha * x + beta))



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#identity" visbl="pub">
<a id="identity(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="identity(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">identity</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@identity(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a copy of the input.

From:src/operator/tensor/elemwise_unary_op_basic.cc:200
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a copy of the input.

From:src/operator/tensor/elemwise_unary_op_basic.cc:200
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#identity" visbl="pub">
<a id="identity(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="identity(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">identity</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@identity(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a copy of the input.

From:src/operator/tensor/elemwise_unary_op_basic.cc:200
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a copy of the input.

From:src/operator/tensor/elemwise_unary_op_basic.cc:200
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#khatri_rao" visbl="pub">
<a id="khatri_rao(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="khatri_rao(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">khatri_rao</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@khatri_rao(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the Khatri-Rao product of the input matrices.

Given a collection of :math:`n` input matrices,

.. math::
   A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},

the (column-wise) Khatri-Rao product is defined as the matrix,

.. math::
   X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},

where the :math:`k` th column is equal to the column-wise outer product
:math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
column of the ith matrix.

Example::

  &gt;&gt;&gt; A = mx.nd.array([[1, -1],
  &gt;&gt;&gt;                  [2, -3]])
  &gt;&gt;&gt; B = mx.nd.array([[1, 4],
  &gt;&gt;&gt;                  [2, 5],
  &gt;&gt;&gt;                  [3, 6]])
  &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
  &gt;&gt;&gt; print(C.asnumpy())
  [[  1.  -4.]
   [  2.  -5.]
   [  3.  -6.]
   [  2. -12.]
   [  4. -15.]
   [  6. -18.]]



Defined in src/operator/contrib/krprod.cc:L108
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the Khatri-Rao product of the input matrices.

Given a collection of :math:`n` input matrices,

.. math::
   A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},

the (column-wise) Khatri-Rao product is defined as the matrix,

.. math::
   X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},

where the :math:`k` th column is equal to the column-wise outer product
:math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
column of the ith matrix.

Example::

  &gt;&gt;&gt; A = mx.nd.array([[1, -1],
  &gt;&gt;&gt;                  [2, -3]])
  &gt;&gt;&gt; B = mx.nd.array([[1, 4],
  &gt;&gt;&gt;                  [2, 5],
  &gt;&gt;&gt;                  [3, 6]])
  &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
  &gt;&gt;&gt; print(C.asnumpy())
  [[  1.  -4.]
   [  2.  -5.]
   [  3.  -6.]
   [  2. -12.]
   [  4. -15.]
   [  6. -18.]]



Defined in src/operator/contrib/krprod.cc:L108
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#khatri_rao" visbl="pub">
<a id="khatri_rao(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="khatri_rao(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">khatri_rao</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@khatri_rao(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the Khatri-Rao product of the input matrices.

Given a collection of :math:`n` input matrices,

.. math::
   A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},

the (column-wise) Khatri-Rao product is defined as the matrix,

.. math::
   X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},

where the :math:`k` th column is equal to the column-wise outer product
:math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
column of the ith matrix.

Example::

  &gt;&gt;&gt; A = mx.nd.array([[1, -1],
  &gt;&gt;&gt;                  [2, -3]])
  &gt;&gt;&gt; B = mx.nd.array([[1, 4],
  &gt;&gt;&gt;                  [2, 5],
  &gt;&gt;&gt;                  [3, 6]])
  &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
  &gt;&gt;&gt; print(C.asnumpy())
  [[  1.  -4.]
   [  2.  -5.]
   [  3.  -6.]
   [  2. -12.]
   [  4. -15.]
   [  6. -18.]]



Defined in src/operator/contrib/krprod.cc:L108
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the Khatri-Rao product of the input matrices.

Given a collection of :math:`n` input matrices,

.. math::
   A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},

the (column-wise) Khatri-Rao product is defined as the matrix,

.. math::
   X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},

where the :math:`k` th column is equal to the column-wise outer product
:math:`{A_1}_k \otimes \cdots \otimes {A_n}_k` where :math:`{A_i}_k` is the kth
column of the ith matrix.

Example::

  &gt;&gt;&gt; A = mx.nd.array([[1, -1],
  &gt;&gt;&gt;                  [2, -3]])
  &gt;&gt;&gt; B = mx.nd.array([[1, 4],
  &gt;&gt;&gt;                  [2, 5],
  &gt;&gt;&gt;                  [3, 6]])
  &gt;&gt;&gt; C = mx.nd.khatri_rao(A, B)
  &gt;&gt;&gt; print(C.asnumpy())
  [[  1.  -4.]
   [  2.  -5.]
   [  3.  -6.]
   [  2. -12.]
   [  4. -15.]
   [  6. -18.]]



Defined in src/operator/contrib/krprod.cc:L108
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_gelqf" visbl="pub">
<a id="linalg_gelqf(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_gelqf(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_gelqf</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_gelqf(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
LQ factorization for general matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
that:

   *A* = *L* \* *Q*

Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
and *Q* is row-orthonormal, meaning that

   *Q* \* *Q*\ :sup:`T`

is equal to the identity matrix of shape *(x, x)*.

If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single LQ factorization
   A = [[1., 2., 3.], [4., 5., 6.]]
   Q, L = gelqf(A)
   Q = [[-0.26726124, -0.53452248, -0.80178373],
        [0.87287156, 0.21821789, -0.43643578]]
   L = [[-3.74165739, 0.],
        [-8.55235974, 1.96396101]]

   // Batch LQ factorization
   A = [[[1., 2., 3.], [4., 5., 6.]],
        [[7., 8., 9.], [10., 11., 12.]]]
   Q, L = gelqf(A)
   Q = [[[-0.26726124, -0.53452248, -0.80178373],
         [0.87287156, 0.21821789, -0.43643578]],
        [[-0.50257071, -0.57436653, -0.64616234],
         [0.7620735, 0.05862104, -0.64483142]]]
   L = [[[-3.74165739, 0.],
         [-8.55235974, 1.96396101]],
        [[-13.92838828, 0.],
         [-19.09768702, 0.52758934]]]


Defined in src/operator/tensor/la_op.cc:L552
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
LQ factorization for general matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
that:

   *A* = *L* \* *Q*

Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
and *Q* is row-orthonormal, meaning that

   *Q* \* *Q*\ :sup:`T`

is equal to the identity matrix of shape *(x, x)*.

If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single LQ factorization
   A = [[1., 2., 3.], [4., 5., 6.]]
   Q, L = gelqf(A)
   Q = [[-0.26726124, -0.53452248, -0.80178373],
        [0.87287156, 0.21821789, -0.43643578]]
   L = [[-3.74165739, 0.],
        [-8.55235974, 1.96396101]]

   // Batch LQ factorization
   A = [[[1., 2., 3.], [4., 5., 6.]],
        [[7., 8., 9.], [10., 11., 12.]]]
   Q, L = gelqf(A)
   Q = [[[-0.26726124, -0.53452248, -0.80178373],
         [0.87287156, 0.21821789, -0.43643578]],
        [[-0.50257071, -0.57436653, -0.64616234],
         [0.7620735, 0.05862104, -0.64483142]]]
   L = [[[-3.74165739, 0.],
         [-8.55235974, 1.96396101]],
        [[-13.92838828, 0.],
         [-19.09768702, 0.52758934]]]


Defined in src/operator/tensor/la_op.cc:L552
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_gelqf" visbl="pub">
<a id="linalg_gelqf(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_gelqf(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_gelqf</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_gelqf(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
LQ factorization for general matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
that:

   *A* = *L* \* *Q*

Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
and *Q* is row-orthonormal, meaning that

   *Q* \* *Q*\ :sup:`T`

is equal to the identity matrix of shape *(x, x)*.

If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single LQ factorization
   A = [[1., 2., 3.], [4., 5., 6.]]
   Q, L = gelqf(A)
   Q = [[-0.26726124, -0.53452248, -0.80178373],
        [0.87287156, 0.21821789, -0.43643578]]
   L = [[-3.74165739, 0.],
        [-8.55235974, 1.96396101]]

   // Batch LQ factorization
   A = [[[1., 2., 3.], [4., 5., 6.]],
        [[7., 8., 9.], [10., 11., 12.]]]
   Q, L = gelqf(A)
   Q = [[[-0.26726124, -0.53452248, -0.80178373],
         [0.87287156, 0.21821789, -0.43643578]],
        [[-0.50257071, -0.57436653, -0.64616234],
         [0.7620735, 0.05862104, -0.64483142]]]
   L = [[[-3.74165739, 0.],
         [-8.55235974, 1.96396101]],
        [[-13.92838828, 0.],
         [-19.09768702, 0.52758934]]]


Defined in src/operator/tensor/la_op.cc:L552
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
LQ factorization for general matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*
must have shape *(x, y)* with *x &lt;= y*, and must have full rank *=x*. The LQ
factorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so
that:

   *A* = *L* \* *Q*

Here, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,
and *Q* is row-orthonormal, meaning that

   *Q* \* *Q*\ :sup:`T`

is equal to the identity matrix of shape *(x, x)*.

If *n&gt;2*, *gelqf* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single LQ factorization
   A = [[1., 2., 3.], [4., 5., 6.]]
   Q, L = gelqf(A)
   Q = [[-0.26726124, -0.53452248, -0.80178373],
        [0.87287156, 0.21821789, -0.43643578]]
   L = [[-3.74165739, 0.],
        [-8.55235974, 1.96396101]]

   // Batch LQ factorization
   A = [[[1., 2., 3.], [4., 5., 6.]],
        [[7., 8., 9.], [10., 11., 12.]]]
   Q, L = gelqf(A)
   Q = [[[-0.26726124, -0.53452248, -0.80178373],
         [0.87287156, 0.21821789, -0.43643578]],
        [[-0.50257071, -0.57436653, -0.64616234],
         [0.7620735, 0.05862104, -0.64483142]]]
   L = [[[-3.74165739, 0.],
         [-8.55235974, 1.96396101]],
        [[-13.92838828, 0.],
         [-19.09768702, 0.52758934]]]


Defined in src/operator/tensor/la_op.cc:L552
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_gemm" visbl="pub">
<a id="linalg_gemm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_gemm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_gemm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_gemm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs general matrix multiplication and accumulation.
Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*

Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
matrix transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = swapaxes(C, dim1=1, dim2=3)
    C = gemm(A1, B1, C)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply-add
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
           = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]

   // Batch matrix multiply-add
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   C = [[[10.0]], [[0.01]]]
   gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
           = [[[104.0]], [[0.14]]]


Defined in src/operator/tensor/la_op.cc:L81
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs general matrix multiplication and accumulation.
Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*

Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
matrix transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = swapaxes(C, dim1=1, dim2=3)
    C = gemm(A1, B1, C)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply-add
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
           = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]

   // Batch matrix multiply-add
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   C = [[[10.0]], [[0.01]]]
   gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
           = [[[104.0]], [[0.14]]]


Defined in src/operator/tensor/la_op.cc:L81
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_gemm" visbl="pub">
<a id="linalg_gemm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_gemm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_gemm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_gemm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs general matrix multiplication and accumulation.
Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*

Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
matrix transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = swapaxes(C, dim1=1, dim2=3)
    C = gemm(A1, B1, C)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply-add
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
           = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]

   // Batch matrix multiply-add
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   C = [[[10.0]], [[0.01]]]
   gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
           = [[[104.0]], [[0.14]]]


Defined in src/operator/tensor/la_op.cc:L81
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs general matrix multiplication and accumulation.
Input are tensors *A*, *B*, *C*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*) + *beta* \* *C*

Here, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or
matrix transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = swapaxes(C, dim1=1, dim2=3)
    C = gemm(A1, B1, C)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply-add
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)
           = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]

   // Batch matrix multiply-add
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   C = [[[10.0]], [[0.01]]]
   gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)
           = [[[104.0]], [[0.14]]]


Defined in src/operator/tensor/la_op.cc:L81
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_gemm2" visbl="pub">
<a id="linalg_gemm2(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_gemm2(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_gemm2</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_gemm2(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs general matrix multiplication.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)

Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = gemm2(A1, B1)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
            = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]

   // Batch matrix multiply
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
           = [[[4.0]], [[0.04 ]]]


Defined in src/operator/tensor/la_op.cc:L151
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs general matrix multiplication.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)

Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = gemm2(A1, B1)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
            = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]

   // Batch matrix multiply
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
           = [[[4.0]], [[0.04 ]]]


Defined in src/operator/tensor/la_op.cc:L151
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_gemm2" visbl="pub">
<a id="linalg_gemm2(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_gemm2(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_gemm2</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_gemm2(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs general matrix multiplication.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)

Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = gemm2(A1, B1)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
            = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]

   // Batch matrix multiply
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
           = [[[4.0]], [[0.04 ]]]


Defined in src/operator/tensor/la_op.cc:L151
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs general matrix multiplication.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, the BLAS3 function *gemm* is performed:

   *out* = *alpha* \* *op*\ (*A*) \* *op*\ (*B*)

Here *alpha* is a scalar parameter and *op()* is either the identity or the matrix
transposition (depending on *transpose_a*, *transpose_b*).

If *n&gt;2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*
parameter. By default, the trailing two dimensions will be used for matrix encoding.

For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to

    A1 = swapaxes(A, dim1=1, dim2=3)
    B1 = swapaxes(B, dim1=1, dim2=3)
    C = gemm2(A1, B1)
    C = swapaxis(C, dim1=1, dim2=3)

without the overhead of the additional swapaxis operations.

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1.0, 1.0], [1.0, 1.0]]
   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
            = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]

   // Batch matrix multiply
   A = [[[1.0, 1.0]], [[0.1, 0.1]]]
   B = [[[1.0, 1.0]], [[0.1, 0.1]]]
   gemm2(A, B, transpose_b=True, alpha=2.0)
           = [[[4.0]], [[0.04 ]]]


Defined in src/operator/tensor/la_op.cc:L151
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_potrf" visbl="pub">
<a id="linalg_potrf(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_potrf(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_potrf</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_potrf(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs Cholesky factorization of a symmetric positive-definite matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the Cholesky factor *L* of the symmetric, positive definite matrix *A* is
computed. *L* is lower triangular (entries of upper triangle are all zero), has
positive diagonal entries, and:

  *A* = *L* \* *L*\ :sup:`T`

If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix factorization
   A = [[4.0, 1.0], [1.0, 4.25]]
   potrf(A) = [[2.0, 0], [0.5, 2.0]]

   // Batch matrix factorization
   A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
   potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]


Defined in src/operator/tensor/la_op.cc:L201
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs Cholesky factorization of a symmetric positive-definite matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the Cholesky factor *L* of the symmetric, positive definite matrix *A* is
computed. *L* is lower triangular (entries of upper triangle are all zero), has
positive diagonal entries, and:

  *A* = *L* \* *L*\ :sup:`T`

If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix factorization
   A = [[4.0, 1.0], [1.0, 4.25]]
   potrf(A) = [[2.0, 0], [0.5, 2.0]]

   // Batch matrix factorization
   A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
   potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]


Defined in src/operator/tensor/la_op.cc:L201
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_potrf" visbl="pub">
<a id="linalg_potrf(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_potrf(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_potrf</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_potrf(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs Cholesky factorization of a symmetric positive-definite matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the Cholesky factor *L* of the symmetric, positive definite matrix *A* is
computed. *L* is lower triangular (entries of upper triangle are all zero), has
positive diagonal entries, and:

  *A* = *L* \* *L*\ :sup:`T`

If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix factorization
   A = [[4.0, 1.0], [1.0, 4.25]]
   potrf(A) = [[2.0, 0], [0.5, 2.0]]

   // Batch matrix factorization
   A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
   potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]


Defined in src/operator/tensor/la_op.cc:L201
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs Cholesky factorization of a symmetric positive-definite matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the Cholesky factor *L* of the symmetric, positive definite matrix *A* is
computed. *L* is lower triangular (entries of upper triangle are all zero), has
positive diagonal entries, and:

  *A* = *L* \* *L*\ :sup:`T`

If *n&gt;2*, *potrf* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix factorization
   A = [[4.0, 1.0], [1.0, 4.25]]
   potrf(A) = [[2.0, 0], [0.5, 2.0]]

   // Batch matrix factorization
   A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]
   potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]


Defined in src/operator/tensor/la_op.cc:L201
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_potri" visbl="pub">
<a id="linalg_potri(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_potri(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_potri</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_potri(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs matrix inversion from a Cholesky factorization.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* is a lower triangular matrix (entries of upper triangle are all zero)
with positive diagonal. We compute:

  *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1`

In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
*B* (obtained by *potrf*), then

  *out* = *B*\ :sup:`-1`

If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

.. note:: Use this operator only if you are certain you need the inverse of *B*, and
          cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
          (*trsm*). The latter is numerically much safer, and also cheaper.

Examples::

   // Single matrix inverse
   A = [[2.0, 0], [0.5, 2.0]]
   potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]

   // Batch matrix inverse
   A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
   potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
               [[0.06641, -0.01562], [-0.01562, 0,0625]]]


Defined in src/operator/tensor/la_op.cc:L259
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs matrix inversion from a Cholesky factorization.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* is a lower triangular matrix (entries of upper triangle are all zero)
with positive diagonal. We compute:

  *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1`

In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
*B* (obtained by *potrf*), then

  *out* = *B*\ :sup:`-1`

If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

.. note:: Use this operator only if you are certain you need the inverse of *B*, and
          cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
          (*trsm*). The latter is numerically much safer, and also cheaper.

Examples::

   // Single matrix inverse
   A = [[2.0, 0], [0.5, 2.0]]
   potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]

   // Batch matrix inverse
   A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
   potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
               [[0.06641, -0.01562], [-0.01562, 0,0625]]]


Defined in src/operator/tensor/la_op.cc:L259
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_potri" visbl="pub">
<a id="linalg_potri(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_potri(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_potri</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_potri(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs matrix inversion from a Cholesky factorization.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* is a lower triangular matrix (entries of upper triangle are all zero)
with positive diagonal. We compute:

  *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1`

In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
*B* (obtained by *potrf*), then

  *out* = *B*\ :sup:`-1`

If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

.. note:: Use this operator only if you are certain you need the inverse of *B*, and
          cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
          (*trsm*). The latter is numerically much safer, and also cheaper.

Examples::

   // Single matrix inverse
   A = [[2.0, 0], [0.5, 2.0]]
   potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]

   // Batch matrix inverse
   A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
   potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
               [[0.06641, -0.01562], [-0.01562, 0,0625]]]


Defined in src/operator/tensor/la_op.cc:L259
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs matrix inversion from a Cholesky factorization.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* is a lower triangular matrix (entries of upper triangle are all zero)
with positive diagonal. We compute:

  *out* = *A*\ :sup:`-T` \* *A*\ :sup:`-1`

In other words, if *A* is the Cholesky factor of a symmetric positive definite matrix
*B* (obtained by *potrf*), then

  *out* = *B*\ :sup:`-1`

If *n&gt;2*, *potri* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

.. note:: Use this operator only if you are certain you need the inverse of *B*, and
          cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution
          (*trsm*). The latter is numerically much safer, and also cheaper.

Examples::

   // Single matrix inverse
   A = [[2.0, 0], [0.5, 2.0]]
   potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]

   // Batch matrix inverse
   A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]
   potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],
               [[0.06641, -0.01562], [-0.01562, 0,0625]]]


Defined in src/operator/tensor/la_op.cc:L259
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_sumlogdiag" visbl="pub">
<a id="linalg_sumlogdiag(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_sumlogdiag(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_sumlogdiag</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_sumlogdiag(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of the logarithms of the diagonal elements of a square matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
logarithms of the diagonal elements, the result has shape (1,).

If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix reduction
   A = [[1.0, 1.0], [1.0, 7.0]]
   sumlogdiag(A) = [1.9459]

   // Batch matrix reduction
   A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
   sumlogdiag(A) = [1.9459, 3.9318]


Defined in src/operator/tensor/la_op.cc:L428
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of the logarithms of the diagonal elements of a square matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
logarithms of the diagonal elements, the result has shape (1,).

If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix reduction
   A = [[1.0, 1.0], [1.0, 7.0]]
   sumlogdiag(A) = [1.9459]

   // Batch matrix reduction
   A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
   sumlogdiag(A) = [1.9459, 3.9318]


Defined in src/operator/tensor/la_op.cc:L428
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_sumlogdiag" visbl="pub">
<a id="linalg_sumlogdiag(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_sumlogdiag(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_sumlogdiag</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_sumlogdiag(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of the logarithms of the diagonal elements of a square matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
logarithms of the diagonal elements, the result has shape (1,).

If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix reduction
   A = [[1.0, 1.0], [1.0, 7.0]]
   sumlogdiag(A) = [1.9459]

   // Batch matrix reduction
   A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
   sumlogdiag(A) = [1.9459, 3.9318]


Defined in src/operator/tensor/la_op.cc:L428
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of the logarithms of the diagonal elements of a square matrix.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, *A* must be square with positive diagonal entries. We sum the natural
logarithms of the diagonal elements, the result has shape (1,).

If *n&gt;2*, *sumlogdiag* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix reduction
   A = [[1.0, 1.0], [1.0, 7.0]]
   sumlogdiag(A) = [1.9459]

   // Batch matrix reduction
   A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]
   sumlogdiag(A) = [1.9459, 3.9318]


Defined in src/operator/tensor/la_op.cc:L428
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_syrk" visbl="pub">
<a id="linalg_syrk(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_syrk(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_syrk</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_syrk(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Multiplication of matrix with its transpose.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the operator performs the BLAS3 function *syrk*:

  *out* = *alpha* \* *A* \* *A*\ :sup:`T`

if *transpose=False*, or

  *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*

if *transpose=True*.

If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1., 2., 3.], [4., 5., 6.]]
   syrk(A, alpha=1., transpose=False)
            = [[14., 32.],
               [32., 77.]]
   syrk(A, alpha=1., transpose=True)
            = [[17., 22., 27.],
               [22., 29., 36.],
               [27., 36., 45.]]

   // Batch matrix multiply
   A = [[[1., 1.]], [[0.1, 0.1]]]
   syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]


Defined in src/operator/tensor/la_op.cc:L484
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Multiplication of matrix with its transpose.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the operator performs the BLAS3 function *syrk*:

  *out* = *alpha* \* *A* \* *A*\ :sup:`T`

if *transpose=False*, or

  *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*

if *transpose=True*.

If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1., 2., 3.], [4., 5., 6.]]
   syrk(A, alpha=1., transpose=False)
            = [[14., 32.],
               [32., 77.]]
   syrk(A, alpha=1., transpose=True)
            = [[17., 22., 27.],
               [22., 29., 36.],
               [27., 36., 45.]]

   // Batch matrix multiply
   A = [[[1., 1.]], [[0.1, 0.1]]]
   syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]


Defined in src/operator/tensor/la_op.cc:L484
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_syrk" visbl="pub">
<a id="linalg_syrk(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_syrk(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_syrk</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_syrk(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Multiplication of matrix with its transpose.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the operator performs the BLAS3 function *syrk*:

  *out* = *alpha* \* *A* \* *A*\ :sup:`T`

if *transpose=False*, or

  *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*

if *transpose=True*.

If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1., 2., 3.], [4., 5., 6.]]
   syrk(A, alpha=1., transpose=False)
            = [[14., 32.],
               [32., 77.]]
   syrk(A, alpha=1., transpose=True)
            = [[17., 22., 27.],
               [22., 29., 36.],
               [27., 36., 45.]]

   // Batch matrix multiply
   A = [[[1., 1.]], [[0.1, 0.1]]]
   syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]


Defined in src/operator/tensor/la_op.cc:L484
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Multiplication of matrix with its transpose.
Input is a tensor *A* of dimension *n &gt;= 2*.

If *n=2*, the operator performs the BLAS3 function *syrk*:

  *out* = *alpha* \* *A* \* *A*\ :sup:`T`

if *transpose=False*, or

  *out* = *alpha* \* *A*\ :sup:`T` \ \* *A*

if *transpose=True*.

If *n&gt;2*, *syrk* is performed separately on the trailing two dimensions for all
inputs (batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix multiply
   A = [[1., 2., 3.], [4., 5., 6.]]
   syrk(A, alpha=1., transpose=False)
            = [[14., 32.],
               [32., 77.]]
   syrk(A, alpha=1., transpose=True)
            = [[17., 22., 27.],
               [22., 29., 36.],
               [27., 36., 45.]]

   // Batch matrix multiply
   A = [[[1., 1.]], [[0.1, 0.1]]]
   syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]


Defined in src/operator/tensor/la_op.cc:L484
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_trmm" visbl="pub">
<a id="linalg_trmm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_trmm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_trmm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_trmm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs multiplication with a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trmm*:

   *out* = *alpha* \* *op*\ (*A*) \* *B*

if *rightside=False*, or

   *out* = *alpha* \* *B* \* *op*\ (*A*)

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.


Examples::

   // Single triangular matrix multiply
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]

   // Batch triangular matrix multiply
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
   trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
                            [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L316
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs multiplication with a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trmm*:

   *out* = *alpha* \* *op*\ (*A*) \* *B*

if *rightside=False*, or

   *out* = *alpha* \* *B* \* *op*\ (*A*)

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.


Examples::

   // Single triangular matrix multiply
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]

   // Batch triangular matrix multiply
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
   trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
                            [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L316
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_trmm" visbl="pub">
<a id="linalg_trmm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_trmm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_trmm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_trmm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Performs multiplication with a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trmm*:

   *out* = *alpha* \* *op*\ (*A*) \* *B*

if *rightside=False*, or

   *out* = *alpha* \* *B* \* *op*\ (*A*)

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.


Examples::

   // Single triangular matrix multiply
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]

   // Batch triangular matrix multiply
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
   trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
                            [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L316
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Performs multiplication with a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trmm*:

   *out* = *alpha* \* *op*\ (*A*) \* *B*

if *rightside=False*, or

   *out* = *alpha* \* *B* \* *op*\ (*A*)

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trmm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.


Examples::

   // Single triangular matrix multiply
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]
   trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]

   // Batch triangular matrix multiply
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]
   trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
                            [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L316
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_trsm" visbl="pub">
<a id="linalg_trsm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_trsm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_trsm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_trsm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Solves matrix equation involving a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trsm*, solving for *out* in:

   *op*\ (*A*) \* *out* = *alpha* \* *B*

if *rightside=False*, or

   *out* \* *op*\ (*A*) = *alpha* \* *B*

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix solve
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
   trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]

   // Batch matrix solve
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
        [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
   trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
                            [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L379
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Solves matrix equation involving a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trsm*, solving for *out* in:

   *op*\ (*A*) \* *out* = *alpha* \* *B*

if *rightside=False*, or

   *out* \* *op*\ (*A*) = *alpha* \* *B*

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix solve
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
   trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]

   // Batch matrix solve
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
        [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
   trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
                            [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L379
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#linalg_trsm" visbl="pub">
<a id="linalg_trsm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="linalg_trsm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">linalg_trsm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@linalg_trsm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Solves matrix equation involving a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trsm*, solving for *out* in:

   *op*\ (*A*) \* *out* = *alpha* \* *B*

if *rightside=False*, or

   *out* \* *op*\ (*A*) = *alpha* \* *B*

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix solve
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
   trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]

   // Batch matrix solve
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
        [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
   trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
                            [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L379
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Solves matrix equation involving a lower triangular matrix.
Input are tensors *A*, *B*, each of dimension *n &gt;= 2* and having the same shape
on the leading *n-2* dimensions.

If *n=2*, *A* must be lower triangular. The operator performs the BLAS3 function
*trsm*, solving for *out* in:

   *op*\ (*A*) \* *out* = *alpha* \* *B*

if *rightside=False*, or

   *out* \* *op*\ (*A*) = *alpha* \* *B*

if *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the
identity or the matrix transposition (depending on *transpose*).

If *n&gt;2*, *trsm* is performed separately on the trailing two dimensions for all inputs
(batch mode).

.. note:: The operator supports float32 and float64 data types only.

Examples::

   // Single matrix solve
   A = [[1.0, 0], [1.0, 1.0]]
   B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]
   trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]

   // Batch matrix solve
   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]
   B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],
        [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]
   trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
                            [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]


Defined in src/operator/tensor/la_op.cc:L379
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log" visbl="pub">
<a id="log(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise Natural logarithmic value of the input.

The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``

The storage type of ``log`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L939
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise Natural logarithmic value of the input.

The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``

The storage type of ``log`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L939
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log" visbl="pub">
<a id="log(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise Natural logarithmic value of the input.

The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``

The storage type of ``log`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L939
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise Natural logarithmic value of the input.

The natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``

The storage type of ``log`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L939
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log10" visbl="pub">
<a id="log10(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log10(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log10</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log10(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise Base-10 logarithmic value of the input.

``10**log10(x) = x``

The storage type of ``log10`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L951
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise Base-10 logarithmic value of the input.

``10**log10(x) = x``

The storage type of ``log10`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L951
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log10" visbl="pub">
<a id="log10(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log10(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log10</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log10(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise Base-10 logarithmic value of the input.

``10**log10(x) = x``

The storage type of ``log10`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L951
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise Base-10 logarithmic value of the input.

``10**log10(x) = x``

The storage type of ``log10`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L951
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log1p" visbl="pub">
<a id="log1p(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log1p(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log1p</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log1p(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise ``log(1 + x)`` value of the input.

This function is more accurate than ``log(1 + x)``  for small ``x`` so that
:math:`1+x\approx 1`

The storage type of ``log1p`` output depends upon the input storage type:

   - log1p(default) = default
   - log1p(row_sparse) = row_sparse
   - log1p(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L988
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise ``log(1 + x)`` value of the input.

This function is more accurate than ``log(1 + x)``  for small ``x`` so that
:math:`1+x\approx 1`

The storage type of ``log1p`` output depends upon the input storage type:

   - log1p(default) = default
   - log1p(row_sparse) = row_sparse
   - log1p(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L988
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log1p" visbl="pub">
<a id="log1p(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log1p(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log1p</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log1p(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise ``log(1 + x)`` value of the input.

This function is more accurate than ``log(1 + x)``  for small ``x`` so that
:math:`1+x\approx 1`

The storage type of ``log1p`` output depends upon the input storage type:

   - log1p(default) = default
   - log1p(row_sparse) = row_sparse
   - log1p(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L988
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise ``log(1 + x)`` value of the input.

This function is more accurate than ``log(1 + x)``  for small ``x`` so that
:math:`1+x\approx 1`

The storage type of ``log1p`` output depends upon the input storage type:

   - log1p(default) = default
   - log1p(row_sparse) = row_sparse
   - log1p(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L988
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log2" visbl="pub">
<a id="log2(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log2(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log2</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log2(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise Base-2 logarithmic value of the input.

``2**log2(x) = x``

The storage type of ``log2`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L963
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise Base-2 logarithmic value of the input.

``2**log2(x) = x``

The storage type of ``log2`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L963
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log2" visbl="pub">
<a id="log2(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log2(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log2</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log2(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise Base-2 logarithmic value of the input.

``2**log2(x) = x``

The storage type of ``log2`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L963
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise Base-2 logarithmic value of the input.

``2**log2(x) = x``

The storage type of ``log2`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L963
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log_softmax" visbl="pub">
<a id="log_softmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log_softmax(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log_softmax</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log_softmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the log softmax of the input.
This is equivalent to computing softmax followed by log.

Examples::

  &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
  &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
  array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)

  &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
  &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
  array([[-0.34115392, -0.69314718, -1.24115396],
         [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the log softmax of the input.
This is equivalent to computing softmax followed by log.

Examples::

  &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
  &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
  array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)

  &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
  &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
  array([[-0.34115392, -0.69314718, -1.24115396],
         [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#log_softmax" visbl="pub">
<a id="log_softmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="log_softmax(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">log_softmax</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@log_softmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the log softmax of the input.
This is equivalent to computing softmax followed by log.

Examples::

  &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
  &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
  array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)

  &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
  &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
  array([[-0.34115392, -0.69314718, -1.24115396],
         [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the log softmax of the input.
This is equivalent to computing softmax followed by log.

Examples::

  &gt;&gt;&gt; x = mx.nd.array([1, 2, .1])
  &gt;&gt;&gt; mx.nd.log_softmax(x).asnumpy()
  array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)

  &gt;&gt;&gt; x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )
  &gt;&gt;&gt; mx.nd.log_softmax(x, axis=0).asnumpy()
  array([[-0.34115392, -0.69314718, -1.24115396],
         [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#logical_not" visbl="pub">
<a id="logical_not(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="logical_not(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">logical_not</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@logical_not(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of logical NOT (!) function

Example:
  logical_not([-2., 0., 1.]) = [0., 1., 0.]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of logical NOT (!) function

Example:
  logical_not([-2., 0., 1.]) = [0., 1., 0.]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#logical_not" visbl="pub">
<a id="logical_not(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="logical_not(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">logical_not</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@logical_not(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the result of logical NOT (!) function

Example:
  logical_not([-2., 0., 1.]) = [0., 1., 0.]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the result of logical NOT (!) function

Example:
  logical_not([-2., 0., 1.]) = [0., 1., 0.]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#make_loss" visbl="pub">
<a id="make_loss(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="make_loss(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">make_loss</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@make_loss(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = make_loss(cross_entropy)

We will need to use ``make_loss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

The storage type of ``make_loss`` output depends upon the input storage type:

   - make_loss(default) = default
   - make_loss(row_sparse) = row_sparse



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L298
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = make_loss(cross_entropy)

We will need to use ``make_loss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

The storage type of ``make_loss`` output depends upon the input storage type:

   - make_loss(default) = default
   - make_loss(row_sparse) = row_sparse



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L298
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#make_loss" visbl="pub">
<a id="make_loss(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="make_loss(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">make_loss</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@make_loss(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = make_loss(cross_entropy)

We will need to use ``make_loss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

The storage type of ``make_loss`` output depends upon the input storage type:

   - make_loss(default) = default
   - make_loss(row_sparse) = row_sparse



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L298
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Make your own loss function in network construction.

This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.

For example, if you are a making a cross entropy loss function. Assume ``out`` is the
predicted output and ``label`` is the true label, then the cross entropy can be defined as::

  cross_entropy = label * log(out) + (1 - label) * log(1 - out)
  loss = make_loss(cross_entropy)

We will need to use ``make_loss`` when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables' gradients
from backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.

The storage type of ``make_loss`` output depends upon the input storage type:

   - make_loss(default) = default
   - make_loss(row_sparse) = row_sparse



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L298
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#max" visbl="pub">
<a id="max(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="max(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">max</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@max(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#max" visbl="pub">
<a id="max(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="max(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">max</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@max(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#max_axis" visbl="pub">
<a id="max_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="max_axis(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">max_axis</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@max_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#max_axis" visbl="pub">
<a id="max_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="max_axis(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">max_axis</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@max_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the max of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L190
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#mean" visbl="pub">
<a id="mean(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="mean(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">mean</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@mean(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the mean of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the mean of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#mean" visbl="pub">
<a id="mean(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="mean(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">mean</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@mean(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the mean of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the mean of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L131
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#min" visbl="pub">
<a id="min(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="min(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">min</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@min(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#min" visbl="pub">
<a id="min(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="min(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">min</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@min(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#min_axis" visbl="pub">
<a id="min_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="min_axis(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">min_axis</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@min_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#min_axis" visbl="pub">
<a id="min_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="min_axis(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">min_axis</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@min_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the min of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L204
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#mp_sgd_mom_update" visbl="pub">
<a id="mp_sgd_mom_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="mp_sgd_mom_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">mp_sgd_mom_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@mp_sgd_mom_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#mp_sgd_mom_update" visbl="pub">
<a id="mp_sgd_mom_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="mp_sgd_mom_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">mp_sgd_mom_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@mp_sgd_mom_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#mp_sgd_update" visbl="pub">
<a id="mp_sgd_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="mp_sgd_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">mp_sgd_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@mp_sgd_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#mp_sgd_update" visbl="pub">
<a id="mp_sgd_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="mp_sgd_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">mp_sgd_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@mp_sgd_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Updater function for multi-precision sgd optimizer
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#nanprod" visbl="pub">
<a id="nanprod(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="nanprod(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">nanprod</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@nanprod(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L176
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L176
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#nanprod" visbl="pub">
<a id="nanprod(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="nanprod(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">nanprod</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@nanprod(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L176
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L176
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#nansum" visbl="pub">
<a id="nansum(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="nansum(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">nansum</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@nansum(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L161
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L161
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#nansum" visbl="pub">
<a id="nansum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="nansum(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">nansum</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@nansum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L161
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L161
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#negative" visbl="pub">
<a id="negative(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="negative(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">negative</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@negative(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Numerical negative of the argument, element-wise.

The storage type of ``negative`` output depends upon the input storage type:

   - negative(default) = default
   - negative(row_sparse) = row_sparse
   - negative(csr) = csr
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Numerical negative of the argument, element-wise.

The storage type of ``negative`` output depends upon the input storage type:

   - negative(default) = default
   - negative(row_sparse) = row_sparse
   - negative(csr) = csr
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#negative" visbl="pub">
<a id="negative(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="negative(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">negative</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@negative(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Numerical negative of the argument, element-wise.

The storage type of ``negative`` output depends upon the input storage type:

   - negative(default) = default
   - negative(row_sparse) = row_sparse
   - negative(csr) = csr
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Numerical negative of the argument, element-wise.

The storage type of ``negative`` output depends upon the input storage type:

   - negative(default) = default
   - negative(row_sparse) = row_sparse
   - negative(csr) = csr
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#norm" visbl="pub">
<a id="norm(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="norm(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">norm</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@norm(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the norm on an NDArray.

This operator computes the norm on an NDArray with the specified axis, depending
on the value of the ord parameter. By default, it computes the L2 norm on the entire
array. Currently only ord=2 supports sparse ndarrays.

Examples::

  x = [[[1, 2],
        [3, 4]],
       [[2, 2],
        [5, 6]]]

  norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
                            [5.3851647 6.3245554]]

  norm(x, ord=1, axis=1) = [[4., 6.],
                            [7., 8.]]

  rsp = x.cast_storage('row_sparse')

  norm(rsp) = [5.47722578]

  csr = x.cast_storage('csr')

  norm(csr) = [5.47722578]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L345
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the norm on an NDArray.

This operator computes the norm on an NDArray with the specified axis, depending
on the value of the ord parameter. By default, it computes the L2 norm on the entire
array. Currently only ord=2 supports sparse ndarrays.

Examples::

  x = [[[1, 2],
        [3, 4]],
       [[2, 2],
        [5, 6]]]

  norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
                            [5.3851647 6.3245554]]

  norm(x, ord=1, axis=1) = [[4., 6.],
                            [7., 8.]]

  rsp = x.cast_storage('row_sparse')

  norm(rsp) = [5.47722578]

  csr = x.cast_storage('csr')

  norm(csr) = [5.47722578]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L345
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#norm" visbl="pub">
<a id="norm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="norm(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">norm</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@norm(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the norm on an NDArray.

This operator computes the norm on an NDArray with the specified axis, depending
on the value of the ord parameter. By default, it computes the L2 norm on the entire
array. Currently only ord=2 supports sparse ndarrays.

Examples::

  x = [[[1, 2],
        [3, 4]],
       [[2, 2],
        [5, 6]]]

  norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
                            [5.3851647 6.3245554]]

  norm(x, ord=1, axis=1) = [[4., 6.],
                            [7., 8.]]

  rsp = x.cast_storage('row_sparse')

  norm(rsp) = [5.47722578]

  csr = x.cast_storage('csr')

  norm(csr) = [5.47722578]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L345
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the norm on an NDArray.

This operator computes the norm on an NDArray with the specified axis, depending
on the value of the ord parameter. By default, it computes the L2 norm on the entire
array. Currently only ord=2 supports sparse ndarrays.

Examples::

  x = [[[1, 2],
        [3, 4]],
       [[2, 2],
        [5, 6]]]

  norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]
                            [5.3851647 6.3245554]]

  norm(x, ord=1, axis=1) = [[4., 6.],
                            [7., 8.]]

  rsp = x.cast_storage('row_sparse')

  norm(rsp) = [5.47722578]

  csr = x.cast_storage('csr')

  norm(csr) = [5.47722578]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L345
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#normal" visbl="pub">
<a id="normal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="normal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">normal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@normal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#normal" visbl="pub">
<a id="normal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="normal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">normal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@normal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#one_hot" visbl="pub">
<a id="one_hot(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="one_hot(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">one_hot</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@one_hot(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a one-hot array.

The locations represented by `indices` take value `on_value`, while all
other locations take value `off_value`.

`one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
in an output array of shape ``(i0, i1, d)`` with::

  output[i,j,:] = off_value
  output[i,j,indices[i,j]] = on_value

Examples::

  one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
                           [ 1.  0.  0.]
                           [ 0.  0.  1.]
                           [ 1.  0.  0.]]

  one_hot([1,0,2,0], 3, on_value=8, off_value=1,
          dtype='int32') = [[1 8 1]
                            [8 1 1]
                            [1 1 8]
                            [8 1 1]]

  one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  0.  1.]
                                      [ 1.  0.  0.]]]


Defined in src/operator/tensor/indexing_op.cc:L536
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a one-hot array.

The locations represented by `indices` take value `on_value`, while all
other locations take value `off_value`.

`one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
in an output array of shape ``(i0, i1, d)`` with::

  output[i,j,:] = off_value
  output[i,j,indices[i,j]] = on_value

Examples::

  one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
                           [ 1.  0.  0.]
                           [ 0.  0.  1.]
                           [ 1.  0.  0.]]

  one_hot([1,0,2,0], 3, on_value=8, off_value=1,
          dtype='int32') = [[1 8 1]
                            [8 1 1]
                            [1 1 8]
                            [8 1 1]]

  one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  0.  1.]
                                      [ 1.  0.  0.]]]


Defined in src/operator/tensor/indexing_op.cc:L536
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#one_hot" visbl="pub">
<a id="one_hot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="one_hot(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">one_hot</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@one_hot(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a one-hot array.

The locations represented by `indices` take value `on_value`, while all
other locations take value `off_value`.

`one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
in an output array of shape ``(i0, i1, d)`` with::

  output[i,j,:] = off_value
  output[i,j,indices[i,j]] = on_value

Examples::

  one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
                           [ 1.  0.  0.]
                           [ 0.  0.  1.]
                           [ 1.  0.  0.]]

  one_hot([1,0,2,0], 3, on_value=8, off_value=1,
          dtype='int32') = [[1 8 1]
                            [8 1 1]
                            [1 1 8]
                            [8 1 1]]

  one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  0.  1.]
                                      [ 1.  0.  0.]]]


Defined in src/operator/tensor/indexing_op.cc:L536
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a one-hot array.

The locations represented by `indices` take value `on_value`, while all
other locations take value `off_value`.

`one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result
in an output array of shape ``(i0, i1, d)`` with::

  output[i,j,:] = off_value
  output[i,j,indices[i,j]] = on_value

Examples::

  one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]
                           [ 1.  0.  0.]
                           [ 0.  0.  1.]
                           [ 1.  0.  0.]]

  one_hot([1,0,2,0], 3, on_value=8, off_value=1,
          dtype='int32') = [[1 8 1]
                            [8 1 1]
                            [1 1 8]
                            [8 1 1]]

  one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  1.  0.]
                                      [ 1.  0.  0.]]

                                     [[ 0.  0.  1.]
                                      [ 1.  0.  0.]]]


Defined in src/operator/tensor/indexing_op.cc:L536
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ones_like" visbl="pub">
<a id="ones_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ones_like(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ones_like</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ones_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return an array of ones with the same shape and type
as the input array.

Examples::

  x = [[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]]

  ones_like(x) = [[ 1.,  1.,  1.],
                  [ 1.,  1.,  1.]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return an array of ones with the same shape and type
as the input array.

Examples::

  x = [[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]]

  ones_like(x) = [[ 1.,  1.,  1.],
                  [ 1.,  1.,  1.]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ones_like" visbl="pub">
<a id="ones_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ones_like(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ones_like</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ones_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return an array of ones with the same shape and type
as the input array.

Examples::

  x = [[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]]

  ones_like(x) = [[ 1.,  1.,  1.],
                  [ 1.,  1.,  1.]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return an array of ones with the same shape and type
as the input array.

Examples::

  x = [[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]]

  ones_like(x) = [[ 1.,  1.,  1.],
                  [ 1.,  1.,  1.]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#pad" visbl="pub">
<a id="pad(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="pad(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">pad</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@pad(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#pad" visbl="pub">
<a id="pad(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="pad(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">pad</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@pad(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Pads an input array with a constant or edge values of the array.

.. note:: `Pad` is deprecated. Use `pad` instead.

.. note:: Current implementation only supports 4D and 5D input arrays with padding applied
   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.

This operation pads an input array with either a `constant_value` or edge values
along each axis of the input array. The amount of padding is specified by `pad_width`.

`pad_width` is a tuple of integer padding widths for each axis of the format
``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``
where ``N`` is the number of dimensions of the array.

For dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values
to add before and after the elements of the array along dimension ``N``.
The widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,
``after_2`` must be 0.

Example::

   x = [[[[  1.   2.   3.]
          [  4.   5.   6.]]

         [[  7.   8.   9.]
          [ 10.  11.  12.]]]


        [[[ 11.  12.  13.]
          [ 14.  15.  16.]]

         [[ 17.  18.  19.]
          [ 20.  21.  22.]]]]

   pad(x,mode="edge", pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  1.   1.   2.   3.   3.]
            [  1.   1.   2.   3.   3.]
            [  4.   4.   5.   6.   6.]
            [  4.   4.   5.   6.   6.]]

           [[  7.   7.   8.   9.   9.]
            [  7.   7.   8.   9.   9.]
            [ 10.  10.  11.  12.  12.]
            [ 10.  10.  11.  12.  12.]]]


          [[[ 11.  11.  12.  13.  13.]
            [ 11.  11.  12.  13.  13.]
            [ 14.  14.  15.  16.  16.]
            [ 14.  14.  15.  16.  16.]]

           [[ 17.  17.  18.  19.  19.]
            [ 17.  17.  18.  19.  19.]
            [ 20.  20.  21.  22.  22.]
            [ 20.  20.  21.  22.  22.]]]]

   pad(x, mode="constant", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =

         [[[[  0.   0.   0.   0.   0.]
            [  0.   1.   2.   3.   0.]
            [  0.   4.   5.   6.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.   7.   8.   9.   0.]
            [  0.  10.  11.  12.   0.]
            [  0.   0.   0.   0.   0.]]]


          [[[  0.   0.   0.   0.   0.]
            [  0.  11.  12.  13.   0.]
            [  0.  14.  15.  16.   0.]
            [  0.   0.   0.   0.   0.]]

           [[  0.   0.   0.   0.   0.]
            [  0.  17.  18.  19.   0.]
            [  0.  20.  21.  22.   0.]
            [  0.   0.   0.   0.   0.]]]]




Defined in src/operator/pad.cc:L766
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#pick" visbl="pub">
<a id="pick(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="pick(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">pick</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@pick(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Picks elements from an input array according to the input indices along the given axis.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the `clip` mode).

This function supports n-dimensional input and (n-1)-dimensional indices arrays.

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // picks elements with specified indices along axis 0
  pick(x, y=[0,1], 0) = [ 1.,  4.]

  // picks elements with specified indices along axis 1
  pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 using 'wrap' mode
  // to place indicies that would normally be out of bounds
  pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 and dims are maintained
  pick(x,y, 1, keepdims=True) = [[ 2.],
                                 [ 3.],
                                 [ 6.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L153
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Picks elements from an input array according to the input indices along the given axis.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the `clip` mode).

This function supports n-dimensional input and (n-1)-dimensional indices arrays.

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // picks elements with specified indices along axis 0
  pick(x, y=[0,1], 0) = [ 1.,  4.]

  // picks elements with specified indices along axis 1
  pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 using 'wrap' mode
  // to place indicies that would normally be out of bounds
  pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 and dims are maintained
  pick(x,y, 1, keepdims=True) = [[ 2.],
                                 [ 3.],
                                 [ 6.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L153
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#pick" visbl="pub">
<a id="pick(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="pick(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">pick</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@pick(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Picks elements from an input array according to the input indices along the given axis.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the `clip` mode).

This function supports n-dimensional input and (n-1)-dimensional indices arrays.

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // picks elements with specified indices along axis 0
  pick(x, y=[0,1], 0) = [ 1.,  4.]

  // picks elements with specified indices along axis 1
  pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 using 'wrap' mode
  // to place indicies that would normally be out of bounds
  pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 and dims are maintained
  pick(x,y, 1, keepdims=True) = [[ 2.],
                                 [ 3.],
                                 [ 6.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L153
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Picks elements from an input array according to the input indices along the given axis.

Given an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be
an output array of shape ``(i0,)`` with::

  output[i] = input[i, indices[i]]

By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the `clip` mode).

This function supports n-dimensional input and (n-1)-dimensional indices arrays.

Examples::

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // picks elements with specified indices along axis 0
  pick(x, y=[0,1], 0) = [ 1.,  4.]

  // picks elements with specified indices along axis 1
  pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 using 'wrap' mode
  // to place indicies that would normally be out of bounds
  pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]

  y = [[ 1.],
       [ 0.],
       [ 2.]]

  // picks elements with specified indices along axis 1 and dims are maintained
  pick(x,y, 1, keepdims=True) = [[ 2.],
                                 [ 3.],
                                 [ 6.]]



Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L153
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#prod" visbl="pub">
<a id="prod(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="prod(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">prod</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@prod(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the product of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the product of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#prod" visbl="pub">
<a id="prod(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="prod(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">prod</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@prod(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the product of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the product of array elements over given axes.

Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L146
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#radians" visbl="pub">
<a id="radians(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="radians(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">radians</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@radians(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts each element of the input array from degrees to radians.

.. math::
   radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]

The storage type of ``radians`` output depends upon the input storage type:

   - radians(default) = default
   - radians(row_sparse) = row_sparse
   - radians(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts each element of the input array from degrees to radians.

.. math::
   radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]

The storage type of ``radians`` output depends upon the input storage type:

   - radians(default) = default
   - radians(row_sparse) = row_sparse
   - radians(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#radians" visbl="pub">
<a id="radians(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="radians(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">radians</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@radians(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts each element of the input array from degrees to radians.

.. math::
   radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]

The storage type of ``radians`` output depends upon the input storage type:

   - radians(default) = default
   - radians(row_sparse) = row_sparse
   - radians(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts each element of the input array from degrees to radians.

.. math::
   radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]

The storage type of ``radians`` output depends upon the input storage type:

   - radians(default) = default
   - radians(row_sparse) = row_sparse
   - radians(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L182
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_exponential" visbl="pub">
<a id="random_exponential(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_exponential(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_exponential</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_exponential(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from an exponential distribution.

Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).

Example::

   exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
                                      [ 0.04146638,  0.31715935]]


Defined in src/operator/random/sample_op.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from an exponential distribution.

Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).

Example::

   exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
                                      [ 0.04146638,  0.31715935]]


Defined in src/operator/random/sample_op.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_exponential" visbl="pub">
<a id="random_exponential(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_exponential(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_exponential</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_exponential(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from an exponential distribution.

Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).

Example::

   exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
                                      [ 0.04146638,  0.31715935]]


Defined in src/operator/random/sample_op.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from an exponential distribution.

Samples are distributed according to an exponential distribution parametrized by *lambda* (rate).

Example::

   exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],
                                      [ 0.04146638,  0.31715935]]


Defined in src/operator/random/sample_op.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_gamma" visbl="pub">
<a id="random_gamma(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_gamma(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_gamma</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_gamma(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a gamma distribution.

Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).

Example::

   gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
                                            [ 3.91697288,  3.65933681]]


Defined in src/operator/random/sample_op.cc:L100
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a gamma distribution.

Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).

Example::

   gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
                                            [ 3.91697288,  3.65933681]]


Defined in src/operator/random/sample_op.cc:L100
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_gamma" visbl="pub">
<a id="random_gamma(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_gamma(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_gamma</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_gamma(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a gamma distribution.

Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).

Example::

   gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
                                            [ 3.91697288,  3.65933681]]


Defined in src/operator/random/sample_op.cc:L100
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a gamma distribution.

Samples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).

Example::

   gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],
                                            [ 3.91697288,  3.65933681]]


Defined in src/operator/random/sample_op.cc:L100
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_generalized_negative_binomial" visbl="pub">
<a id="random_generalized_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_generalized_negative_binomial(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_generalized_negative_binomial</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_generalized_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a generalized negative binomial distribution.

Samples are distributed according to a generalized negative binomial distribution parametrized by
*mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
number of unsuccessful experiments (generalized to real numbers).
Samples will always be returned as a floating point data type.

Example::

   generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
                                                                    [ 6.,  4.]]


Defined in src/operator/random/sample_op.cc:L168
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a generalized negative binomial distribution.

Samples are distributed according to a generalized negative binomial distribution parametrized by
*mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
number of unsuccessful experiments (generalized to real numbers).
Samples will always be returned as a floating point data type.

Example::

   generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
                                                                    [ 6.,  4.]]


Defined in src/operator/random/sample_op.cc:L168
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_generalized_negative_binomial" visbl="pub">
<a id="random_generalized_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_generalized_negative_binomial(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_generalized_negative_binomial</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_generalized_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a generalized negative binomial distribution.

Samples are distributed according to a generalized negative binomial distribution parametrized by
*mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
number of unsuccessful experiments (generalized to real numbers).
Samples will always be returned as a floating point data type.

Example::

   generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
                                                                    [ 6.,  4.]]


Defined in src/operator/random/sample_op.cc:L168
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a generalized negative binomial distribution.

Samples are distributed according to a generalized negative binomial distribution parametrized by
*mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the
number of unsuccessful experiments (generalized to real numbers).
Samples will always be returned as a floating point data type.

Example::

   generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],
                                                                    [ 6.,  4.]]


Defined in src/operator/random/sample_op.cc:L168
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_negative_binomial" visbl="pub">
<a id="random_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_negative_binomial(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_negative_binomial</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a negative binomial distribution.

Samples are distributed according to a negative binomial distribution parametrized by
*k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
Samples will always be returned as a floating point data type.

Example::

   negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
                                                 [ 2.,  5.]]


Defined in src/operator/random/sample_op.cc:L149
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a negative binomial distribution.

Samples are distributed according to a negative binomial distribution parametrized by
*k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
Samples will always be returned as a floating point data type.

Example::

   negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
                                                 [ 2.,  5.]]


Defined in src/operator/random/sample_op.cc:L149
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_negative_binomial" visbl="pub">
<a id="random_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_negative_binomial(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_negative_binomial</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a negative binomial distribution.

Samples are distributed according to a negative binomial distribution parametrized by
*k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
Samples will always be returned as a floating point data type.

Example::

   negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
                                                 [ 2.,  5.]]


Defined in src/operator/random/sample_op.cc:L149
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a negative binomial distribution.

Samples are distributed according to a negative binomial distribution parametrized by
*k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).
Samples will always be returned as a floating point data type.

Example::

   negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],
                                                 [ 2.,  5.]]


Defined in src/operator/random/sample_op.cc:L149
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_normal" visbl="pub">
<a id="random_normal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_normal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_normal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_normal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_normal" visbl="pub">
<a id="random_normal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_normal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_normal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_normal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a normal (Gaussian) distribution.

.. note:: The existing alias ``normal`` is deprecated.

Samples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale* (standard deviation).

Example::

   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],
                                          [-1.23474145,  1.55807114]]


Defined in src/operator/random/sample_op.cc:L85
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_poisson" visbl="pub">
<a id="random_poisson(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_poisson(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_poisson</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_poisson(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a Poisson distribution.

Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
Samples will always be returned as a floating point data type.

Example::

   poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
                                  [ 4.,  6.]]


Defined in src/operator/random/sample_op.cc:L132
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a Poisson distribution.

Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
Samples will always be returned as a floating point data type.

Example::

   poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
                                  [ 4.,  6.]]


Defined in src/operator/random/sample_op.cc:L132
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_poisson" visbl="pub">
<a id="random_poisson(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_poisson(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_poisson</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_poisson(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a Poisson distribution.

Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
Samples will always be returned as a floating point data type.

Example::

   poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
                                  [ 4.,  6.]]


Defined in src/operator/random/sample_op.cc:L132
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a Poisson distribution.

Samples are distributed according to a Poisson distribution parametrized by *lambda* (rate).
Samples will always be returned as a floating point data type.

Example::

   poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],
                                  [ 4.,  6.]]


Defined in src/operator/random/sample_op.cc:L132
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_uniform" visbl="pub">
<a id="random_uniform(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_uniform(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_uniform</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_uniform(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#random_uniform" visbl="pub">
<a id="random_uniform(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="random_uniform(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">random_uniform</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@random_uniform(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ravel_multi_index" visbl="pub">
<a id="ravel_multi_index(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ravel_multi_index(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ravel_multi_index</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ravel_multi_index(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix.

Examples::

   A = [[3,6,6],[4,5,1]]
   ravel(A, shape=(7,6)) = [22,41,37]



Defined in src/operator/tensor/ravel.cc:L41
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix.

Examples::

   A = [[3,6,6],[4,5,1]]
   ravel(A, shape=(7,6)) = [22,41,37]



Defined in src/operator/tensor/ravel.cc:L41
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#ravel_multi_index" visbl="pub">
<a id="ravel_multi_index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="ravel_multi_index(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ravel_multi_index</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ravel_multi_index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix.

Examples::

   A = [[3,6,6],[4,5,1]]
   ravel(A, shape=(7,6)) = [22,41,37]



Defined in src/operator/tensor/ravel.cc:L41
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix.

Examples::

   A = [[3,6,6],[4,5,1]]
   ravel(A, shape=(7,6)) = [22,41,37]



Defined in src/operator/tensor/ravel.cc:L41
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rcbrt" visbl="pub">
<a id="rcbrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rcbrt(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rcbrt</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rcbrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse cube-root value of the input.

.. math::
   rcbrt(x) = 1/\sqrt[3]{x}

Example::

   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L904
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse cube-root value of the input.

.. math::
   rcbrt(x) = 1/\sqrt[3]{x}

Example::

   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L904
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rcbrt" visbl="pub">
<a id="rcbrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rcbrt(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rcbrt</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rcbrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse cube-root value of the input.

.. math::
   rcbrt(x) = 1/\sqrt[3]{x}

Example::

   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L904
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse cube-root value of the input.

.. math::
   rcbrt(x) = 1/\sqrt[3]{x}

Example::

   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L904
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reciprocal" visbl="pub">
<a id="reciprocal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reciprocal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reciprocal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reciprocal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the reciprocal of the argument, element-wise.

Calculates 1/x.

Example::

    reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L644
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the reciprocal of the argument, element-wise.

Calculates 1/x.

Example::

    reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L644
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reciprocal" visbl="pub">
<a id="reciprocal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reciprocal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reciprocal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reciprocal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the reciprocal of the argument, element-wise.

Calculates 1/x.

Example::

    reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L644
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the reciprocal of the argument, element-wise.

Calculates 1/x.

Example::

    reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L644
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#relu" visbl="pub">
<a id="relu(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="relu(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">relu</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@relu(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes rectified linear.

.. math::
   max(features, 0)

The storage type of ``relu`` output depends upon the input storage type:

   - relu(default) = default
   - relu(row_sparse) = row_sparse
   - relu(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes rectified linear.

.. math::
   max(features, 0)

The storage type of ``relu`` output depends upon the input storage type:

   - relu(default) = default
   - relu(row_sparse) = row_sparse
   - relu(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#relu" visbl="pub">
<a id="relu(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="relu(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">relu</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@relu(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes rectified linear.

.. math::
   max(features, 0)

The storage type of ``relu`` output depends upon the input storage type:

   - relu(default) = default
   - relu(row_sparse) = row_sparse
   - relu(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes rectified linear.

.. math::
   max(features, 0)

The storage type of ``relu`` output depends upon the input storage type:

   - relu(default) = default
   - relu(row_sparse) = row_sparse
   - relu(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#repeat" visbl="pub">
<a id="repeat(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="repeat(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">repeat</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@repeat(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Repeats elements of an array.

By default, ``repeat`` flattens the input array into 1-D and then repeats the
elements::

  x = [[ 1, 2],
       [ 3, 4]]

  repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]

The parameter ``axis`` specifies the axis along which to perform repeat::

  repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
                                  [ 3.,  3.,  4.,  4.]]

  repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
                                  [ 1.,  2.],
                                  [ 3.,  4.],
                                  [ 3.,  4.]]

  repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
                                   [ 3.,  3.,  4.,  4.]]



Defined in src/operator/tensor/matrix_op.cc:L691
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Repeats elements of an array.

By default, ``repeat`` flattens the input array into 1-D and then repeats the
elements::

  x = [[ 1, 2],
       [ 3, 4]]

  repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]

The parameter ``axis`` specifies the axis along which to perform repeat::

  repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
                                  [ 3.,  3.,  4.,  4.]]

  repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
                                  [ 1.,  2.],
                                  [ 3.,  4.],
                                  [ 3.,  4.]]

  repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
                                   [ 3.,  3.,  4.,  4.]]



Defined in src/operator/tensor/matrix_op.cc:L691
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#repeat" visbl="pub">
<a id="repeat(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="repeat(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">repeat</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@repeat(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Repeats elements of an array.

By default, ``repeat`` flattens the input array into 1-D and then repeats the
elements::

  x = [[ 1, 2],
       [ 3, 4]]

  repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]

The parameter ``axis`` specifies the axis along which to perform repeat::

  repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
                                  [ 3.,  3.,  4.,  4.]]

  repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
                                  [ 1.,  2.],
                                  [ 3.,  4.],
                                  [ 3.,  4.]]

  repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
                                   [ 3.,  3.,  4.,  4.]]



Defined in src/operator/tensor/matrix_op.cc:L691
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Repeats elements of an array.

By default, ``repeat`` flattens the input array into 1-D and then repeats the
elements::

  x = [[ 1, 2],
       [ 3, 4]]

  repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]

The parameter ``axis`` specifies the axis along which to perform repeat::

  repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],
                                  [ 3.,  3.,  4.,  4.]]

  repeat(x, repeats=2, axis=0) = [[ 1.,  2.],
                                  [ 1.,  2.],
                                  [ 3.,  4.],
                                  [ 3.,  4.]]

  repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],
                                   [ 3.,  3.,  4.,  4.]]



Defined in src/operator/tensor/matrix_op.cc:L691
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reshape" visbl="pub">
<a id="reshape(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reshape(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reshape</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reshape(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reshape" visbl="pub">
<a id="reshape(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reshape(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reshape</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reshape(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reshapes the input array.

.. note:: ``Reshape`` is deprecated, use ``reshape``

Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.

Example::

  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]

Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:

- ``0``  copy this dimension from the input to the output shape.

  Example::

  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)
  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)

- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions
  keeping the size of the new array same as that of the input array.
  At most one dimension of shape can be -1.

  Example::

  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)
  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)
  - input shape = (2,3,4), shape=(-1,), output shape = (24,)

- ``-2`` copy all/remainder of the input dimensions to the output shape.

  Example::

  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)
  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)

- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.

  Example::

  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)
  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)
  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)
  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)

- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).

  Example::

  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)
  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)

If the argument `reverse` is set to 1, then the special values are inferred from right to left.

  Example::

  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)
  - with reverse=1, output shape will be (50,4).



Defined in src/operator/tensor/matrix_op.cc:L169
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reshape_like" visbl="pub">
<a id="reshape_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reshape_like(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reshape_like</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reshape_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.

Returns a **view** of the `lhs` array with a new shape without altering any data.

Example::

  x = [1, 2, 3, 4, 5, 6]
  y = [[0, -4], [3, 2], [2, 2]]
  reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]

More precise control over how dimensions are inherited is achieved by specifying \
slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.

  Examples::

  - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
  - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)

Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.

  Example::

  - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L453
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.

Returns a **view** of the `lhs` array with a new shape without altering any data.

Example::

  x = [1, 2, 3, 4, 5, 6]
  y = [[0, -4], [3, 2], [2, 2]]
  reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]

More precise control over how dimensions are inherited is achieved by specifying \
slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.

  Examples::

  - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
  - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)

Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.

  Example::

  - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L453
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reshape_like" visbl="pub">
<a id="reshape_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reshape_like(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reshape_like</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reshape_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.

Returns a **view** of the `lhs` array with a new shape without altering any data.

Example::

  x = [1, 2, 3, 4, 5, 6]
  y = [[0, -4], [3, 2], [2, 2]]
  reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]

More precise control over how dimensions are inherited is achieved by specifying \
slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.

  Examples::

  - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
  - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)

Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.

  Example::

  - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L453
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.

Returns a **view** of the `lhs` array with a new shape without altering any data.

Example::

  x = [1, 2, 3, 4, 5, 6]
  y = [[0, -4], [3, 2], [2, 2]]
  reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]

More precise control over how dimensions are inherited is achieved by specifying \
slices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \
are reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.

  Examples::

  - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)
  - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)

Negative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.

  Example::

  - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L453
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reverse" visbl="pub">
<a id="reverse(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reverse(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reverse</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reverse(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#reverse" visbl="pub">
<a id="reverse(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="reverse(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">reverse</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@reverse(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Reverses the order of elements along given axis while preserving array shape.

Note: reverse and flip are equivalent. We use reverse in the following examples.

Examples::

  x = [[ 0.,  1.,  2.,  3.,  4.],
       [ 5.,  6.,  7.,  8.,  9.]]

  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],
                        [ 0.,  1.,  2.,  3.,  4.]]

  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],
                        [ 9.,  8.,  7.,  6.,  5.]]


Defined in src/operator/tensor/matrix_op.cc:L793
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rint" visbl="pub">
<a id="rint(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rint(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rint</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rint(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise rounded value to the nearest integer of the input.

.. note::
   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.

Example::

   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]

The storage type of ``rint`` output depends upon the input storage type:

   - rint(default) = default
   - rint(row_sparse) = row_sparse
   - rint(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L725
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise rounded value to the nearest integer of the input.

.. note::
   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.

Example::

   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]

The storage type of ``rint`` output depends upon the input storage type:

   - rint(default) = default
   - rint(row_sparse) = row_sparse
   - rint(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L725
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rint" visbl="pub">
<a id="rint(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rint(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rint</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rint(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise rounded value to the nearest integer of the input.

.. note::
   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.

Example::

   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]

The storage type of ``rint`` output depends upon the input storage type:

   - rint(default) = default
   - rint(row_sparse) = row_sparse
   - rint(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L725
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise rounded value to the nearest integer of the input.

.. note::
   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.
   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.

Example::

   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]

The storage type of ``rint`` output depends upon the input storage type:

   - rint(default) = default
   - rint(row_sparse) = row_sparse
   - rint(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L725
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rmsprop_update" visbl="pub">
<a id="rmsprop_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rmsprop_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rmsprop_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rmsprop_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for `RMSProp` optimizer.

`RMSprop` is a variant of stochastic gradient descent where the gradients are
divided by a cache which grows with the sum of squares of recent gradients?

`RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
each parameter monotonically over the course of training.
While this is analytically motivated for convex optimizations, it may not be ideal
for non-convex problems. `RMSProp` deals with this heuristically by allowing the
learning rates to rebound as the denominator decays over time.

Define the Root Mean Square (RMS) error criterion of the gradient as
:math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.

The :math:`E[g^2]_t` is given by:

.. math::
  E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2

The update step is

.. math::
  \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t

The RMSProp code follows the version in
http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
Tieleman &amp; Hinton, 2012.

Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
:math:`\eta` to be 0.001.



Defined in src/operator/optimizer_op.cc:L553
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for `RMSProp` optimizer.

`RMSprop` is a variant of stochastic gradient descent where the gradients are
divided by a cache which grows with the sum of squares of recent gradients?

`RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
each parameter monotonically over the course of training.
While this is analytically motivated for convex optimizations, it may not be ideal
for non-convex problems. `RMSProp` deals with this heuristically by allowing the
learning rates to rebound as the denominator decays over time.

Define the Root Mean Square (RMS) error criterion of the gradient as
:math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.

The :math:`E[g^2]_t` is given by:

.. math::
  E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2

The update step is

.. math::
  \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t

The RMSProp code follows the version in
http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
Tieleman &amp; Hinton, 2012.

Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
:math:`\eta` to be 0.001.



Defined in src/operator/optimizer_op.cc:L553
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rmsprop_update" visbl="pub">
<a id="rmsprop_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rmsprop_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rmsprop_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rmsprop_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for `RMSProp` optimizer.

`RMSprop` is a variant of stochastic gradient descent where the gradients are
divided by a cache which grows with the sum of squares of recent gradients?

`RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
each parameter monotonically over the course of training.
While this is analytically motivated for convex optimizations, it may not be ideal
for non-convex problems. `RMSProp` deals with this heuristically by allowing the
learning rates to rebound as the denominator decays over time.

Define the Root Mean Square (RMS) error criterion of the gradient as
:math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.

The :math:`E[g^2]_t` is given by:

.. math::
  E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2

The update step is

.. math::
  \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t

The RMSProp code follows the version in
http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
Tieleman &amp; Hinton, 2012.

Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
:math:`\eta` to be 0.001.



Defined in src/operator/optimizer_op.cc:L553
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for `RMSProp` optimizer.

`RMSprop` is a variant of stochastic gradient descent where the gradients are
divided by a cache which grows with the sum of squares of recent gradients?

`RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively
tunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for
each parameter monotonically over the course of training.
While this is analytically motivated for convex optimizations, it may not be ideal
for non-convex problems. `RMSProp` deals with this heuristically by allowing the
learning rates to rebound as the denominator decays over time.

Define the Root Mean Square (RMS) error criterion of the gradient as
:math:`RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}`, where :math:`g` represents
gradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.

The :math:`E[g^2]_t` is given by:

.. math::
  E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2

The update step is

.. math::
  \theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t

The RMSProp code follows the version in
http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf
Tieleman &amp; Hinton, 2012.

Hinton suggests the momentum term :math:`\gamma` to be 0.9 and the learning rate
:math:`\eta` to be 0.001.



Defined in src/operator/optimizer_op.cc:L553
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rmspropalex_update" visbl="pub">
<a id="rmspropalex_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rmspropalex_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rmspropalex_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rmspropalex_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for RMSPropAlex optimizer.

`RMSPropAlex` is non-centered version of `RMSProp`.

Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
:math:`E[g]_t` is the decaying average over past gradient.

.. math::
  E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
  E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
  \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\

The update step is

.. math::
  \theta_{t+1} = \theta_t + \Delta_t

The RMSPropAlex code follows the version in
http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.

Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
to be 0.9 and the learning rate :math:`\eta` to be 0.0001.


Defined in src/operator/optimizer_op.cc:L592
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for RMSPropAlex optimizer.

`RMSPropAlex` is non-centered version of `RMSProp`.

Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
:math:`E[g]_t` is the decaying average over past gradient.

.. math::
  E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
  E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
  \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\

The update step is

.. math::
  \theta_{t+1} = \theta_t + \Delta_t

The RMSPropAlex code follows the version in
http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.

Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
to be 0.9 and the learning rate :math:`\eta` to be 0.0001.


Defined in src/operator/optimizer_op.cc:L592
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rmspropalex_update" visbl="pub">
<a id="rmspropalex_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rmspropalex_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rmspropalex_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rmspropalex_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for RMSPropAlex optimizer.

`RMSPropAlex` is non-centered version of `RMSProp`.

Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
:math:`E[g]_t` is the decaying average over past gradient.

.. math::
  E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
  E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
  \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\

The update step is

.. math::
  \theta_{t+1} = \theta_t + \Delta_t

The RMSPropAlex code follows the version in
http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.

Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
to be 0.9 and the learning rate :math:`\eta` to be 0.0001.


Defined in src/operator/optimizer_op.cc:L592
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for RMSPropAlex optimizer.

`RMSPropAlex` is non-centered version of `RMSProp`.

Define :math:`E[g^2]_t` is the decaying average over past squared gradient and
:math:`E[g]_t` is the decaying average over past gradient.

.. math::
  E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
  E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
  \Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\

The update step is

.. math::
  \theta_{t+1} = \theta_t + \Delta_t

The RMSPropAlex code follows the version in
http://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.

Graves suggests the momentum term :math:`\gamma_1` to be 0.95, :math:`\gamma_2`
to be 0.9 and the learning rate :math:`\eta` to be 0.0001.


Defined in src/operator/optimizer_op.cc:L592
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#round" visbl="pub">
<a id="round(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="round(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">round</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@round(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise rounded value to the nearest integer of the input.

Example::

   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]

The storage type of ``round`` output depends upon the input storage type:

  - round(default) = default
  - round(row_sparse) = row_sparse
  - round(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L704
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise rounded value to the nearest integer of the input.

Example::

   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]

The storage type of ``round`` output depends upon the input storage type:

  - round(default) = default
  - round(row_sparse) = row_sparse
  - round(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L704
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#round" visbl="pub">
<a id="round(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="round(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">round</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@round(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise rounded value to the nearest integer of the input.

Example::

   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]

The storage type of ``round`` output depends upon the input storage type:

  - round(default) = default
  - round(row_sparse) = row_sparse
  - round(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L704
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise rounded value to the nearest integer of the input.

Example::

   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]

The storage type of ``round`` output depends upon the input storage type:

  - round(default) = default
  - round(row_sparse) = row_sparse
  - round(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L704
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rsqrt" visbl="pub">
<a id="rsqrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rsqrt(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rsqrt</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rsqrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse square-root value of the input.

.. math::
   rsqrt(x) = 1/\sqrt{x}

Example::

   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]

The storage type of ``rsqrt`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L864
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse square-root value of the input.

.. math::
   rsqrt(x) = 1/\sqrt{x}

Example::

   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]

The storage type of ``rsqrt`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L864
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#rsqrt" visbl="pub">
<a id="rsqrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="rsqrt(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">rsqrt</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@rsqrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise inverse square-root value of the input.

.. math::
   rsqrt(x) = 1/\sqrt{x}

Example::

   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]

The storage type of ``rsqrt`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L864
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise inverse square-root value of the input.

.. math::
   rsqrt(x) = 1/\sqrt{x}

Example::

   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]

The storage type of ``rsqrt`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L864
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_exponential" visbl="pub">
<a id="sample_exponential(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_exponential(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_exponential</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_exponential(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
exponential distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_exponential(lam) = [ 0.51837951,  0.09994757]

   // Draw a vector containing two samples for each distribution
   sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
                                         [ 0.09994757,  0.50447971]]


Defined in src/operator/random/multisample_op.cc:L284
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
exponential distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_exponential(lam) = [ 0.51837951,  0.09994757]

   // Draw a vector containing two samples for each distribution
   sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
                                         [ 0.09994757,  0.50447971]]


Defined in src/operator/random/multisample_op.cc:L284
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_exponential" visbl="pub">
<a id="sample_exponential(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_exponential(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_exponential</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_exponential(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
exponential distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_exponential(lam) = [ 0.51837951,  0.09994757]

   // Draw a vector containing two samples for each distribution
   sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
                                         [ 0.09994757,  0.50447971]]


Defined in src/operator/random/multisample_op.cc:L284
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
exponential distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_exponential(lam) = [ 0.51837951,  0.09994757]

   // Draw a vector containing two samples for each distribution
   sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],
                                         [ 0.09994757,  0.50447971]]


Defined in src/operator/random/multisample_op.cc:L284
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_gamma" visbl="pub">
<a id="sample_gamma(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_gamma(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_gamma</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_gamma(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
gamma distributions with parameters *alpha* (shape) and *beta* (scale).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   alpha = [ 0.0, 2.5 ]
   beta = [ 1.0, 0.7 ]

   // Draw a single sample for each distribution
   sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]

   // Draw a vector containing two samples for each distribution
   sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
                                           [ 2.25797319,  1.70734084]]


Defined in src/operator/random/multisample_op.cc:L282
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
gamma distributions with parameters *alpha* (shape) and *beta* (scale).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   alpha = [ 0.0, 2.5 ]
   beta = [ 1.0, 0.7 ]

   // Draw a single sample for each distribution
   sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]

   // Draw a vector containing two samples for each distribution
   sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
                                           [ 2.25797319,  1.70734084]]


Defined in src/operator/random/multisample_op.cc:L282
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_gamma" visbl="pub">
<a id="sample_gamma(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_gamma(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_gamma</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_gamma(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
gamma distributions with parameters *alpha* (shape) and *beta* (scale).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   alpha = [ 0.0, 2.5 ]
   beta = [ 1.0, 0.7 ]

   // Draw a single sample for each distribution
   sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]

   // Draw a vector containing two samples for each distribution
   sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
                                           [ 2.25797319,  1.70734084]]


Defined in src/operator/random/multisample_op.cc:L282
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
gamma distributions with parameters *alpha* (shape) and *beta* (scale).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   alpha = [ 0.0, 2.5 ]
   beta = [ 1.0, 0.7 ]

   // Draw a single sample for each distribution
   sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]

   // Draw a vector containing two samples for each distribution
   sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],
                                           [ 2.25797319,  1.70734084]]


Defined in src/operator/random/multisample_op.cc:L282
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_generalized_negative_binomial" visbl="pub">
<a id="sample_generalized_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_generalized_negative_binomial(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_generalized_negative_binomial</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_generalized_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   mu = [ 2.0, 2.5 ]
   alpha = [ 1.0, 0.1 ]

   // Draw a single sample for each distribution
   sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]

   // Draw a vector containing two samples for each distribution
   sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
                                                                 [ 3.,  1.]]


Defined in src/operator/random/multisample_op.cc:L293
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   mu = [ 2.0, 2.5 ]
   alpha = [ 1.0, 0.1 ]

   // Draw a single sample for each distribution
   sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]

   // Draw a vector containing two samples for each distribution
   sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
                                                                 [ 3.,  1.]]


Defined in src/operator/random/multisample_op.cc:L293
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_generalized_negative_binomial" visbl="pub">
<a id="sample_generalized_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_generalized_negative_binomial(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_generalized_negative_binomial</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_generalized_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   mu = [ 2.0, 2.5 ]
   alpha = [ 1.0, 0.1 ]

   // Draw a single sample for each distribution
   sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]

   // Draw a vector containing two samples for each distribution
   sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
                                                                 [ 3.,  1.]]


Defined in src/operator/random/multisample_op.cc:L293
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
generalized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   mu = [ 2.0, 2.5 ]
   alpha = [ 1.0, 0.1 ]

   // Draw a single sample for each distribution
   sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]

   // Draw a vector containing two samples for each distribution
   sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],
                                                                 [ 3.,  1.]]


Defined in src/operator/random/multisample_op.cc:L293
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_multinomial" visbl="pub">
<a id="sample_multinomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_multinomial(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_multinomial</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_multinomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple multinomial distributions.

*data* is an *n* dimensional array whose last dimension has length *k*, where
*k* is the number of possible outcomes of each multinomial distribution. This
operator will draw *shape* samples from each distribution. If shape is empty
one sample will be drawn from each distribution.

If *get_prob* is true, a second array containing log likelihood of the drawn
samples will also be returned. This is usually used for reinforcement learning
where you can provide reward as head gradient for this array to estimate
gradient.

Note that the input distribution must be normalized, i.e. *data* must sum to
1 along its last axis.

Examples::

   probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]

   // Draw a single sample for each distribution
   sample_multinomial(probs) = [3, 0]

   // Draw a vector containing two samples for each distribution
   sample_multinomial(probs, shape=(2)) = [[4, 2],
                                           [0, 0]]

   // requests log likelihood
   sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple multinomial distributions.

*data* is an *n* dimensional array whose last dimension has length *k*, where
*k* is the number of possible outcomes of each multinomial distribution. This
operator will draw *shape* samples from each distribution. If shape is empty
one sample will be drawn from each distribution.

If *get_prob* is true, a second array containing log likelihood of the drawn
samples will also be returned. This is usually used for reinforcement learning
where you can provide reward as head gradient for this array to estimate
gradient.

Note that the input distribution must be normalized, i.e. *data* must sum to
1 along its last axis.

Examples::

   probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]

   // Draw a single sample for each distribution
   sample_multinomial(probs) = [3, 0]

   // Draw a vector containing two samples for each distribution
   sample_multinomial(probs, shape=(2)) = [[4, 2],
                                           [0, 0]]

   // requests log likelihood
   sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_multinomial" visbl="pub">
<a id="sample_multinomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_multinomial(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_multinomial</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_multinomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple multinomial distributions.

*data* is an *n* dimensional array whose last dimension has length *k*, where
*k* is the number of possible outcomes of each multinomial distribution. This
operator will draw *shape* samples from each distribution. If shape is empty
one sample will be drawn from each distribution.

If *get_prob* is true, a second array containing log likelihood of the drawn
samples will also be returned. This is usually used for reinforcement learning
where you can provide reward as head gradient for this array to estimate
gradient.

Note that the input distribution must be normalized, i.e. *data* must sum to
1 along its last axis.

Examples::

   probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]

   // Draw a single sample for each distribution
   sample_multinomial(probs) = [3, 0]

   // Draw a vector containing two samples for each distribution
   sample_multinomial(probs, shape=(2)) = [[4, 2],
                                           [0, 0]]

   // requests log likelihood
   sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple multinomial distributions.

*data* is an *n* dimensional array whose last dimension has length *k*, where
*k* is the number of possible outcomes of each multinomial distribution. This
operator will draw *shape* samples from each distribution. If shape is empty
one sample will be drawn from each distribution.

If *get_prob* is true, a second array containing log likelihood of the drawn
samples will also be returned. This is usually used for reinforcement learning
where you can provide reward as head gradient for this array to estimate
gradient.

Note that the input distribution must be normalized, i.e. *data* must sum to
1 along its last axis.

Examples::

   probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]

   // Draw a single sample for each distribution
   sample_multinomial(probs) = [3, 0]

   // Draw a vector containing two samples for each distribution
   sample_multinomial(probs, shape=(2)) = [[4, 2],
                                           [0, 0]]

   // requests log likelihood
   sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_negative_binomial" visbl="pub">
<a id="sample_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_negative_binomial(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_negative_binomial</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_negative_binomial(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   k = [ 20, 49 ]
   p = [ 0.4 , 0.77 ]

   // Draw a single sample for each distribution
   sample_negative_binomial(k, p) = [ 15.,  16.]

   // Draw a vector containing two samples for each distribution
   sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
                                                [ 16.,  12.]]


Defined in src/operator/random/multisample_op.cc:L289
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   k = [ 20, 49 ]
   p = [ 0.4 , 0.77 ]

   // Draw a single sample for each distribution
   sample_negative_binomial(k, p) = [ 15.,  16.]

   // Draw a vector containing two samples for each distribution
   sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
                                                [ 16.,  12.]]


Defined in src/operator/random/multisample_op.cc:L289
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_negative_binomial" visbl="pub">
<a id="sample_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_negative_binomial(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_negative_binomial</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_negative_binomial(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   k = [ 20, 49 ]
   p = [ 0.4 , 0.77 ]

   // Draw a single sample for each distribution
   sample_negative_binomial(k, p) = [ 15.,  16.]

   // Draw a vector containing two samples for each distribution
   sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
                                                [ 16.,  12.]]


Defined in src/operator/random/multisample_op.cc:L289
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
negative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Samples will always be returned as a floating point data type.

Examples::

   k = [ 20, 49 ]
   p = [ 0.4 , 0.77 ]

   // Draw a single sample for each distribution
   sample_negative_binomial(k, p) = [ 15.,  16.]

   // Draw a vector containing two samples for each distribution
   sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],
                                                [ 16.,  12.]]


Defined in src/operator/random/multisample_op.cc:L289
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_normal" visbl="pub">
<a id="sample_normal(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_normal(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_normal</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_normal(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   mu = [ 0.0, 2.5 ]
   sigma = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_normal(mu, sigma) = [-0.56410581,  0.95934606]

   // Draw a vector containing two samples for each distribution
   sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
                                          [ 0.95934606,  4.48287058]]


Defined in src/operator/random/multisample_op.cc:L279
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   mu = [ 0.0, 2.5 ]
   sigma = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_normal(mu, sigma) = [-0.56410581,  0.95934606]

   // Draw a vector containing two samples for each distribution
   sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
                                          [ 0.95934606,  4.48287058]]


Defined in src/operator/random/multisample_op.cc:L279
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_normal" visbl="pub">
<a id="sample_normal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_normal(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_normal</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_normal(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   mu = [ 0.0, 2.5 ]
   sigma = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_normal(mu, sigma) = [-0.56410581,  0.95934606]

   // Draw a vector containing two samples for each distribution
   sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
                                          [ 0.95934606,  4.48287058]]


Defined in src/operator/random/multisample_op.cc:L279
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
normal distributions with parameters *mu* (mean) and *sigma* (standard deviation).

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   mu = [ 0.0, 2.5 ]
   sigma = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_normal(mu, sigma) = [-0.56410581,  0.95934606]

   // Draw a vector containing two samples for each distribution
   sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],
                                          [ 0.95934606,  4.48287058]]


Defined in src/operator/random/multisample_op.cc:L279
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_poisson" visbl="pub">
<a id="sample_poisson(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_poisson(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_poisson</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_poisson(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
Poisson distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Samples will always be returned as a floating point data type.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_poisson(lam) = [  0.,  13.]

   // Draw a vector containing two samples for each distribution
   sample_poisson(lam, shape=(2)) = [[  0.,   4.],
                                     [ 13.,   8.]]


Defined in src/operator/random/multisample_op.cc:L286
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
Poisson distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Samples will always be returned as a floating point data type.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_poisson(lam) = [  0.,  13.]

   // Draw a vector containing two samples for each distribution
   sample_poisson(lam, shape=(2)) = [[  0.,   4.],
                                     [ 13.,   8.]]


Defined in src/operator/random/multisample_op.cc:L286
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_poisson" visbl="pub">
<a id="sample_poisson(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_poisson(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_poisson</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_poisson(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
Poisson distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Samples will always be returned as a floating point data type.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_poisson(lam) = [  0.,  13.]

   // Draw a vector containing two samples for each distribution
   sample_poisson(lam, shape=(2)) = [[  0.,   4.],
                                     [ 13.,   8.]]


Defined in src/operator/random/multisample_op.cc:L286
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
Poisson distributions with parameters lambda (rate).

The parameters of the distributions are provided as an input array.
Let *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input array, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.

Samples will always be returned as a floating point data type.

Examples::

   lam = [ 1.0, 8.5 ]

   // Draw a single sample for each distribution
   sample_poisson(lam) = [  0.,  13.]

   // Draw a vector containing two samples for each distribution
   sample_poisson(lam, shape=(2)) = [[  0.,   4.],
                                     [ 13.,   8.]]


Defined in src/operator/random/multisample_op.cc:L286
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_uniform" visbl="pub">
<a id="sample_uniform(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_uniform(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_uniform</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_uniform(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
uniform distributions on the intervals given by *[low,high)*.

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   low = [ 0.0, 2.5 ]
   high = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_uniform(low, high) = [ 0.40451524,  3.18687344]

   // Draw a vector containing two samples for each distribution
   sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
                                           [ 3.18687344,  3.68352246]]


Defined in src/operator/random/multisample_op.cc:L277
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
uniform distributions on the intervals given by *[low,high)*.

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   low = [ 0.0, 2.5 ]
   high = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_uniform(low, high) = [ 0.40451524,  3.18687344]

   // Draw a vector containing two samples for each distribution
   sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
                                           [ 3.18687344,  3.68352246]]


Defined in src/operator/random/multisample_op.cc:L277
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sample_uniform" visbl="pub">
<a id="sample_uniform(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sample_uniform(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sample_uniform</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sample_uniform(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Concurrent sampling from multiple
uniform distributions on the intervals given by *[low,high)*.

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   low = [ 0.0, 2.5 ]
   high = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_uniform(low, high) = [ 0.40451524,  3.18687344]

   // Draw a vector containing two samples for each distribution
   sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
                                           [ 3.18687344,  3.68352246]]


Defined in src/operator/random/multisample_op.cc:L277
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Concurrent sampling from multiple
uniform distributions on the intervals given by *[low,high)*.

The parameters of the distributions are provided as input arrays.
Let *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*
be the shape specified as the parameter of the operator, and *m* be the dimension
of *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.

For any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*
will be an *m*-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index *i*. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.

Examples::

   low = [ 0.0, 2.5 ]
   high = [ 1.0, 3.7 ]

   // Draw a single sample for each distribution
   sample_uniform(low, high) = [ 0.40451524,  3.18687344]

   // Draw a vector containing two samples for each distribution
   sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],
                                           [ 3.18687344,  3.68352246]]


Defined in src/operator/random/multisample_op.cc:L277
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#scatter_nd" visbl="pub">
<a id="scatter_nd(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="scatter_nd(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">scatter_nd</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@scatter_nd(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Scatters data into a new tensor according to indices.

Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[indices[0, y_0, ..., y_{K-1}],
         ...,
         indices[M-1, y_0, ..., y_{K-1}],
         x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]

all other entries in output are 0.

.. warning::

    If the indices have duplicates, the result will be non-deterministic and
    the gradient of `scatter_nd` will not be correct!!


Examples::

  data = [2, 3, 0]
  indices = [[1, 1, 0], [0, 1, 0]]
  shape = (2, 2)
  scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 1]]
  shape = (2, 2, 2, 2)
  scatter_nd(data, indices, shape) = [[[[0, 0],
                                        [0, 0]],

                                       [[1, 2],
                                        [3, 4]]],

                                      [[[0, 0],
                                        [0, 0]],

                                       [[5, 6],
                                        [7, 8]]]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Scatters data into a new tensor according to indices.

Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[indices[0, y_0, ..., y_{K-1}],
         ...,
         indices[M-1, y_0, ..., y_{K-1}],
         x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]

all other entries in output are 0.

.. warning::

    If the indices have duplicates, the result will be non-deterministic and
    the gradient of `scatter_nd` will not be correct!!


Examples::

  data = [2, 3, 0]
  indices = [[1, 1, 0], [0, 1, 0]]
  shape = (2, 2)
  scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 1]]
  shape = (2, 2, 2, 2)
  scatter_nd(data, indices, shape) = [[[[0, 0],
                                        [0, 0]],

                                       [[1, 2],
                                        [3, 4]]],

                                      [[[0, 0],
                                        [0, 0]],

                                       [[5, 6],
                                        [7, 8]]]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#scatter_nd" visbl="pub">
<a id="scatter_nd(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="scatter_nd(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">scatter_nd</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@scatter_nd(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Scatters data into a new tensor according to indices.

Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[indices[0, y_0, ..., y_{K-1}],
         ...,
         indices[M-1, y_0, ..., y_{K-1}],
         x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]

all other entries in output are 0.

.. warning::

    If the indices have duplicates, the result will be non-deterministic and
    the gradient of `scatter_nd` will not be correct!!


Examples::

  data = [2, 3, 0]
  indices = [[1, 1, 0], [0, 1, 0]]
  shape = (2, 2)
  scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 1]]
  shape = (2, 2, 2, 2)
  scatter_nd(data, indices, shape) = [[[[0, 0],
                                        [0, 0]],

                                       [[1, 2],
                                        [3, 4]]],

                                      [[[0, 0],
                                        [0, 0]],

                                       [[5, 6],
                                        [7, 8]]]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Scatters data into a new tensor according to indices.

Given `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape
`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,
where `M &lt;= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.

The elements in output is defined as follows::

  output[indices[0, y_0, ..., y_{K-1}],
         ...,
         indices[M-1, y_0, ..., y_{K-1}],
         x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]

all other entries in output are 0.

.. warning::

    If the indices have duplicates, the result will be non-deterministic and
    the gradient of `scatter_nd` will not be correct!!


Examples::

  data = [2, 3, 0]
  indices = [[1, 1, 0], [0, 1, 0]]
  shape = (2, 2)
  scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]

  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
  indices = [[0, 1], [1, 1]]
  shape = (2, 2, 2, 2)
  scatter_nd(data, indices, shape) = [[[[0, 0],
                                        [0, 0]],

                                       [[1, 2],
                                        [3, 4]]],

                                      [[[0, 0],
                                        [0, 0]],

                                       [[5, 6],
                                        [7, 8]]]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sgd_mom_update" visbl="pub">
<a id="sgd_mom_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sgd_mom_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sgd_mom_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sgd_mom_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Momentum update function for Stochastic Gradient Descent (SGD) optimizer.

Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:

.. math::

  v_1 = \alpha * \nabla J(W_0)\\
  v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
  W_t = W_{t-1} + v_t

It updates the weights using::

  v = momentum * v - learning_rate * gradient
  weight += v

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and weight's storage
type is the same as momentum's storage type,
only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::

  for row in gradient.indices:
      v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
      weight[row] += v[row]



Defined in src/operator/optimizer_op.cc:L372
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Momentum update function for Stochastic Gradient Descent (SGD) optimizer.

Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:

.. math::

  v_1 = \alpha * \nabla J(W_0)\\
  v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
  W_t = W_{t-1} + v_t

It updates the weights using::

  v = momentum * v - learning_rate * gradient
  weight += v

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and weight's storage
type is the same as momentum's storage type,
only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::

  for row in gradient.indices:
      v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
      weight[row] += v[row]



Defined in src/operator/optimizer_op.cc:L372
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sgd_mom_update" visbl="pub">
<a id="sgd_mom_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sgd_mom_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sgd_mom_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sgd_mom_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Momentum update function for Stochastic Gradient Descent (SGD) optimizer.

Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:

.. math::

  v_1 = \alpha * \nabla J(W_0)\\
  v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
  W_t = W_{t-1} + v_t

It updates the weights using::

  v = momentum * v - learning_rate * gradient
  weight += v

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and weight's storage
type is the same as momentum's storage type,
only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::

  for row in gradient.indices:
      v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
      weight[row] += v[row]



Defined in src/operator/optimizer_op.cc:L372
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Momentum update function for Stochastic Gradient Descent (SGD) optimizer.

Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:

.. math::

  v_1 = \alpha * \nabla J(W_0)\\
  v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
  W_t = W_{t-1} + v_t

It updates the weights using::

  v = momentum * v - learning_rate * gradient
  weight += v

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

However, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and weight's storage
type is the same as momentum's storage type,
only the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::

  for row in gradient.indices:
      v[row] = momentum[row] * v[row] - learning_rate * gradient[row]
      weight[row] += v[row]



Defined in src/operator/optimizer_op.cc:L372
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sgd_update" visbl="pub">
<a id="sgd_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sgd_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sgd_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sgd_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for Stochastic Gradient Descent (SDG) optimizer.

It updates the weights using::

 weight = weight - learning_rate * (gradient + wd * weight)

However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
only the row slices whose indices appear in grad.indices are updated::

 for row in gradient.indices:
     weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])



Defined in src/operator/optimizer_op.cc:L331
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for Stochastic Gradient Descent (SDG) optimizer.

It updates the weights using::

 weight = weight - learning_rate * (gradient + wd * weight)

However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
only the row slices whose indices appear in grad.indices are updated::

 for row in gradient.indices:
     weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])



Defined in src/operator/optimizer_op.cc:L331
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sgd_update" visbl="pub">
<a id="sgd_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sgd_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sgd_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sgd_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for Stochastic Gradient Descent (SDG) optimizer.

It updates the weights using::

 weight = weight - learning_rate * (gradient + wd * weight)

However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
only the row slices whose indices appear in grad.indices are updated::

 for row in gradient.indices:
     weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])



Defined in src/operator/optimizer_op.cc:L331
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for Stochastic Gradient Descent (SDG) optimizer.

It updates the weights using::

 weight = weight - learning_rate * (gradient + wd * weight)

However, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,
only the row slices whose indices appear in grad.indices are updated::

 for row in gradient.indices:
     weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])



Defined in src/operator/optimizer_op.cc:L331
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#shape_array" visbl="pub">
<a id="shape_array(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="shape_array(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">shape_array</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@shape_array(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a 1D int64 array containing the shape of data.

Example::

  shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L503
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a 1D int64 array containing the shape of data.

Example::

  shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L503
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#shape_array" visbl="pub">
<a id="shape_array(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="shape_array(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">shape_array</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@shape_array(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a 1D int64 array containing the shape of data.

Example::

  shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L503
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a 1D int64 array containing the shape of data.

Example::

  shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L503
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#shuffle" visbl="pub">
<a id="shuffle(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="shuffle(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">shuffle</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@shuffle(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Randomly shuffle the elements.

This shuffles the array along the first axis.
The order of the elements in each subarray does not change.
For example, if a 2D array is given, the order of the rows randomly changes,
but the order of the elements in each row does not change.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Randomly shuffle the elements.

This shuffles the array along the first axis.
The order of the elements in each subarray does not change.
For example, if a 2D array is given, the order of the rows randomly changes,
but the order of the elements in each row does not change.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#shuffle" visbl="pub">
<a id="shuffle(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="shuffle(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">shuffle</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@shuffle(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Randomly shuffle the elements.

This shuffles the array along the first axis.
The order of the elements in each subarray does not change.
For example, if a 2D array is given, the order of the rows randomly changes,
but the order of the elements in each row does not change.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Randomly shuffle the elements.

This shuffles the array along the first axis.
The order of the elements in each subarray does not change.
For example, if a 2D array is given, the order of the rows randomly changes,
but the order of the elements in each row does not change.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sigmoid" visbl="pub">
<a id="sigmoid(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sigmoid(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sigmoid</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sigmoid(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes sigmoid of x element-wise.

.. math::
   y = 1 / (1 + exp(-x))

The storage type of ``sigmoid`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L101
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes sigmoid of x element-wise.

.. math::
   y = 1 / (1 + exp(-x))

The storage type of ``sigmoid`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L101
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sigmoid" visbl="pub">
<a id="sigmoid(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sigmoid(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sigmoid</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sigmoid(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes sigmoid of x element-wise.

.. math::
   y = 1 / (1 + exp(-x))

The storage type of ``sigmoid`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L101
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes sigmoid of x element-wise.

.. math::
   y = 1 / (1 + exp(-x))

The storage type of ``sigmoid`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L101
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sign" visbl="pub">
<a id="sign(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sign(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sign</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sign(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise sign of the input.

Example::

   sign([-2, 0, 3]) = [-1, 0, 1]

The storage type of ``sign`` output depends upon the input storage type:

   - sign(default) = default
   - sign(row_sparse) = row_sparse
   - sign(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L685
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise sign of the input.

Example::

   sign([-2, 0, 3]) = [-1, 0, 1]

The storage type of ``sign`` output depends upon the input storage type:

   - sign(default) = default
   - sign(row_sparse) = row_sparse
   - sign(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L685
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sign" visbl="pub">
<a id="sign(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sign(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sign</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sign(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise sign of the input.

Example::

   sign([-2, 0, 3]) = [-1, 0, 1]

The storage type of ``sign`` output depends upon the input storage type:

   - sign(default) = default
   - sign(row_sparse) = row_sparse
   - sign(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L685
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise sign of the input.

Example::

   sign([-2, 0, 3]) = [-1, 0, 1]

The storage type of ``sign`` output depends upon the input storage type:

   - sign(default) = default
   - sign(row_sparse) = row_sparse
   - sign(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L685
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#signsgd_update" visbl="pub">
<a id="signsgd_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="signsgd_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">signsgd_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@signsgd_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for SignSGD optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 W_t = W_{t-1} - \eta_t \text{sign}(g_t)

It updates the weights using::

 weight = weight - learning_rate * sign(gradient)

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L57
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for SignSGD optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 W_t = W_{t-1} - \eta_t \text{sign}(g_t)

It updates the weights using::

 weight = weight - learning_rate * sign(gradient)

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L57
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#signsgd_update" visbl="pub">
<a id="signsgd_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="signsgd_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">signsgd_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@signsgd_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Update function for SignSGD optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 W_t = W_{t-1} - \eta_t \text{sign}(g_t)

It updates the weights using::

 weight = weight - learning_rate * sign(gradient)

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L57
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Update function for SignSGD optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 W_t = W_{t-1} - \eta_t \text{sign}(g_t)

It updates the weights using::

 weight = weight - learning_rate * sign(gradient)

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L57
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#signum_update" visbl="pub">
<a id="signum_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="signum_update(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">signum_update</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@signum_update(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
SIGN momentUM (Signum) optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta m_{t-1} + (1 - \beta) g_t\\
 W_t = W_{t-1} - \eta_t \text{sign}(m_t)

It updates the weights using::
 state = momentum * state + (1-momentum) * gradient
 weight = weight - learning_rate * sign(state)

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L86
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
SIGN momentUM (Signum) optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta m_{t-1} + (1 - \beta) g_t\\
 W_t = W_{t-1} - \eta_t \text{sign}(m_t)

It updates the weights using::
 state = momentum * state + (1-momentum) * gradient
 weight = weight - learning_rate * sign(state)

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L86
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#signum_update" visbl="pub">
<a id="signum_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="signum_update(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">signum_update</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@signum_update(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
SIGN momentUM (Signum) optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta m_{t-1} + (1 - \beta) g_t\\
 W_t = W_{t-1} - \eta_t \text{sign}(m_t)

It updates the weights using::
 state = momentum * state + (1-momentum) * gradient
 weight = weight - learning_rate * sign(state)

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L86
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
SIGN momentUM (Signum) optimizer.

.. math::

 g_t = \nabla J(W_{t-1})\\
 m_t = \beta m_{t-1} + (1 - \beta) g_t\\
 W_t = W_{t-1} - \eta_t \text{sign}(m_t)

It updates the weights using::
 state = momentum * state + (1-momentum) * gradient
 weight = weight - learning_rate * sign(state)

Where the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.

.. note::
   - sparse ndarray not supported for this optimizer yet.


Defined in src/operator/optimizer_op.cc:L86
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sin" visbl="pub">
<a id="sin(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sin(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sin</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sin(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the element-wise sine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]

The storage type of ``sin`` output depends upon the input storage type:

   - sin(default) = default
   - sin(row_sparse) = row_sparse
   - sin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the element-wise sine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]

The storage type of ``sin`` output depends upon the input storage type:

   - sin(default) = default
   - sin(row_sparse) = row_sparse
   - sin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sin" visbl="pub">
<a id="sin(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sin(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sin</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sin(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the element-wise sine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]

The storage type of ``sin`` output depends upon the input storage type:

   - sin(default) = default
   - sin(row_sparse) = row_sparse
   - sin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the element-wise sine of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]

The storage type of ``sin`` output depends upon the input storage type:

   - sin(default) = default
   - sin(row_sparse) = row_sparse
   - sin(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sinh" visbl="pub">
<a id="sinh(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sinh(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sinh</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sinh(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the hyperbolic sine of the input array, computed element-wise.

.. math::
   sinh(x) = 0.5\times(exp(x) - exp(-x))

The storage type of ``sinh`` output depends upon the input storage type:

   - sinh(default) = default
   - sinh(row_sparse) = row_sparse
   - sinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the hyperbolic sine of the input array, computed element-wise.

.. math::
   sinh(x) = 0.5\times(exp(x) - exp(-x))

The storage type of ``sinh`` output depends upon the input storage type:

   - sinh(default) = default
   - sinh(row_sparse) = row_sparse
   - sinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sinh" visbl="pub">
<a id="sinh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sinh(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sinh</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sinh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the hyperbolic sine of the input array, computed element-wise.

.. math::
   sinh(x) = 0.5\times(exp(x) - exp(-x))

The storage type of ``sinh`` output depends upon the input storage type:

   - sinh(default) = default
   - sinh(row_sparse) = row_sparse
   - sinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the hyperbolic sine of the input array, computed element-wise.

.. math::
   sinh(x) = 0.5\times(exp(x) - exp(-x))

The storage type of ``sinh`` output depends upon the input storage type:

   - sinh(default) = default
   - sinh(row_sparse) = row_sparse
   - sinh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L201
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#size_array" visbl="pub">
<a id="size_array(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="size_array(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">size_array</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@size_array(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a 1D int64 array containing the size of data.

Example::

  size_array([[1,2,3,4], [5,6,7,8]]) = [8]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L554
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a 1D int64 array containing the size of data.

Example::

  size_array([[1,2,3,4], [5,6,7,8]]) = [8]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L554
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#size_array" visbl="pub">
<a id="size_array(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="size_array(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">size_array</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@size_array(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a 1D int64 array containing the size of data.

Example::

  size_array([[1,2,3,4], [5,6,7,8]]) = [8]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L554
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a 1D int64 array containing the size of data.

Example::

  size_array([[1,2,3,4], [5,6,7,8]]) = [8]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L554
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#slice" visbl="pub">
<a id="slice(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="slice(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">slice</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@slice(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#slice" visbl="pub">
<a id="slice(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="slice(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">slice</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@slice(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices a region of the array.

.. note:: ``crop`` is deprecated. Use ``slice`` instead.

This function returns a sliced array between the indices given
by `begin` and `end` with the corresponding `step`.

For an input array of ``shape=(d_0, d_1, ..., d_n-1)``,
slice operation with ``begin=(b_0, b_1...b_m-1)``,
``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,
where m &lt;= n, results in an array with the shape
``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.

The resulting array's *k*-th dimension contains elements
from the *k*-th dimension of the input array starting
from index ``b_k`` (inclusive) with step ``s_k``
until reaching ``e_k`` (exclusive).

If the *k*-th elements are `None` in the sequence of `begin`, `end`,
and `step`, the following rule will be used to set default values.
If `s_k` is `None`, set `s_k=1`. If `s_k &gt; 0`, set `b_k=0`, `e_k=d_k`;
else, set `b_k=d_k-1`, `e_k=-1`.

The storage type of ``slice`` output depends on storage types of inputs

- slice(csr) = csr
- otherwise, ``slice`` generates output with default storage

.. note:: When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],
                                     [ 6.,  7.,  8.]]
  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],
                                                            [5.,  7.],
                                                            [1.,  3.]]


Defined in src/operator/tensor/matrix_op.cc:L413
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#slice_axis" visbl="pub">
<a id="slice_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="slice_axis(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">slice_axis</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@slice_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices along a given axis.

Returns an array slice along a given `axis` starting from the `begin` index
to the `end` index.

Examples::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
                                           [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
                                           [  5.,   6.],
                                           [  9.,  10.]]

  slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
                                             [  6.,   7.],
                                             [ 10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L500
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices along a given axis.

Returns an array slice along a given `axis` starting from the `begin` index
to the `end` index.

Examples::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
                                           [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
                                           [  5.,   6.],
                                           [  9.,  10.]]

  slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
                                             [  6.,   7.],
                                             [ 10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L500
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#slice_axis" visbl="pub">
<a id="slice_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="slice_axis(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">slice_axis</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@slice_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices along a given axis.

Returns an array slice along a given `axis` starting from the `begin` index
to the `end` index.

Examples::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
                                           [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
                                           [  5.,   6.],
                                           [  9.,  10.]]

  slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
                                             [  6.,   7.],
                                             [ 10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L500
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices along a given axis.

Returns an array slice along a given `axis` starting from the `begin` index
to the `end` index.

Examples::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],
                                           [  9.,  10.,  11.,  12.]]

  slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],
                                           [  5.,   6.],
                                           [  9.,  10.]]

  slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],
                                             [  6.,   7.],
                                             [ 10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L500
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#slice_like" visbl="pub">
<a id="slice_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="slice_like(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">slice_like</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@slice_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices a region of the array like the shape of another array.

This function is similar to ``slice``, however, the `begin` are always `0`s
and `end` of specific axes are inferred from the second input `shape_like`.

Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
a ``slice_like`` operator with default empty `axes`, it performs the
following operation:

`` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.

When `axes` is not empty, it is used to speficy which axes are being sliced.

Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
will perform the following operation:

`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.

Note that it is allowed to have first and second input with different dimensions,
however, you have to make sure the `axes` are specified and not exceeding the
dimension limits.

For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
``shape=(1,2,3)``, it is not allowed to use:

`` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
is 3.

The following is allowed in this situation:

`` out = slice_like(a, b, axes=(0, 2))``

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  y = [[  0.,   0.,   0.],
       [  0.,   0.,   0.]]

  slice_like(x, y) = [[ 1.,  2.,  3.]
                      [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
                                   [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
                                [ 5.,  6.,  7.,  8.]]
  slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
                                 [  5.,   6.,   7.]
                                 [  9.,  10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L569
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices a region of the array like the shape of another array.

This function is similar to ``slice``, however, the `begin` are always `0`s
and `end` of specific axes are inferred from the second input `shape_like`.

Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
a ``slice_like`` operator with default empty `axes`, it performs the
following operation:

`` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.

When `axes` is not empty, it is used to speficy which axes are being sliced.

Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
will perform the following operation:

`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.

Note that it is allowed to have first and second input with different dimensions,
however, you have to make sure the `axes` are specified and not exceeding the
dimension limits.

For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
``shape=(1,2,3)``, it is not allowed to use:

`` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
is 3.

The following is allowed in this situation:

`` out = slice_like(a, b, axes=(0, 2))``

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  y = [[  0.,   0.,   0.],
       [  0.,   0.,   0.]]

  slice_like(x, y) = [[ 1.,  2.,  3.]
                      [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
                                   [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
                                [ 5.,  6.,  7.,  8.]]
  slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
                                 [  5.,   6.,   7.]
                                 [  9.,  10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L569
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#slice_like" visbl="pub">
<a id="slice_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="slice_like(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">slice_like</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@slice_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Slices a region of the array like the shape of another array.

This function is similar to ``slice``, however, the `begin` are always `0`s
and `end` of specific axes are inferred from the second input `shape_like`.

Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
a ``slice_like`` operator with default empty `axes`, it performs the
following operation:

`` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.

When `axes` is not empty, it is used to speficy which axes are being sliced.

Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
will perform the following operation:

`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.

Note that it is allowed to have first and second input with different dimensions,
however, you have to make sure the `axes` are specified and not exceeding the
dimension limits.

For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
``shape=(1,2,3)``, it is not allowed to use:

`` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
is 3.

The following is allowed in this situation:

`` out = slice_like(a, b, axes=(0, 2))``

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  y = [[  0.,   0.,   0.],
       [  0.,   0.,   0.]]

  slice_like(x, y) = [[ 1.,  2.,  3.]
                      [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
                                   [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
                                [ 5.,  6.,  7.,  8.]]
  slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
                                 [  5.,   6.,   7.]
                                 [  9.,  10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L569
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Slices a region of the array like the shape of another array.

This function is similar to ``slice``, however, the `begin` are always `0`s
and `end` of specific axes are inferred from the second input `shape_like`.

Given the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,
a ``slice_like`` operator with default empty `axes`, it performs the
following operation:

`` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.

When `axes` is not empty, it is used to speficy which axes are being sliced.

Given a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``
will perform the following operation:

`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.

Note that it is allowed to have first and second input with different dimensions,
however, you have to make sure the `axes` are specified and not exceeding the
dimension limits.

For example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with
``shape=(1,2,3)``, it is not allowed to use:

`` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`
is 3.

The following is allowed in this situation:

`` out = slice_like(a, b, axes=(0, 2))``

Example::

  x = [[  1.,   2.,   3.,   4.],
       [  5.,   6.,   7.,   8.],
       [  9.,  10.,  11.,  12.]]

  y = [[  0.,   0.,   0.],
       [  0.,   0.,   0.]]

  slice_like(x, y) = [[ 1.,  2.,  3.]
                      [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]
                                   [ 5.,  6.,  7.]]
  slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]
                                [ 5.,  6.,  7.,  8.]]
  slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]
                                 [  5.,   6.,   7.]
                                 [  9.,  10.,  11.]]


Defined in src/operator/tensor/matrix_op.cc:L569
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#smooth_l1" visbl="pub">
<a id="smooth_l1(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="smooth_l1(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">smooth_l1</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@smooth_l1(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Calculate Smooth L1 Loss(lhs, scalar) by summing

.. math::

    f(x) =
    \begin{cases}
    (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    |x|-0.5/\sigma^2,&amp; \text{otherwise}
    \end{cases}

where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.

Example::

  smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]



Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Calculate Smooth L1 Loss(lhs, scalar) by summing

.. math::

    f(x) =
    \begin{cases}
    (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    |x|-0.5/\sigma^2,&amp; \text{otherwise}
    \end{cases}

where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.

Example::

  smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]



Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#smooth_l1" visbl="pub">
<a id="smooth_l1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="smooth_l1(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">smooth_l1</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@smooth_l1(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Calculate Smooth L1 Loss(lhs, scalar) by summing

.. math::

    f(x) =
    \begin{cases}
    (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    |x|-0.5/\sigma^2,&amp; \text{otherwise}
    \end{cases}

where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.

Example::

  smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]



Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Calculate Smooth L1 Loss(lhs, scalar) by summing

.. math::

    f(x) =
    \begin{cases}
    (\sigma x)^2/2,&amp; \text{if }x &lt; 1/\sigma^2\\
    |x|-0.5/\sigma^2,&amp; \text{otherwise}
    \end{cases}

where :math:`x` is an element of the tensor *lhs* and :math:`\sigma` is the scalar.

Example::

  smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]



Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L103
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#softmax" visbl="pub">
<a id="softmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="softmax(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">softmax</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@softmax(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies the softmax function.

The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.

.. math::
   softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}

for :math:`j = 1, ..., K`

t is the temperature parameter in softmax function. By default, t equals 1.0

Example::

  x = [[ 1.  1.  1.]
       [ 1.  1.  1.]]

  softmax(x,axis=0) = [[ 0.5  0.5  0.5]
                       [ 0.5  0.5  0.5]]

  softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
                       [ 0.33333334,  0.33333334,  0.33333334]]



Defined in src/operator/nn/softmax.cc:L100
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies the softmax function.

The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.

.. math::
   softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}

for :math:`j = 1, ..., K`

t is the temperature parameter in softmax function. By default, t equals 1.0

Example::

  x = [[ 1.  1.  1.]
       [ 1.  1.  1.]]

  softmax(x,axis=0) = [[ 0.5  0.5  0.5]
                       [ 0.5  0.5  0.5]]

  softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
                       [ 0.33333334,  0.33333334,  0.33333334]]



Defined in src/operator/nn/softmax.cc:L100
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#softmax" visbl="pub">
<a id="softmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="softmax(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">softmax</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@softmax(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Applies the softmax function.

The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.

.. math::
   softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}

for :math:`j = 1, ..., K`

t is the temperature parameter in softmax function. By default, t equals 1.0

Example::

  x = [[ 1.  1.  1.]
       [ 1.  1.  1.]]

  softmax(x,axis=0) = [[ 0.5  0.5  0.5]
                       [ 0.5  0.5  0.5]]

  softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
                       [ 0.33333334,  0.33333334,  0.33333334]]



Defined in src/operator/nn/softmax.cc:L100
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Applies the softmax function.

The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.

.. math::
   softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}

for :math:`j = 1, ..., K`

t is the temperature parameter in softmax function. By default, t equals 1.0

Example::

  x = [[ 1.  1.  1.]
       [ 1.  1.  1.]]

  softmax(x,axis=0) = [[ 0.5  0.5  0.5]
                       [ 0.5  0.5  0.5]]

  softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],
                       [ 0.33333334,  0.33333334,  0.33333334]]



Defined in src/operator/nn/softmax.cc:L100
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#softmax_cross_entropy" visbl="pub">
<a id="softmax_cross_entropy(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="softmax_cross_entropy(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">softmax_cross_entropy</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@softmax_cross_entropy(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Calculate cross entropy of softmax output and one-hot label.

- This operator computes the cross entropy in two steps:
  - Applies softmax function on the input array.
  - Computes and returns the cross entropy loss between the softmax output and the labels.

- The softmax function and cross entropy loss is given by:

  - Softmax Function:

  .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

  .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

Example::

  x = [[1, 2, 3],
       [11, 7, 5]]

  label = [2, 0]

  softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
                [0.97962922, 0.01794253, 0.00242826]]

  softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871



Defined in src/operator/loss_binary_op.cc:L59
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Calculate cross entropy of softmax output and one-hot label.

- This operator computes the cross entropy in two steps:
  - Applies softmax function on the input array.
  - Computes and returns the cross entropy loss between the softmax output and the labels.

- The softmax function and cross entropy loss is given by:

  - Softmax Function:

  .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

  .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

Example::

  x = [[1, 2, 3],
       [11, 7, 5]]

  label = [2, 0]

  softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
                [0.97962922, 0.01794253, 0.00242826]]

  softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871



Defined in src/operator/loss_binary_op.cc:L59
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#softmax_cross_entropy" visbl="pub">
<a id="softmax_cross_entropy(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="softmax_cross_entropy(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">softmax_cross_entropy</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@softmax_cross_entropy(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Calculate cross entropy of softmax output and one-hot label.

- This operator computes the cross entropy in two steps:
  - Applies softmax function on the input array.
  - Computes and returns the cross entropy loss between the softmax output and the labels.

- The softmax function and cross entropy loss is given by:

  - Softmax Function:

  .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

  .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

Example::

  x = [[1, 2, 3],
       [11, 7, 5]]

  label = [2, 0]

  softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
                [0.97962922, 0.01794253, 0.00242826]]

  softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871



Defined in src/operator/loss_binary_op.cc:L59
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Calculate cross entropy of softmax output and one-hot label.

- This operator computes the cross entropy in two steps:
  - Applies softmax function on the input array.
  - Computes and returns the cross entropy loss between the softmax output and the labels.

- The softmax function and cross entropy loss is given by:

  - Softmax Function:

  .. math:: \text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}

  - Cross Entropy Function:

  .. math:: \text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)

Example::

  x = [[1, 2, 3],
       [11, 7, 5]]

  label = [2, 0]

  softmax(x) = [[0.09003057, 0.24472848, 0.66524094],
                [0.97962922, 0.01794253, 0.00242826]]

  softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871



Defined in src/operator/loss_binary_op.cc:L59
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#softsign" visbl="pub">
<a id="softsign(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="softsign(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">softsign</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@softsign(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes softsign of x element-wise.

.. math::
   y = x / (1 + abs(x))

The storage type of ``softsign`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L145
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes softsign of x element-wise.

.. math::
   y = x / (1 + abs(x))

The storage type of ``softsign`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L145
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#softsign" visbl="pub">
<a id="softsign(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="softsign(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">softsign</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@softsign(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes softsign of x element-wise.

.. math::
   y = x / (1 + abs(x))

The storage type of ``softsign`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L145
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes softsign of x element-wise.

.. math::
   y = x / (1 + abs(x))

The storage type of ``softsign`` output is always dense



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L145
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sort" visbl="pub">
<a id="sort(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sort(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sort</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sort(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a sorted copy of an input array along the given axis.

Examples::

  x = [[ 1, 4],
       [ 3, 1]]

  // sorts along the last axis
  sort(x) = [[ 1.,  4.],
             [ 1.,  3.]]

  // flattens and then sorts
  sort(x) = [ 1.,  1.,  3.,  4.]

  // sorts along the first axis
  sort(x, axis=0) = [[ 1.,  1.],
                     [ 3.,  4.]]

  // in a descend order
  sort(x, is_ascend=0) = [[ 4.,  1.],
                          [ 3.,  1.]]



Defined in src/operator/tensor/ordering_op.cc:L126
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a sorted copy of an input array along the given axis.

Examples::

  x = [[ 1, 4],
       [ 3, 1]]

  // sorts along the last axis
  sort(x) = [[ 1.,  4.],
             [ 1.,  3.]]

  // flattens and then sorts
  sort(x) = [ 1.,  1.,  3.,  4.]

  // sorts along the first axis
  sort(x, axis=0) = [[ 1.,  1.],
                     [ 3.,  4.]]

  // in a descend order
  sort(x, is_ascend=0) = [[ 4.,  1.],
                          [ 3.,  1.]]



Defined in src/operator/tensor/ordering_op.cc:L126
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sort" visbl="pub">
<a id="sort(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sort(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sort</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sort(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns a sorted copy of an input array along the given axis.

Examples::

  x = [[ 1, 4],
       [ 3, 1]]

  // sorts along the last axis
  sort(x) = [[ 1.,  4.],
             [ 1.,  3.]]

  // flattens and then sorts
  sort(x) = [ 1.,  1.,  3.,  4.]

  // sorts along the first axis
  sort(x, axis=0) = [[ 1.,  1.],
                     [ 3.,  4.]]

  // in a descend order
  sort(x, is_ascend=0) = [[ 4.,  1.],
                          [ 3.,  1.]]



Defined in src/operator/tensor/ordering_op.cc:L126
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns a sorted copy of an input array along the given axis.

Examples::

  x = [[ 1, 4],
       [ 3, 1]]

  // sorts along the last axis
  sort(x) = [[ 1.,  4.],
             [ 1.,  3.]]

  // flattens and then sorts
  sort(x) = [ 1.,  1.,  3.,  4.]

  // sorts along the first axis
  sort(x, axis=0) = [[ 1.,  1.],
                     [ 3.,  4.]]

  // in a descend order
  sort(x, is_ascend=0) = [[ 4.,  1.],
                          [ 3.,  1.]]



Defined in src/operator/tensor/ordering_op.cc:L126
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#space_to_depth" visbl="pub">
<a id="space_to_depth(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="space_to_depth(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">space_to_depth</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@space_to_depth(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Rearranges(permutes) blocks of spatial data into depth.
Similar to ONNX SpaceToDepth operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth

The output is a new tensor where the values from height and width dimension are
moved to the depth dimension. The reverse of this operation is ``depth_to_space``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`

Example::

  x = [[[[0, 6, 1, 7, 2, 8],
         [12, 18, 13, 19, 14, 20],
         [3, 9, 4, 10, 5, 11],
         [15, 21, 16, 22, 17, 23]]]]


  space_to_depth(x, 2) = [[[[0, 1, 2],
                            [3, 4, 5]],
                           [[6, 7, 8],
                            [9, 10, 11]],
                           [[12, 13, 14],
                            [15, 16, 17]],
                           [[18, 19, 20],
                            [21, 22, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L999
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Rearranges(permutes) blocks of spatial data into depth.
Similar to ONNX SpaceToDepth operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth

The output is a new tensor where the values from height and width dimension are
moved to the depth dimension. The reverse of this operation is ``depth_to_space``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`

Example::

  x = [[[[0, 6, 1, 7, 2, 8],
         [12, 18, 13, 19, 14, 20],
         [3, 9, 4, 10, 5, 11],
         [15, 21, 16, 22, 17, 23]]]]


  space_to_depth(x, 2) = [[[[0, 1, 2],
                            [3, 4, 5]],
                           [[6, 7, 8],
                            [9, 10, 11]],
                           [[12, 13, 14],
                            [15, 16, 17]],
                           [[18, 19, 20],
                            [21, 22, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L999
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#space_to_depth" visbl="pub">
<a id="space_to_depth(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="space_to_depth(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">space_to_depth</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@space_to_depth(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Rearranges(permutes) blocks of spatial data into depth.
Similar to ONNX SpaceToDepth operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth

The output is a new tensor where the values from height and width dimension are
moved to the depth dimension. The reverse of this operation is ``depth_to_space``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`

Example::

  x = [[[[0, 6, 1, 7, 2, 8],
         [12, 18, 13, 19, 14, 20],
         [3, 9, 4, 10, 5, 11],
         [15, 21, 16, 22, 17, 23]]]]


  space_to_depth(x, 2) = [[[[0, 1, 2],
                            [3, 4, 5]],
                           [[6, 7, 8],
                            [9, 10, 11]],
                           [[12, 13, 14],
                            [15, 16, 17]],
                           [[18, 19, 20],
                            [21, 22, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L999
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Rearranges(permutes) blocks of spatial data into depth.
Similar to ONNX SpaceToDepth operator:
https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth

The output is a new tensor where the values from height and width dimension are
moved to the depth dimension. The reverse of this operation is ``depth_to_space``.

.. math::

    \begin{gather*}
    x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
    x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
    y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
    \end{gather*}

where :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width]
and :math:`y` is the output tensor of layout :math:`[N, C * (block\_size ^ 2), H / block\_size, W / block\_size]`

Example::

  x = [[[[0, 6, 1, 7, 2, 8],
         [12, 18, 13, 19, 14, 20],
         [3, 9, 4, 10, 5, 11],
         [15, 21, 16, 22, 17, 23]]]]


  space_to_depth(x, 2) = [[[[0, 1, 2],
                            [3, 4, 5]],
                           [[6, 7, 8],
                            [9, 10, 11]],
                           [[12, 13, 14],
                            [15, 16, 17]],
                           [[18, 19, 20],
                            [21, 22, 23]]]]


Defined in src/operator/tensor/matrix_op.cc:L999
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#split" visbl="pub">
<a id="split(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="split(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">split</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@split(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#split" visbl="pub">
<a id="split(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="split(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">split</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@split(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Splits an array along a particular axis into multiple sub-arrays.

.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.

**Note** that `num_outputs` should evenly divide the length of the axis
along which to split the array.

Example::

   x  = [[[ 1.]
          [ 2.]]
         [[ 3.]
          [ 4.]]
         [[ 5.]
          [ 6.]]]
   x.shape = (3, 2, 1)

   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)
   y = [[[ 1.]]
        [[ 3.]]
        [[ 5.]]]

       [[[ 2.]]
        [[ 4.]]
        [[ 6.]]]

   y[0].shape = (3, 1, 1)

   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)
   z = [[[ 1.]
         [ 2.]]]

       [[[ 3.]
         [ 4.]]]

       [[[ 5.]
         [ 6.]]]

   z[0].shape = (1, 2, 1)

`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.
**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only
along the `axis` which it is split.
Also `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.

Example::

   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)
   z = [[ 1.]
        [ 2.]]

       [[ 3.]
        [ 4.]]

       [[ 5.]
        [ 6.]]
   z[0].shape = (2 ,1 )



Defined in src/operator/slice_channel.cc:L107
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sqrt" visbl="pub">
<a id="sqrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sqrt(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sqrt</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sqrt(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise square-root value of the input.

.. math::
   \textrm{sqrt}(x) = \sqrt{x}

Example::

   sqrt([4, 9, 16]) = [2, 3, 4]

The storage type of ``sqrt`` output depends upon the input storage type:

   - sqrt(default) = default
   - sqrt(row_sparse) = row_sparse
   - sqrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L844
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise square-root value of the input.

.. math::
   \textrm{sqrt}(x) = \sqrt{x}

Example::

   sqrt([4, 9, 16]) = [2, 3, 4]

The storage type of ``sqrt`` output depends upon the input storage type:

   - sqrt(default) = default
   - sqrt(row_sparse) = row_sparse
   - sqrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L844
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sqrt" visbl="pub">
<a id="sqrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sqrt(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sqrt</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sqrt(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise square-root value of the input.

.. math::
   \textrm{sqrt}(x) = \sqrt{x}

Example::

   sqrt([4, 9, 16]) = [2, 3, 4]

The storage type of ``sqrt`` output depends upon the input storage type:

   - sqrt(default) = default
   - sqrt(row_sparse) = row_sparse
   - sqrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L844
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise square-root value of the input.

.. math::
   \textrm{sqrt}(x) = \sqrt{x}

Example::

   sqrt([4, 9, 16]) = [2, 3, 4]

The storage type of ``sqrt`` output depends upon the input storage type:

   - sqrt(default) = default
   - sqrt(row_sparse) = row_sparse
   - sqrt(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L844
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#square" visbl="pub">
<a id="square(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="square(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">square</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@square(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise squared value of the input.

.. math::
   square(x) = x^2

Example::

   square([2, 3, 4]) = [4, 9, 16]

The storage type of ``square`` output depends upon the input storage type:

   - square(default) = default
   - square(row_sparse) = row_sparse
   - square(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L821
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise squared value of the input.

.. math::
   square(x) = x^2

Example::

   square([2, 3, 4]) = [4, 9, 16]

The storage type of ``square`` output depends upon the input storage type:

   - square(default) = default
   - square(row_sparse) = row_sparse
   - square(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L821
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#square" visbl="pub">
<a id="square(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="square(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">square</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@square(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns element-wise squared value of the input.

.. math::
   square(x) = x^2

Example::

   square([2, 3, 4]) = [4, 9, 16]

The storage type of ``square`` output depends upon the input storage type:

   - square(default) = default
   - square(row_sparse) = row_sparse
   - square(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L821
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns element-wise squared value of the input.

.. math::
   square(x) = x^2

Example::

   square([2, 3, 4]) = [4, 9, 16]

The storage type of ``square`` output depends upon the input storage type:

   - square(default) = default
   - square(row_sparse) = row_sparse
   - square(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L821
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#squeeze" visbl="pub">
<a id="squeeze(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="squeeze(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">squeeze</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@squeeze(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Remove single-dimensional entries from the shape of an array.
Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
See the following note for exception.

Examples::

  data = [[[0], [1], [2]]]
  squeeze(data) = [0, 1, 2]
  squeeze(data, axis=0) = [[0], [1], [2]]
  squeeze(data, axis=2) = [[0, 1, 2]]
  squeeze(data, axis=(0, 2)) = [0, 1, 2]

.. Note::
  The output of this operator will keep at least one dimension not removed. For example,
  squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Remove single-dimensional entries from the shape of an array.
Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
See the following note for exception.

Examples::

  data = [[[0], [1], [2]]]
  squeeze(data) = [0, 1, 2]
  squeeze(data, axis=0) = [[0], [1], [2]]
  squeeze(data, axis=2) = [[0, 1, 2]]
  squeeze(data, axis=(0, 2)) = [0, 1, 2]

.. Note::
  The output of this operator will keep at least one dimension not removed. For example,
  squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#squeeze" visbl="pub">
<a id="squeeze(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="squeeze(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">squeeze</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@squeeze(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Remove single-dimensional entries from the shape of an array.
Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
See the following note for exception.

Examples::

  data = [[[0], [1], [2]]]
  squeeze(data) = [0, 1, 2]
  squeeze(data, axis=0) = [[0], [1], [2]]
  squeeze(data, axis=2) = [[0, 1, 2]]
  squeeze(data, axis=(0, 2)) = [0, 1, 2]

.. Note::
  The output of this operator will keep at least one dimension not removed. For example,
  squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Remove single-dimensional entries from the shape of an array.
Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
See the following note for exception.

Examples::

  data = [[[0], [1], [2]]]
  squeeze(data) = [0, 1, 2]
  squeeze(data, axis=0) = [[0], [1], [2]]
  squeeze(data, axis=2) = [[0, 1, 2]]
  squeeze(data, axis=(0, 2)) = [0, 1, 2]

.. Note::
  The output of this operator will keep at least one dimension not removed. For example,
  squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#stack" visbl="pub">
<a id="stack(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="stack(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">stack</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@stack(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Join a sequence of arrays along a new axis.

The axis parameter specifies the index of the new axis in the dimensions of the
result. For example, if axis=0 it will be the first dimension and if axis=-1 it
will be the last dimension.

Examples::

  x = [1, 2]
  y = [3, 4]

  stack(x, y) = [[1, 2],
                 [3, 4]]
  stack(x, y, axis=1) = [[1, 3],
                         [2, 4]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Join a sequence of arrays along a new axis.

The axis parameter specifies the index of the new axis in the dimensions of the
result. For example, if axis=0 it will be the first dimension and if axis=-1 it
will be the last dimension.

Examples::

  x = [1, 2]
  y = [3, 4]

  stack(x, y) = [[1, 2],
                 [3, 4]]
  stack(x, y, axis=1) = [[1, 3],
                         [2, 4]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#stack" visbl="pub">
<a id="stack(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="stack(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">stack</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@stack(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Join a sequence of arrays along a new axis.

The axis parameter specifies the index of the new axis in the dimensions of the
result. For example, if axis=0 it will be the first dimension and if axis=-1 it
will be the last dimension.

Examples::

  x = [1, 2]
  y = [3, 4]

  stack(x, y) = [[1, 2],
                 [3, 4]]
  stack(x, y, axis=1) = [[1, 3],
                         [2, 4]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Join a sequence of arrays along a new axis.

The axis parameter specifies the index of the new axis in the dimensions of the
result. For example, if axis=0 it will be the first dimension and if axis=-1 it
will be the last dimension.

Examples::

  x = [1, 2]
  y = [3, 4]

  stack(x, y) = [[1, 2],
                 [3, 4]]
  stack(x, y, axis=1) = [[1, 3],
                         [2, 4]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#stop_gradient" visbl="pub">
<a id="stop_gradient(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="stop_gradient(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">stop_gradient</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@stop_gradient(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#stop_gradient" visbl="pub">
<a id="stop_gradient(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="stop_gradient(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">stop_gradient</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@stop_gradient(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Stops gradient computation.

Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.

Example::

  v1 = [1, 2]
  v2 = [0, 1]
  a = Variable('a')
  b = Variable('b')
  b_stop_grad = stop_gradient(3 * b)
  loss = MakeLoss(b_stop_grad + a)

  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))
  executor.forward(is_train=True, a=v1, b=v2)
  executor.outputs
  [ 1.  5.]

  executor.backward()
  executor.grad_arrays
  [ 0.  0.]
  [ 1.  1.]



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L265
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sum" visbl="pub">
<a id="sum(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sum(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sum</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sum(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sum" visbl="pub">
<a id="sum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sum(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sum</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sum(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sum_axis" visbl="pub">
<a id="sum_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sum_axis(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sum_axis</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sum_axis(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#sum_axis" visbl="pub">
<a id="sum_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="sum_axis(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">sum_axis</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@sum_axis(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the sum of array elements over given axes.

.. Note::

  `sum` and `sum_axis` are equivalent.
  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
  Setting keepdims or exclude to True will cause a fallback to dense operator.

Example::

  data = [[[1, 2], [2, 3], [1, 3]],
          [[1, 4], [4, 3], [5, 2]],
          [[7, 1], [7, 2], [7, 3]]]

  sum(data, axis=1)
  [[  4.   8.]
   [ 10.   9.]
   [ 21.   6.]]

  sum(data, axis=[1,2])
  [ 12.  19.  27.]

  data = [[1, 2, 0],
          [3, 0, 1],
          [4, 1, 0]]

  csr = cast_storage(data, 'csr')

  sum(csr, axis=0)
  [ 8.  3.  1.]

  sum(csr, axis=1)
  [ 3.  4.  5.]



Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L115
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#swapaxes" visbl="pub">
<a id="swapaxes(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="swapaxes(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">swapaxes</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@swapaxes(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#swapaxes" visbl="pub">
<a id="swapaxes(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="swapaxes(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">swapaxes</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@swapaxes(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Interchanges two axes of an array.

Examples::

  x = [[1, 2, 3]])
  swapaxes(x, 0, 1) = [[ 1],
                       [ 2],
                       [ 3]]

  x = [[[ 0, 1],
        [ 2, 3]],
       [[ 4, 5],
        [ 6, 7]]]  // (2,2,2) array

 swapaxes(x, 0, 2) = [[[ 0, 4],
                       [ 2, 6]],
                      [[ 1, 5],
                       [ 3, 7]]]


Defined in src/operator/swapaxis.cc:L70
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#take" visbl="pub">
<a id="take(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="take(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">take</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@take(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Takes elements from an input array along the given axis.

This function slices the input array along a particular axis with the provided indices.

Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
in an output tensor of rank q + (r - 1).

Examples::
  x = [4.  5.  6.]

  // Trivial case, take the second element along the first axis.

  take(x, [1]) = [ 5. ]

  // The other trivial case, axis=-1, take the third element along the first axis

  take(x, [3], axis=-1, mode='clip') = [ 6. ]

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0

  take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
                             [ 3.,  4.]],

                            [[ 3.,  4.],
                             [ 5.,  6.]]]

  // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
  // Along axis 1

  take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.,  2.],
                                                       [ 3.,  4.]],

                                                      [[ 3.,  4.],
                                                       [ 5.,  6.]]]



Defined in src/operator/tensor/indexing_op.cc:L434
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Takes elements from an input array along the given axis.

This function slices the input array along a particular axis with the provided indices.

Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
in an output tensor of rank q + (r - 1).

Examples::
  x = [4.  5.  6.]

  // Trivial case, take the second element along the first axis.

  take(x, [1]) = [ 5. ]

  // The other trivial case, axis=-1, take the third element along the first axis

  take(x, [3], axis=-1, mode='clip') = [ 6. ]

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0

  take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
                             [ 3.,  4.]],

                            [[ 3.,  4.],
                             [ 5.,  6.]]]

  // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
  // Along axis 1

  take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.,  2.],
                                                       [ 3.,  4.]],

                                                      [[ 3.,  4.],
                                                       [ 5.,  6.]]]



Defined in src/operator/tensor/indexing_op.cc:L434
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#take" visbl="pub">
<a id="take(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="take(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">take</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@take(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Takes elements from an input array along the given axis.

This function slices the input array along a particular axis with the provided indices.

Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
in an output tensor of rank q + (r - 1).

Examples::
  x = [4.  5.  6.]

  // Trivial case, take the second element along the first axis.

  take(x, [1]) = [ 5. ]

  // The other trivial case, axis=-1, take the third element along the first axis

  take(x, [3], axis=-1, mode='clip') = [ 6. ]

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0

  take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
                             [ 3.,  4.]],

                            [[ 3.,  4.],
                             [ 5.,  6.]]]

  // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
  // Along axis 1

  take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.,  2.],
                                                       [ 3.,  4.]],

                                                      [[ 3.,  4.],
                                                       [ 5.,  6.]]]



Defined in src/operator/tensor/indexing_op.cc:L434
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Takes elements from an input array along the given axis.

This function slices the input array along a particular axis with the provided indices.

Given data tensor of rank r &gt;= 1, and indices tensor of rank q, gather entries of the axis
dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
in an output tensor of rank q + (r - 1).

Examples::
  x = [4.  5.  6.]

  // Trivial case, take the second element along the first axis.

  take(x, [1]) = [ 5. ]

  // The other trivial case, axis=-1, take the third element along the first axis

  take(x, [3], axis=-1, mode='clip') = [ 6. ]

  x = [[ 1.,  2.],
       [ 3.,  4.],
       [ 5.,  6.]]

  // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0

  take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],
                             [ 3.,  4.]],

                            [[ 3.,  4.],
                             [ 5.,  6.]]]

  // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).
  // Along axis 1

  take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.,  2.],
                                                       [ 3.,  4.]],

                                                      [[ 3.,  4.],
                                                       [ 5.,  6.]]]



Defined in src/operator/tensor/indexing_op.cc:L434
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#tan" visbl="pub">
<a id="tan(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="tan(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">tan</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@tan(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the element-wise tangent of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   tan([0, \pi/4, \pi/2]) = [0, 1, -inf]

The storage type of ``tan`` output depends upon the input storage type:

   - tan(default) = default
   - tan(row_sparse) = row_sparse
   - tan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the element-wise tangent of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   tan([0, \pi/4, \pi/2]) = [0, 1, -inf]

The storage type of ``tan`` output depends upon the input storage type:

   - tan(default) = default
   - tan(row_sparse) = row_sparse
   - tan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#tan" visbl="pub">
<a id="tan(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="tan(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">tan</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@tan(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Computes the element-wise tangent of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   tan([0, \pi/4, \pi/2]) = [0, 1, -inf]

The storage type of ``tan`` output depends upon the input storage type:

   - tan(default) = default
   - tan(row_sparse) = row_sparse
   - tan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Computes the element-wise tangent of the input array.

The input should be in radians (:math:`2\pi` rad equals 360 degrees).

.. math::
   tan([0, \pi/4, \pi/2]) = [0, 1, -inf]

The storage type of ``tan`` output depends upon the input storage type:

   - tan(default) = default
   - tan(row_sparse) = row_sparse
   - tan(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L83
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#tanh" visbl="pub">
<a id="tanh(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="tanh(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">tanh</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@tanh(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the hyperbolic tangent of the input array, computed element-wise.

.. math::
   tanh(x) = sinh(x) / cosh(x)

The storage type of ``tanh`` output depends upon the input storage type:

   - tanh(default) = default
   - tanh(row_sparse) = row_sparse
   - tanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the hyperbolic tangent of the input array, computed element-wise.

.. math::
   tanh(x) = sinh(x) / cosh(x)

The storage type of ``tanh`` output depends upon the input storage type:

   - tanh(default) = default
   - tanh(row_sparse) = row_sparse
   - tanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#tanh" visbl="pub">
<a id="tanh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="tanh(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">tanh</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@tanh(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the hyperbolic tangent of the input array, computed element-wise.

.. math::
   tanh(x) = sinh(x) / cosh(x)

The storage type of ``tanh`` output depends upon the input storage type:

   - tanh(default) = default
   - tanh(row_sparse) = row_sparse
   - tanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the hyperbolic tangent of the input array, computed element-wise.

.. math::
   tanh(x) = sinh(x) / cosh(x)

The storage type of ``tanh`` output depends upon the input storage type:

   - tanh(default) = default
   - tanh(row_sparse) = row_sparse
   - tanh(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L234
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#tile" visbl="pub">
<a id="tile(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="tile(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">tile</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@tile(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Repeats the whole array multiple times.

If ``reps`` has length *d*, and input array has dimension of *n*. There are
three cases:

- **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::

    x = [[1, 2],
         [3, 4]]

    tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.],
                           [ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.]]

- **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for
  an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::


    tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
                          [ 3.,  4.,  3.,  4.]]

- **n<d**. 1.,="" 2.,="" 2.],="" 3-d="" 3.,="" 4.,="" 4.],="" 4.]],="" 4.]]]="" <="" =="" [="" [[="" [[[="" ``(1,2,2)``="" ``(2,2)``="" a="" array="" axes.="" be="" by="" d-dimensional="" defined="" for="" in="" input="" is="" matrix_op.cc:l752="" new="" operator="" pre="" prepending="" promoted="" replication::="" reps="(2,2,3))" shape="" so="" src="" tensor="" the="" tile(x,="" to=""></d**.></pre></p><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Repeats the whole array multiple times.

If ``reps`` has length *d*, and input array has dimension of *n*. There are
three cases:

- **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::

    x = [[1, 2],
         [3, 4]]

    tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.],
                           [ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.]]

- **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for
  an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::


    tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
                          [ 3.,  4.,  3.,  4.]]

- **n<d**. 1.,="" 2.,="" 2.],="" 3-d="" 3.,="" 4.,="" 4.],="" 4.]],="" 4.]]]="" <="" =="" [="" [[="" [[[="" ``(1,2,2)``="" ``(2,2)``="" a="" array="" axes.="" be="" by="" d-dimensional="" defined="" for="" in="" input="" is="" matrix_op.cc:l752="" new="" operator="" pre="" prepending="" promoted="" replication::="" reps="(2,2,3))" shape="" so="" src="" tensor="" the="" tile(x,="" to=""></d**.></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
</li><li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#tile" visbl="pub">
<a id="tile(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="tile(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">tile</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@tile(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Repeats the whole array multiple times.

If ``reps`` has length *d*, and input array has dimension of *n*. There are
three cases:

- **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::

    x = [[1, 2],
         [3, 4]]

    tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.],
                           [ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.]]

- **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for
  an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::


    tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
                          [ 3.,  4.,  3.,  4.]]

- **n<d**. 1.,="" 2.,="" 2.],="" 3-d="" 3.,="" 4.,="" 4.],="" 4.]],="" 4.]]]="" <="" =="" [="" [[="" [[[="" ``(1,2,2)``="" ``(2,2)``="" a="" array="" axes.="" be="" by="" d-dimensional="" defined="" for="" in="" input="" is="" matrix_op.cc:l752="" new="" operator="" pre="" prepending="" promoted="" replication::="" reps="(2,2,3))" shape="" so="" src="" tensor="" the="" tile(x,="" to=""></d**.></pre></p><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Repeats the whole array multiple times.

If ``reps`` has length *d*, and input array has dimension of *n*. There are
three cases:

- **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::

    x = [[1, 2],
         [3, 4]]

    tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.],
                           [ 1.,  2.,  1.,  2.,  1.,  2.],
                           [ 3.,  4.,  3.,  4.,  3.,  4.]]

- **n&gt;d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for
  an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::


    tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],
                          [ 3.,  4.,  3.,  4.]]

- **n<d**. 1.,="" 2.,="" 2.],="" 3-d="" 3.,="" 4.,="" 4.],="" 4.]],="" 4.]]]="" <="" =="" [="" [[="" [[[="" ``(1,2,2)``="" ``(2,2)``="" a="" array="" axes.="" be="" by="" d-dimensional="" defined="" for="" in="" input="" is="" matrix_op.cc:l752="" new="" operator="" pre="" prepending="" promoted="" replication::="" reps="(2,2,3))" shape="" so="" src="" tensor="" the="" tile(x,="" to=""></d**.></pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
</li><li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#topk" visbl="pub">
<a id="topk(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="topk(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">topk</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@topk(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the top *k* elements in an input array along the given axis.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // returns an index of the largest element on last axis
  topk(x) = [[ 2.],
             [ 1.]]

  // returns the value of top-2 largest elements on last axis
  topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],
                                   [ 0.3,  0.2]]

  // returns the value of top-2 smallest elements on last axis
  topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],
                                               [ 0.1 ,  0.2]]

  // returns the value of top-2 largest elements on axis 0
  topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],
                                           [ 0.1,  0.2,  0.2]]

  // flattens and then returns list of both values and indices
  topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]



Defined in src/operator/tensor/ordering_op.cc:L63
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the top *k* elements in an input array along the given axis.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // returns an index of the largest element on last axis
  topk(x) = [[ 2.],
             [ 1.]]

  // returns the value of top-2 largest elements on last axis
  topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],
                                   [ 0.3,  0.2]]

  // returns the value of top-2 smallest elements on last axis
  topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],
                                               [ 0.1 ,  0.2]]

  // returns the value of top-2 largest elements on axis 0
  topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],
                                           [ 0.1,  0.2,  0.2]]

  // flattens and then returns list of both values and indices
  topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]



Defined in src/operator/tensor/ordering_op.cc:L63
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#topk" visbl="pub">
<a id="topk(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="topk(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">topk</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@topk(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Returns the top *k* elements in an input array along the given axis.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // returns an index of the largest element on last axis
  topk(x) = [[ 2.],
             [ 1.]]

  // returns the value of top-2 largest elements on last axis
  topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],
                                   [ 0.3,  0.2]]

  // returns the value of top-2 smallest elements on last axis
  topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],
                                               [ 0.1 ,  0.2]]

  // returns the value of top-2 largest elements on axis 0
  topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],
                                           [ 0.1,  0.2,  0.2]]

  // flattens and then returns list of both values and indices
  topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]



Defined in src/operator/tensor/ordering_op.cc:L63
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Returns the top *k* elements in an input array along the given axis.

Examples::

  x = [[ 0.3,  0.2,  0.4],
       [ 0.1,  0.3,  0.2]]

  // returns an index of the largest element on last axis
  topk(x) = [[ 2.],
             [ 1.]]

  // returns the value of top-2 largest elements on last axis
  topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],
                                   [ 0.3,  0.2]]

  // returns the value of top-2 smallest elements on last axis
  topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],
                                               [ 0.1 ,  0.2]]

  // returns the value of top-2 largest elements on axis 0
  topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],
                                           [ 0.1,  0.2,  0.2]]

  // flattens and then returns list of both values and indices
  topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]



Defined in src/operator/tensor/ordering_op.cc:L63
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#transpose" visbl="pub">
<a id="transpose(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="transpose(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">transpose</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@transpose(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Permutes the dimensions of an array.

Examples::

  x = [[ 1, 2],
       [ 3, 4]]

  transpose(x) = [[ 1.,  3.],
                  [ 2.,  4.]]

  x = [[[ 1.,  2.],
        [ 3.,  4.]],

       [[ 5.,  6.],
        [ 7.,  8.]]]

  transpose(x) = [[[ 1.,  5.],
                   [ 3.,  7.]],

                  [[ 2.,  6.],
                   [ 4.,  8.]]]

  transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
                                 [ 5.,  6.]],

                                [[ 3.,  4.],
                                 [ 7.,  8.]]]


Defined in src/operator/tensor/matrix_op.cc:L311
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Permutes the dimensions of an array.

Examples::

  x = [[ 1, 2],
       [ 3, 4]]

  transpose(x) = [[ 1.,  3.],
                  [ 2.,  4.]]

  x = [[[ 1.,  2.],
        [ 3.,  4.]],

       [[ 5.,  6.],
        [ 7.,  8.]]]

  transpose(x) = [[[ 1.,  5.],
                   [ 3.,  7.]],

                  [[ 2.,  6.],
                   [ 4.,  8.]]]

  transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
                                 [ 5.,  6.]],

                                [[ 3.,  4.],
                                 [ 7.,  8.]]]


Defined in src/operator/tensor/matrix_op.cc:L311
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#transpose" visbl="pub">
<a id="transpose(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="transpose(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">transpose</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@transpose(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Permutes the dimensions of an array.

Examples::

  x = [[ 1, 2],
       [ 3, 4]]

  transpose(x) = [[ 1.,  3.],
                  [ 2.,  4.]]

  x = [[[ 1.,  2.],
        [ 3.,  4.]],

       [[ 5.,  6.],
        [ 7.,  8.]]]

  transpose(x) = [[[ 1.,  5.],
                   [ 3.,  7.]],

                  [[ 2.,  6.],
                   [ 4.,  8.]]]

  transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
                                 [ 5.,  6.]],

                                [[ 3.,  4.],
                                 [ 7.,  8.]]]


Defined in src/operator/tensor/matrix_op.cc:L311
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Permutes the dimensions of an array.

Examples::

  x = [[ 1, 2],
       [ 3, 4]]

  transpose(x) = [[ 1.,  3.],
                  [ 2.,  4.]]

  x = [[[ 1.,  2.],
        [ 3.,  4.]],

       [[ 5.,  6.],
        [ 7.,  8.]]]

  transpose(x) = [[[ 1.,  5.],
                   [ 3.,  7.]],

                  [[ 2.,  6.],
                   [ 4.,  8.]]]

  transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],
                                 [ 5.,  6.]],

                                [[ 3.,  4.],
                                 [ 7.,  8.]]]


Defined in src/operator/tensor/matrix_op.cc:L311
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#trunc" visbl="pub">
<a id="trunc(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="trunc(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">trunc</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@trunc(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return the element-wise truncated value of the input.

The truncated value of the scalar x is the nearest integer i which is closer to
zero than x is. In short, the fractional part of the signed number x is discarded.

Example::

   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]

The storage type of ``trunc`` output depends upon the input storage type:

   - trunc(default) = default
   - trunc(row_sparse) = row_sparse
   - trunc(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L783
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return the element-wise truncated value of the input.

The truncated value of the scalar x is the nearest integer i which is closer to
zero than x is. In short, the fractional part of the signed number x is discarded.

Example::

   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]

The storage type of ``trunc`` output depends upon the input storage type:

   - trunc(default) = default
   - trunc(row_sparse) = row_sparse
   - trunc(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L783
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#trunc" visbl="pub">
<a id="trunc(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="trunc(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">trunc</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@trunc(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return the element-wise truncated value of the input.

The truncated value of the scalar x is the nearest integer i which is closer to
zero than x is. In short, the fractional part of the signed number x is discarded.

Example::

   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]

The storage type of ``trunc`` output depends upon the input storage type:

   - trunc(default) = default
   - trunc(row_sparse) = row_sparse
   - trunc(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L783
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return the element-wise truncated value of the input.

The truncated value of the scalar x is the nearest integer i which is closer to
zero than x is. In short, the fractional part of the signed number x is discarded.

Example::

   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]

The storage type of ``trunc`` output depends upon the input storage type:

   - trunc(default) = default
   - trunc(row_sparse) = row_sparse
   - trunc(csr) = csr



Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L783
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#uniform" visbl="pub">
<a id="uniform(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="uniform(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">uniform</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@uniform(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#uniform" visbl="pub">
<a id="uniform(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="uniform(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">uniform</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@uniform(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Draw random samples from a uniform distribution.

.. note:: The existing alias ``uniform`` is deprecated.

Samples are uniformly distributed over the half-open interval *[low, high)*
(includes *low*, but excludes *high*).

Example::

   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],
                                          [ 0.54488319,  0.84725171]]



Defined in src/operator/random/sample_op.cc:L66
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#unravel_index" visbl="pub">
<a id="unravel_index(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="unravel_index(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">unravel_index</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@unravel_index(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix.

Examples::

   A = [22,41,37]
   unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]



Defined in src/operator/tensor/ravel.cc:L65
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix.

Examples::

   A = [22,41,37]
   unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]



Defined in src/operator/tensor/ravel.cc:L65
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#unravel_index" visbl="pub">
<a id="unravel_index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="unravel_index(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">unravel_index</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@unravel_index(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix.

Examples::

   A = [22,41,37]
   unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]



Defined in src/operator/tensor/ravel.cc:L65
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix.

Examples::

   A = [22,41,37]
   unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]



Defined in src/operator/tensor/ravel.cc:L65
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#where" visbl="pub">
<a id="where(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="where(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">where</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@where(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return the elements, either from x or y, depending on the condition.

Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
depending on the elements from condition are true or false. x and y must have the same shape.
If condition has the same shape as x, each element in the output array is from x if the
corresponding element in the condition is true, and from y if false.

If condition does not have the same shape as x, it must be a 1D array whose size is
the same as x's first dimension size. Each row of the output array is from x's row
if the corresponding element from condition is true, and from y's row if false.

Note that all non-zero values are interpreted as ``True`` in condition.

Examples::

  x = [[1, 2], [3, 4]]
  y = [[5, 6], [7, 8]]
  cond = [[0, 1], [-1, 0]]

  where(cond, x, y) = [[5, 2], [3, 8]]

  csr_cond = cast_storage(cond, 'csr')

  where(csr_cond, x, y) = [[5, 2], [3, 8]]



Defined in src/operator/tensor/control_flow_op.cc:L57
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return the elements, either from x or y, depending on the condition.

Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
depending on the elements from condition are true or false. x and y must have the same shape.
If condition has the same shape as x, each element in the output array is from x if the
corresponding element in the condition is true, and from y if false.

If condition does not have the same shape as x, it must be a 1D array whose size is
the same as x's first dimension size. Each row of the output array is from x's row
if the corresponding element from condition is true, and from y's row if false.

Note that all non-zero values are interpreted as ``True`` in condition.

Examples::

  x = [[1, 2], [3, 4]]
  y = [[5, 6], [7, 8]]
  cond = [[0, 1], [-1, 0]]

  where(cond, x, y) = [[5, 2], [3, 8]]

  csr_cond = cast_storage(cond, 'csr')

  where(csr_cond, x, y) = [[5, 2], [3, 8]]



Defined in src/operator/tensor/control_flow_op.cc:L57
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#where" visbl="pub">
<a id="where(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="where(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">where</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@where(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return the elements, either from x or y, depending on the condition.

Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
depending on the elements from condition are true or false. x and y must have the same shape.
If condition has the same shape as x, each element in the output array is from x if the
corresponding element in the condition is true, and from y if false.

If condition does not have the same shape as x, it must be a 1D array whose size is
the same as x's first dimension size. Each row of the output array is from x's row
if the corresponding element from condition is true, and from y's row if false.

Note that all non-zero values are interpreted as ``True`` in condition.

Examples::

  x = [[1, 2], [3, 4]]
  y = [[5, 6], [7, 8]]
  cond = [[0, 1], [-1, 0]]

  where(cond, x, y) = [[5, 2], [3, 8]]

  csr_cond = cast_storage(cond, 'csr')

  where(csr_cond, x, y) = [[5, 2], [3, 8]]



Defined in src/operator/tensor/control_flow_op.cc:L57
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return the elements, either from x or y, depending on the condition.

Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
depending on the elements from condition are true or false. x and y must have the same shape.
If condition has the same shape as x, each element in the output array is from x if the
corresponding element in the condition is true, and from y if false.

If condition does not have the same shape as x, it must be a 1D array whose size is
the same as x's first dimension size. Each row of the output array is from x's row
if the corresponding element from condition is true, and from y's row if false.

Note that all non-zero values are interpreted as ``True`` in condition.

Examples::

  x = [[1, 2], [3, 4]]
  y = [[5, 6], [7, 8]]
  cond = [[0, 1], [-1, 0]]

  where(cond, x, y) = [[5, 2], [3, 8]]

  csr_cond = cast_storage(cond, 'csr')

  where(csr_cond, x, y) = [[5, 2], [3, 8]]



Defined in src/operator/tensor/control_flow_op.cc:L57
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#zeros_like" visbl="pub">
<a id="zeros_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="zeros_like(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">zeros_like</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@zeros_like(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return an array of zeros with the same shape, type and storage type
as the input array.

The storage type of ``zeros_like`` output depends on the storage type of the input

- zeros_like(row_sparse) = row_sparse
- zeros_like(csr) = csr
- zeros_like(default) = default

Examples::

  x = [[ 1.,  1.,  1.],
       [ 1.,  1.,  1.]]

  zeros_like(x) = [[ 0.,  0.,  0.],
                   [ 0.,  0.,  0.]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return an array of zeros with the same shape, type and storage type
as the input array.

The storage type of ``zeros_like`` output depends on the storage type of the input

- zeros_like(row_sparse) = row_sparse
- zeros_like(csr) = csr
- zeros_like(default) = default

Examples::

  x = [[ 1.,  1.,  1.],
       [ 1.,  1.,  1.]]

  zeros_like(x) = [[ 0.,  0.,  0.],
                   [ 0.,  0.,  0.]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>
<li data-isabs="true" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArrayBase#zeros_like" visbl="pub">
<a id="zeros_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn"></a>
<a id="zeros_like(Map[String,Any])(Any*):NDArrayFuncReturn"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">abstract </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">zeros_like</span><span class="params">(<span name="kwargs">kwargs: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>] = <span class="symbol">null</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="result">: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@zeros_like(kwargs:Map[String,Any])(args:Any*):org.apache.mxnet.NDArrayFuncReturn" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">
<pre>
Return an array of zeros with the same shape, type and storage type
as the input array.

The storage type of ``zeros_like`` output depends on the storage type of the input

- zeros_like(row_sparse) = row_sparse
- zeros_like(csr) = csr
- zeros_like(default) = default

Examples::

  x = [[ 1.,  1.,  1.],
       [ 1.,  1.,  1.]]

  zeros_like(x) = [[ 0.,  0.,  0.],
                   [ 0.,  0.,  0.]]
</pre></p></li><div class="fullcomment"><div class="comment cmt"><p>
<pre>
Return an array of zeros with the same shape, type and storage type
as the input array.

The storage type of ``zeros_like`` output depends on the storage type of the input

- zeros_like(row_sparse) = row_sparse
- zeros_like(csr) = csr
- zeros_like(default) = default

Examples::

  x = [[ 1.,  1.,  1.],
       [ 1.,  1.,  1.]]

  zeros_like(x) = [[ 0.,  0.,  0.],
                   [ 0.,  0.,  0.]]
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>org.apache.mxnet.NDArray
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></dd></dl></div>


<div class="values members" id="values">
<h3>Concrete Value Members</h3>
<ol><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#!=" visbl="pub">
<a id="!=(x$1:Any):Boolean"></a>
<a id="!=(Any):Boolean"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@!=(x$1:Any):Boolean" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef###" visbl="pub">
<a id="##():Int"></a>
<a id="##():Int"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@##():Int" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#==" visbl="pub">
<a id="==(x$1:Any):Boolean"></a>
<a id="==(Any):Boolean"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@==(x$1:Any):Boolean" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#api" visbl="pub">
<a id="api:org.apache.mxnet.NDArrayAPI.type"></a>
<a id="api:NDArrayAPI.type"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">val</span>
</span>
<span class="symbol">
<span class="name">api</span><span class="result">: <a class="extype" href="NDArrayAPI$.html" name="org.apache.mxnet.NDArrayAPI">NDArrayAPI</a>.type</span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@api:org.apache.mxnet.NDArrayAPI.type" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#arange" visbl="pub">
<a id="arange(start:Float,stop:Option[Float],step:Float,repeat:Int,ctx:org.apache.mxnet.Context,dType:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray"></a>
<a id="arange(Float,Option[Float],Float,Int,Context,DType):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">arange</span><span class="params">(<span name="start">start: <span class="extype" name="scala.Float">Float</span></span>, <span name="stop">stop: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Float">Float</span>] = <span class="symbol">None</span></span>, <span name="step">step: <span class="extype" name="scala.Float">Float</span> = <span class="symbol">1.0f</span></span>, <span name="repeat">repeat: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>, <span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a> = <span class="symbol"><span class="name"><a href="Context$.html">Context.defaultCtx</a></span></span></span>, <span name="dType">dType: <a class="extmbr" href="DType$.html#DType=org.apache.mxnet.DType.Value" name="org.apache.mxnet.DType.DType">DType</a> = <span class="symbol">Base.MX_REAL_TYPE</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@arange(start:Float,stop:Option[Float],step:Float,repeat:Int,ctx:org.apache.mxnet.Context,dType:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns evenly spaced values within a given interval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns evenly spaced values within a given interval.
Values are generated within the half-open interval [<code>start</code>, <code>stop</code>). In other
words, the interval includes <code>start</code> but excludes <code>stop</code>.</p></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>Start of interval. The default start value is 0.</p></dd><dt class="param">stop</dt><dd class="cmt"><p>End of interval.</p></dd><dt class="param">step</dt><dd class="cmt"><p>Spacing between values. The default step size is 1.</p></dd><dt class="param">repeat</dt><dd class="cmt"><p>Number of times to repeat each element. The default repeat count is 1.</p></dd><dt class="param">ctx</dt><dd class="cmt"><p>Device context. Default context is the current default context.</p></dd><dt class="param">dType</dt><dd class="cmt"><p>The data type of the <code>NDArray</code>. The default datatype is <code>DType.Float32</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>NDArray of evenly spaced values in the specified range.
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#array" visbl="pub">
<a id="array(sourceArr:Array[Float],shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context):org.apache.mxnet.NDArray"></a>
<a id="array(Array[Float],Shape,Context):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">array</span><span class="params">(<span name="sourceArr">sourceArr: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Float">Float</span>]</span>, <span name="shape">shape: <a class="extype" href="Shape.html" name="org.apache.mxnet.Shape">Shape</a></span>, <span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a> = <span class="symbol">null</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@array(sourceArr:Array[Float],shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Create a new NDArray that copies content from source_array.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new NDArray that copies content from source_array.</p></div><dl class="paramcmts block"><dt class="param">sourceArr</dt><dd class="cmt"><p>Source data to create NDArray from.</p></dd><dt class="param">shape</dt><dd class="cmt"><p>shape of the NDArray</p></dd><dt class="param">ctx</dt><dd class="cmt"><p>The context of the NDArray, default to current default context.</p></dd><dt>returns</dt><dd class="cmt"><p>The created NDArray.
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.Any#asInstanceOf" visbl="pub">
<a id="asInstanceOf[T0]:T0"></a>
<a id="asInstanceOf[T0]:T0"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@asInstanceOf[T0]:T0" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#clone" visbl="prt">
<a id="clone():Object"></a>
<a id="clone():AnyRef"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@clone():Object" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a class="extype" href="../../../java$lang.html" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
<span class="name">@throws</span><span class="args">(<span>
<span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
</span>)</span>
</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#concatenate" visbl="pub">
<a id="concatenate(arrays:org.apache.mxnet.NDArray*):org.apache.mxnet.NDArray"></a>
<a id="concatenate(NDArray*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">concatenate</span><span class="params">(<span name="arrays">arrays: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@concatenate(arrays:org.apache.mxnet.NDArray*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#concatenate" visbl="pub">
<a id="concatenate(arrays:Seq[org.apache.mxnet.NDArray],axis:Int,alwaysCopy:Boolean):org.apache.mxnet.NDArray"></a>
<a id="concatenate(Seq[NDArray],Int,Boolean):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">concatenate</span><span class="params">(<span name="arrays">arrays: <span class="extype" name="scala.Seq">Seq</span>[<a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>]</span>, <span name="axis">axis: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>, <span name="alwaysCopy">alwaysCopy: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@concatenate(arrays:Seq[org.apache.mxnet.NDArray],axis:Int,alwaysCopy:Boolean):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Concatenate a list of NDArrays along the specified dimension.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenate a list of NDArrays along the specified dimension.</p></div><dl class="paramcmts block"><dt class="param">arrays</dt><dd class="cmt"><p>Arrays to be concatenate.
              They must have identical shape except the first dimension.
              They also must have the same data type.</p></dd><dt class="param">axis</dt><dd class="cmt"><p>The axis along which to concatenate.</p></dd><dt class="param">alwaysCopy</dt><dd class="cmt"><p>Default <code>True</code>. When not <code>True</code>,
                  if the arrays only contain one <code>NDArray</code>,
                  that element will be returned directly, avoid copying.</p></dd><dt>returns</dt><dd class="cmt"><p>An <code>NDArray</code> that lives on the same context as <code>arrays[0].context</code>.
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#deserialize" visbl="pub">
<a id="deserialize(bytes:Array[Byte]):org.apache.mxnet.NDArray"></a>
<a id="deserialize(Array[Byte]):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">deserialize</span><span class="params">(<span name="bytes">bytes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@deserialize(bytes:Array[Byte]):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#empty" visbl="pub">
<a id="empty(ctx:org.apache.mxnet.Context,shape:Int*):org.apache.mxnet.NDArray"></a>
<a id="empty(Context,Int*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">empty</span><span class="params">(<span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a></span>, <span name="shape">shape: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@empty(ctx:org.apache.mxnet.Context,shape:Int*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#empty" visbl="pub">
<a id="empty(shape:Int*):org.apache.mxnet.NDArray"></a>
<a id="empty(Int*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">empty</span><span class="params">(<span name="shape">shape: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@empty(shape:Int*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#empty" visbl="pub">
<a id="empty(shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context,dtype:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray"></a>
<a id="empty(Shape,Context,DType):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">empty</span><span class="params">(<span name="shape">shape: <a class="extype" href="Shape.html" name="org.apache.mxnet.Shape">Shape</a></span>, <span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a> = <span class="symbol">null</span></span>, <span name="dtype">dtype: <a class="extmbr" href="DType$.html#DType=org.apache.mxnet.DType.Value" name="org.apache.mxnet.DType.DType">DType</a> = <span class="symbol">Base.MX_REAL_TYPE</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@empty(shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context,dtype:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Create an empty uninitialized new NDArray, with specified shape.</p><div class="fullcomment"><div class="comment cmt"><p>Create an empty uninitialized new NDArray, with specified shape.
</p></div><dl class="paramcmts block"><dt class="param">shape</dt><dd class="cmt"><p>shape of the NDArray.</p></dd><dt class="param">ctx</dt><dd class="cmt"><p>The context of the NDArray, default to current default context.
</p></dd><dt>returns</dt><dd class="cmt"><p>The created NDArray.
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#eq" visbl="pub">
<a id="eq(x$1:AnyRef):Boolean"></a>
<a id="eq(AnyRef):Boolean"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@eq(x$1:AnyRef):Boolean" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#equal" visbl="pub">
<a id="equal(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="equal(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">equal</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@equal(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#equal" visbl="pub">
<a id="equal(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="equal(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">equal</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@equal(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.
For each element in input arrays, return 1(true) if corresponding elements are same,
otherwise return 0(false).
</p></div></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#equals" visbl="pub">
<a id="equals(x$1:Any):Boolean"></a>
<a id="equals(Any):Boolean"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@equals(x$1:Any):Boolean" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#finalize" visbl="prt">
<a id="finalize():Unit"></a>
<a id="finalize():Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@finalize():Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a class="extype" href="../../../java$lang.html" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
<span class="name">@throws</span><span class="args">(<span>
<span class="symbol">classOf[java.lang.Throwable]</span>
</span>)</span>
</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#full" visbl="pub">
<a id="full(shape:org.apache.mxnet.Shape,value:Float,ctx:org.apache.mxnet.Context):org.apache.mxnet.NDArray"></a>
<a id="full(Shape,Float,Context):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">full</span><span class="params">(<span name="shape">shape: <a class="extype" href="Shape.html" name="org.apache.mxnet.Shape">Shape</a></span>, <span name="value">value: <span class="extype" name="scala.Float">Float</span></span>, <span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a> = <span class="symbol">null</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@full(shape:org.apache.mxnet.Shape,value:Float,ctx:org.apache.mxnet.Context):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Create a new NDArray filled with given value, with specified shape.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new NDArray filled with given value, with specified shape.</p></div><dl class="paramcmts block"><dt class="param">shape</dt><dd class="cmt"><p>shape of the NDArray.</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be filled with</p></dd><dt class="param">ctx</dt><dd class="cmt"><p>The context of the NDArray, default to current default context
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#getClass" visbl="pub">
<a id="getClass():Class[_]"></a>
<a id="getClass():Class[_]"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@getClass():Class[_]" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#getFirstResult" visbl="pub">
<a id="getFirstResult(ret:org.apache.mxnet.NDArrayFuncReturn):org.apache.mxnet.NDArray"></a>
<a id="getFirstResult(NDArrayFuncReturn):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">implicit </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">getFirstResult</span><span class="params">(<span name="ret">ret: <span class="extype" name="org.apache.mxnet.NDArrayFuncReturn">NDArrayFuncReturn</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@getFirstResult(ret:org.apache.mxnet.NDArrayFuncReturn):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#greater" visbl="pub">
<a id="greater(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="greater(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">greater</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@greater(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#greater" visbl="pub">
<a id="greater(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="greater(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">greater</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@greater(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns the result of element-wise **greater than** (&gt;) comparison operation
with broadcasting.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of element-wise **greater than** (&gt;) comparison operation
with broadcasting.
For each element in input arrays, return 1(true) if lhs elements are greater than rhs,
otherwise return 0(false).
</p></div></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#greaterEqual" visbl="pub">
<a id="greaterEqual(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="greaterEqual(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">greaterEqual</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@greaterEqual(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#greaterEqual" visbl="pub">
<a id="greaterEqual(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="greaterEqual(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">greaterEqual</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@greaterEqual(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns the result of element-wise **greater than or equal to** (&gt;=) comparison
operation with broadcasting.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of element-wise **greater than or equal to** (&gt;=) comparison
operation with broadcasting.
For each element in input arrays, return 1(true) if lhs elements are greater than equal to rhs,
otherwise return 0(false).
</p></div></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#hashCode" visbl="pub">
<a id="hashCode():Int"></a>
<a id="hashCode():Int"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@hashCode():Int" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.Any#isInstanceOf" visbl="pub">
<a id="isInstanceOf[T0]:Boolean"></a>
<a id="isInstanceOf[T0]:Boolean"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@isInstanceOf[T0]:Boolean" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#lesser" visbl="pub">
<a id="lesser(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="lesser(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">lesser</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@lesser(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#lesser" visbl="pub">
<a id="lesser(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="lesser(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">lesser</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@lesser(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns the result of element-wise **lesser than** (&lt;) comparison operation
with broadcasting.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of element-wise **lesser than** (&lt;) comparison operation
with broadcasting.
For each element in input arrays, return 1(true) if lhs elements are less than rhs,
otherwise return 0(false).
</p></div></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#lesserEqual" visbl="pub">
<a id="lesserEqual(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="lesserEqual(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">lesserEqual</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@lesserEqual(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#lesserEqual" visbl="pub">
<a id="lesserEqual(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="lesserEqual(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">lesserEqual</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@lesserEqual(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison
operation with broadcasting.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of element-wise **lesser than or equal to** (&lt;=) comparison
operation with broadcasting.
For each element in input arrays, return 1(true) if lhs elements are
lesser than equal to rhs, otherwise return 0(false).
</p></div></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#load" visbl="pub">
<a id="load(fname:String):(Array[String],Array[org.apache.mxnet.NDArray])"></a>
<a id="load(String):(Array[String],Array[NDArray])"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">load</span><span class="params">(<span name="fname">fname: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: (<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Predef.String">String</span>], <span class="extype" name="scala.Array">Array</span>[<a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>])</span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@load(fname:String):(Array[String],Array[org.apache.mxnet.NDArray])" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Load ndarray from binary file.</p><div class="fullcomment"><div class="comment cmt"><p>Load ndarray from binary file.</p><p>You can also use pickle to do the job if you only work on python.
The advantage of load/save is the file is language agnostic.
This means the file saved using save can be loaded by other language binding of mxnet.
You also get the benefit being able to directly load/save from cloud storage(S3, HDFS)
</p></div><dl class="paramcmts block"><dt class="param">fname</dt><dd class="cmt"><p>
    The name of the file.Can be S3 or HDFS address (remember built with S3 support).
    Example of fname:</p><ul><li><code>s3://my-bucket/path/my-s3-ndarray</code></li><li><code>hdfs://my-bucket/path/my-hdfs-ndarray</code></li><li><code>/path-to/my-local-ndarray</code></li></ul></dd><dt>returns</dt><dd class="cmt"><p>dict of str-&gt;NDArray to be saved
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#load2Array" visbl="pub">
<a id="load2Array(fname:String):Array[org.apache.mxnet.NDArray]"></a>
<a id="load2Array(String):Array[NDArray]"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">load2Array</span><span class="params">(<span name="fname">fname: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>]</span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@load2Array(fname:String):Array[org.apache.mxnet.NDArray]" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#load2Map" visbl="pub">
<a id="load2Map(fname:String):Map[String,org.apache.mxnet.NDArray]"></a>
<a id="load2Map(String):Map[String,NDArray]"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">load2Map</span><span class="params">(<span name="fname">fname: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>]</span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@load2Map(fname:String):Map[String,org.apache.mxnet.NDArray]" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#maximum" visbl="pub">
<a id="maximum(lhs:Float,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="maximum(Float,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">maximum</span><span class="params">(<span name="lhs">lhs: <span class="extype" name="scala.Float">Float</span></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@maximum(lhs:Float,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#maximum" visbl="pub">
<a id="maximum(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="maximum(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">maximum</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@maximum(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#maximum" visbl="pub">
<a id="maximum(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="maximum(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">maximum</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@maximum(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#minimum" visbl="pub">
<a id="minimum(lhs:Float,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="minimum(Float,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">minimum</span><span class="params">(<span name="lhs">lhs: <span class="extype" name="scala.Float">Float</span></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@minimum(lhs:Float,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#minimum" visbl="pub">
<a id="minimum(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="minimum(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">minimum</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@minimum(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#minimum" visbl="pub">
<a id="minimum(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="minimum(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">minimum</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@minimum(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#ne" visbl="pub">
<a id="ne(x$1:AnyRef):Boolean"></a>
<a id="ne(AnyRef):Boolean"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ne(x$1:AnyRef):Boolean" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#notEqual" visbl="pub">
<a id="notEqual(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="notEqual(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">notEqual</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@notEqual(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#notEqual" visbl="pub">
<a id="notEqual(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="notEqual(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">notEqual</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@notEqual(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Returns the result of element-wise **not equal to** (!=) comparison operation
with broadcasting.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of element-wise **not equal to** (!=) comparison operation
with broadcasting.
For each element in input arrays, return 1(true) if corresponding elements are different,
otherwise return 0(false).
</p></div></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#notify" visbl="pub">
<a id="notify():Unit"></a>
<a id="notify():Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@notify():Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#notifyAll" visbl="pub">
<a id="notifyAll():Unit"></a>
<a id="notifyAll():Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@notifyAll():Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#onehotEncode" visbl="pub">
<a id="onehotEncode(indices:org.apache.mxnet.NDArray,out:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="onehotEncode(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">onehotEncode</span><span class="params">(<span name="indices">indices: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="out">out: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@onehotEncode(indices:org.apache.mxnet.NDArray,out:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">One hot encoding indices into matrix out.</p><div class="fullcomment"><div class="comment cmt"><p>One hot encoding indices into matrix out.</p></div><dl class="paramcmts block"><dt class="param">indices</dt><dd class="cmt"><p>An NDArray containing indices of the categorical features.</p></dd><dt class="param">out</dt><dd class="cmt"><p>The result holder of the encoding.</p></dd><dt>returns</dt><dd class="cmt"><p>Same as out.
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#ones" visbl="pub">
<a id="ones(ctx:org.apache.mxnet.Context,shape:Int*):org.apache.mxnet.NDArray"></a>
<a id="ones(Context,Int*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ones</span><span class="params">(<span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a></span>, <span name="shape">shape: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ones(ctx:org.apache.mxnet.Context,shape:Int*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#ones" visbl="pub">
<a id="ones(shape:Int*):org.apache.mxnet.NDArray"></a>
<a id="ones(Int*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ones</span><span class="params">(<span name="shape">shape: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ones(shape:Int*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#ones" visbl="pub">
<a id="ones(shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context,dtype:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray"></a>
<a id="ones(Shape,Context,DType):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">ones</span><span class="params">(<span name="shape">shape: <a class="extype" href="Shape.html" name="org.apache.mxnet.Shape">Shape</a></span>, <span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a> = <span class="symbol">null</span></span>, <span name="dtype">dtype: <a class="extmbr" href="DType$.html#DType=org.apache.mxnet.DType.Value" name="org.apache.mxnet.DType.DType">DType</a> = <span class="symbol">Base.MX_REAL_TYPE</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@ones(shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context,dtype:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Create a new NDArray filled with 1, with specified shape.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new NDArray filled with 1, with specified shape.</p></div><dl class="paramcmts block"><dt class="param">shape</dt><dd class="cmt"><p>shape of the NDArray.</p></dd><dt class="param">ctx</dt><dd class="cmt"><p>The context of the NDArray, default to current default context.</p></dd><dt>returns</dt><dd class="cmt"><p>The created NDArray.
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#power" visbl="pub">
<a id="power(lhs:Float,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="power(Float,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">power</span><span class="params">(<span name="lhs">lhs: <span class="extype" name="scala.Float">Float</span></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@power(lhs:Float,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#power" visbl="pub">
<a id="power(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray"></a>
<a id="power(NDArray,Float):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">power</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@power(lhs:org.apache.mxnet.NDArray,rhs:Float):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#power" visbl="pub">
<a id="power(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray"></a>
<a id="power(NDArray,NDArray):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">power</span><span class="params">(<span name="lhs">lhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>, <span name="rhs">rhs: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@power(lhs:org.apache.mxnet.NDArray,rhs:org.apache.mxnet.NDArray):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#save" visbl="pub">
<a id="save(fname:String,data:Traversable[org.apache.mxnet.NDArray]):Unit"></a>
<a id="save(String,Traversable[NDArray]):Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">save</span><span class="params">(<span name="fname">fname: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="data">data: <span class="extype" name="scala.Traversable">Traversable</span>[<a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@save(fname:String,data:Traversable[org.apache.mxnet.NDArray]):Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#save" visbl="pub">
<a id="save(fname:String,data:Map[String,org.apache.mxnet.NDArray]):Unit"></a>
<a id="save(String,Map[String,NDArray]):Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">save</span><span class="params">(<span name="fname">fname: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="data">data: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@save(fname:String,data:Map[String,org.apache.mxnet.NDArray]):Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Save list of NDArray or dict of str-&gt;NDArray to binary file.</p><div class="fullcomment"><div class="comment cmt"><p>Save list of NDArray or dict of str-&gt;NDArray to binary file.</p><p>You can also use pickle to do the job if you only work on python.
The advantage of load/save is the file is language agnostic.
This means the file saved using save can be loaded by other language binding of mxnet.
You also get the benefit being able to directly load/save from cloud storage(S3, HDFS)
</p></div><dl class="paramcmts block"><dt class="param">fname</dt><dd class="cmt"><p>
    The name of the file.Can be S3 or HDFS address (remember built with S3 support).
    Example of fname:</p><ul><li><code>s3://my-bucket/path/my-s3-ndarray</code></li><li><code>hdfs://my-bucket/path/my-hdfs-ndarray</code></li><li><code>/path-to/my-local-ndarray</code></li></ul></dd><dt class="param">data</dt><dd class="cmt"><p>dict of str-&gt;NDArray
</p></dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#synchronized" visbl="pub">
<a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
<a id="synchronized[T0](⇒T0):T0"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@synchronized[T0](x$1:=&gt;T0):T0" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#toString" visbl="pub">
<a id="toString():String"></a>
<a id="toString():String"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@toString():String" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#wait" visbl="pub">
<a id="wait():Unit"></a>
<a id="wait():Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@wait():Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
<span class="name">@throws</span><span class="args">(<span>
<span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
</span>)</span>
</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#wait" visbl="pub">
<a id="wait(x$1:Long,x$2:Int):Unit"></a>
<a id="wait(Long,Int):Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@wait(x$1:Long,x$2:Int):Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
<span class="name">@throws</span><span class="args">(<span>
<span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
</span>)</span>
</dd></dl></div>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="scala.AnyRef#wait" visbl="pub">
<a id="wait(x$1:Long):Unit"></a>
<a id="wait(Long):Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier">final </span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@wait(x$1:Long):Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
<span class="name">@throws</span><span class="args">(<span>
<span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
</span>)</span>
</dd></dl></div>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#waitall" visbl="pub">
<a id="waitall():Unit"></a>
<a id="waitall():Unit"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">waitall</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@waitall():Unit" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Wait all async operation to finish in MXNet
This function is used for benchmark only
</p>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#zeros" visbl="pub">
<a id="zeros(ctx:org.apache.mxnet.Context,shape:Int*):org.apache.mxnet.NDArray"></a>
<a id="zeros(Context,Int*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">zeros</span><span class="params">(<span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a></span>, <span name="shape">shape: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@zeros(ctx:org.apache.mxnet.Context,shape:Int*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="no" group="Ungrouped" name="org.apache.mxnet.NDArray#zeros" visbl="pub">
<a id="zeros(shape:Int*):org.apache.mxnet.NDArray"></a>
<a id="zeros(Int*):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">zeros</span><span class="params">(<span name="shape">shape: <span class="extype" name="scala.Int">Int</span>*</span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@zeros(shape:Int*):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
</li><li data-isabs="false" fullcomment="yes" group="Ungrouped" name="org.apache.mxnet.NDArray#zeros" visbl="pub">
<a id="zeros(shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context,dtype:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray"></a>
<a id="zeros(Shape,Context,DType):NDArray"></a>
<h4 class="signature">
<span class="modifier_kind">
<span class="modifier"></span>
<span class="kind">def</span>
</span>
<span class="symbol">
<span class="name">zeros</span><span class="params">(<span name="shape">shape: <a class="extype" href="Shape.html" name="org.apache.mxnet.Shape">Shape</a></span>, <span name="ctx">ctx: <a class="extype" href="Context.html" name="org.apache.mxnet.Context">Context</a> = <span class="symbol">null</span></span>, <span name="dtype">dtype: <a class="extmbr" href="DType$.html#DType=org.apache.mxnet.DType.Value" name="org.apache.mxnet.DType.DType">DType</a> = <span class="symbol">Base.MX_REAL_TYPE</span></span>)</span><span class="result">: <a class="extype" href="NDArray.html" name="org.apache.mxnet.NDArray">NDArray</a></span>
</span>
</h4><span class="permalink">
<a href="../../../index.html#org.apache.mxnet.NDArray$@zeros(shape:org.apache.mxnet.Shape,ctx:org.apache.mxnet.Context,dtype:org.apache.mxnet.DType.DType):org.apache.mxnet.NDArray" target="_top" title="Permalink">
<img src="../../../lib/permalink.png"/>
</a>
</span>
<p class="shortcomment cmt">Create a new NDArray filled with 0, with specified shape.</p><div class="fullcomment"><div class="comment cmt"><p>Create a new NDArray filled with 0, with specified shape.
</p></div><dl class="paramcmts block"><dt class="param">shape</dt><dd class="cmt"><p>shape of the NDArray.</p></dd><dt class="param">ctx</dt><dd class="cmt"><p>The context of the NDArray, default to current default context.
</p></dd><dt>returns</dt><dd class="cmt"><p>The created NDArray.
</p></dd></dl></div>
</li></ol>
</div>

<div id="inheritedMembers">
<div class="parent" name="org.apache.mxnet.NDArrayBase">
<h3>Inherited from <a class="extype" href="NDArrayBase.html" name="org.apache.mxnet.NDArrayBase">NDArrayBase</a></h3>
</div><div class="parent" name="scala.AnyRef">
<h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
</div><div class="parent" name="scala.Any">
<h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
</div>
</div>
<div id="groupedMembers">
<div class="group" name="Ungrouped">
<h3>Ungrouped</h3>
</div>
</div>

<div id="tooltip"></div>
<div id="footer"> </div>

